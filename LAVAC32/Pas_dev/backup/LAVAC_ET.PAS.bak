{************************************************}
{                                                }
{   Programme Lavac_cr                           }
{                                                }
{   Projet LAVAC                                 }
{                                                }
{  (c) 1992-94 C Puissance 3 Informatique        }
{              MORGAN MULTIMEDIA                 }
{                                                }
{  par Guillaume de Bailliencourt                }
{                                                }
{  02/02/1994                                    }
{                                                }
{************************************************}

{ VideoLoc: variable globale définie dans le module MMLAVAC.PAS. Il s'agit
						d'un booléen prenant la valeur true
						si la vidéo peut être jouée
            en local et FALSE sinon}

program LAVAC_ET;

{*************************************************************}

{$Define _Eleve} {Directive utilisée dans l'unité UQcmLavc. Celle-ci doit
									donc être recompilée à chaque changement de module}

uses Windows, Dos, SysUtils,
		 CommDlg, mmsystem, VFW, Strings, {toolhelp,}
		 LZExpand,
		 {BWCC,}     {-- Pour les fonctions Borland --}
		 MMLAVAC,  {-- Pour les fonctions propres à LAVAC --}
		 MMDIADIR, {--pour le dialogue--}
		 MMDIB,    {-- Pour les fonctions Multimédia --}
		 MMSTRING,
		 MMMCI,  {-- Pour les fonctions propres aux commandes LAVAC/MCI --}
		 MMWAVE,
                 {$IFDEF _TUTOR}
		 UQcmLavc, {-- Interface Lavac et QCM Object --}
		 UOleInit, {-- Initialisation OLE et flux --}
		 UQcmType, {-- Constantes QCM --}
		 UQcmWin,
		 UQcmRep,
		 UTutDlg,
                 {$ENDIF}
		 mmDrwDib,
		 MCIWnd,
		 CTL3D,
		 MMLic,
		 licData,
		 lavacini,
		 ShellApi,
		 MultiSel,

		 mmHelper,

		 RichEdit, Unit1, xmlparser, PerMonitorApi
		 {$IFDEF _DEBUG}
		 ,MMDEBUG
		 {$ENDIF};


{*************************************************************}
{***             Déclarations des constantes globales      ***}
{*************************************************************}
const
{$IFDEF _E0}
	AppName = 'LAVAC_MK';                { Nom de l'application }
{$ELSE}
	AppName = 'LAVAC_ET';                { Nom de l'application }
{$ENDIF}

{$R ..\Res_Dev\LAVAC32x64.RES}

{$IFDEF _ASSIST}
		{$R MABITMAP.RES}
{$ENDIF}

{*************************************************************}
{***              Déclarations des variables globales      ***}
{*************************************************************}
const
		lpOldBmpProc		: TFarProc = nil;
		lpOldTxtProc		: TFarProc = nil;
		lpOldSeqProc	        : TFarProc = nil;
                lpOldStsProc	        : TFarProc = nil;
		FrameWin 				: HWND = 0;
		hRichedLib			: THINSTANCE = 0;

var
		OldExitProc : pointer;

		hOption : HWND;

		hItem : HWnd;
		rcItem : TRECT;

//		hApp : HWnd;
//		rcApp : TRECT;
		lpAppProc : TFarProc;

		hFrame : HWnd;
		rcFrame : TRECT;
		lpFrameProc : TFarProc;

var CommandLine : szLongName;       { Ligne de commande    }
		StrEleveRep : szLongName;       {                      }
		correction : Boolean;           { Etat de la session Correction = TRUE}
		NoLecon :Integer;               { Numéro de leçon      }

{-- Pour l'utilisation des ressources --}

{*************************************************************}
{***            Implémentation du module élève             ***}
{*************************************************************}

{$R-}

{*************************************************************}
{**                Fonction AttenteProc                     **}
{** SE: Procédure de traitement des messages envoyés        **}
{**     à la fenêtre video ...                              **}
{** SI: En fonction des messages envoyés à la fenêtre.      **}
{*************************************************************}

function AttenteProc(Fen: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var
		szOldFile,
		szSource, szCible,
		szDir, szDir1 : szLongName;
		szNom, szNom1, szCompteur : Array[0..9] of Char;
		szExt, szExt1 : Array[0..4] of Char;
		bFind,
		bOk : Boolean;
		DirInfo : TSearchRec;
		nNombreFichier : integer;
		pszFile : PCHAR;
		dwSize,
		dwRet : DWORD;
		MSG : TMSG;
		MciCommandStr : TMCISTR;

const
		nPercent : integer = 0;
		lTotalSize : Longint = 0;
		lCurSize : Longint = 0;

begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+1, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	AttenteProc := TRUE;
	case Message of
		WM_INITDIALOG :
			begin

				CenterDialog(Fen);
				SetDlgItemText(Fen, 1002, '');

				ShowWindow(Fen, SW_SHOW);
				UpdateWindow(Fen);

				{post UM_ATTENTE
				if VideoLoc then begin
					PostMessage(Fen, UM_ATTENTE, 0, 0);
				end else begin
					EndDialog(Fen, 1);
				end;
			end;

		UM_ATTENTE:
			begin}

				{#### GDB 4/12/96 Test if ...\QUESTION.LST exist before copying video to local drive }
				StrCopy(PathFichier,tLecon.PathLecon);
				StrCat(PathFichier, '\QUESTION.LST');
				if VideoLoc AND
					 FileExist(PathFichier) then begin

					SetCursor(LoadCursor(0,IDC_WAIT));
					lTotalSize := 0;
					lCurSize := 0;
					nNombreFichier := 0;
					{Créer la liste des fichiers vidéos contenus dans lecons.lst}
					FileMode := OF_SHARE_DENY_NONE OR  0;
					Assign(fQuestion,PChar(PathFichier));
					{$i-}
					reset(fQuestion);
					{$i+}
					while (IOResult = 0) AND NOT EOF(fQuestion) do begin
						SetCursor(LoadCursor(0,IDC_WAIT));
						{$i-}
						Read(fQuestion, tQuestion);
						{$i+}
						{ #### GDB 04/12/96 Add Dynapath support for local video }
						if bDynaPath AND
							 (tQuestion.FichierGraph[0] <> #0) AND
							 {(UpCase(PathLecons[0]) <> UpCase(tQuestion.FichierGraph[0])) AND}
							 (StrPos(tQuestion.FichierGraph, 'LAVAC\LECONS') <> nil) then begin
							UpdatePath(tQuestion.FichierGraph, tLecon.PathLecon);
							{tQuestion.FichierGraph[0] := PathLecons[0];}
						end;

						if IsVideoFile(tQuestion.FichierGraph) then begin
							FindFirst(tQuestion.FichierGraph, faAnyFile, DirInfo);
							if DosError <> 0 then begin
								DirInfo.Size := 0;
							end;
							pszFile := StrUpper(tQuestion.FichierGraph);
							if SendDlgItemMessage(Fen, 101, LB_FINDSTRINGEXACT, 0, LongInt(pszFile)) = LB_ERR then begin
								dwRet := SendDlgItemMessage(Fen, 101, LB_ADDSTRING, 0, LongInt(pszFile));
								if (dwRet <> LB_ERR) AND
									 (dwRet <> LB_ERRSPACE) then begin
									SendDlgItemMessage(Fen, 101, LB_SETITEMDATA, WORD(dwRet), DirInfo.Size);
								end;
								inc(nNombreFichier);
								inc(lTotalSize, DirInfo.Size);
							end;
							if bVideoWave then begin
								tQuestion.FichierGraph[StrLen(tQuestion.FichierGraph) - 3] := 'W';
								tQuestion.FichierGraph[StrLen(tQuestion.FichierGraph) - 2] := 'A';
								tQuestion.FichierGraph[StrLen(tQuestion.FichierGraph) - 1] := 'V';
								FindFirst(tQuestion.FichierGraph, faAnyFile, DirInfo);
								if DosError <> 0 then begin
									DirInfo.Size := 0;
								end;
								pszFile := StrUpper(tQuestion.FichierGraph);
								if SendDlgItemMessage(Fen, 101, LB_FINDSTRINGEXACT, 0, LongInt(pszFile)) = LB_ERR then begin
									dwRet := SendDlgItemMessage(Fen, 101, LB_ADDSTRING, 0, LongInt(pszFile));
									if (dwRet <> LB_ERR) AND
										 (dwRet <> LB_ERRSPACE) then begin
										SendDlgItemMessage(Fen, 101, LB_SETITEMDATA, WORD(dwRet), DirInfo.Size);
									end;
									inc(nNombreFichier);
									inc(lTotalSize, DirInfo.Size);
								end;
							end;
						end;
					end;
					{$i-}
					close(fQuestion);
					{$i+}
					if InOutRes <> 0 then begin
						wvsprintf(szMessage, mmLoadString(hInstRes, ERR_IONUM), @InOutRes);
						Messagebox(window, szMessage, '', MB_OK);
						InOutRes := 0;
					end;
					FileMode := OF_SHARE_DENY_NONE OR  2;

					{while PeekMessage(MSG, 0, 0, 0,PM_REMOVE) do begin
						TranslateMessage(MSG);
						DispatchMessage(MSG);
					end;}

					{Affiche le nombre de fichier à copier en local}
					SetDlgItemText(Fen, 1002, '0%');
					dec(nNombreFichier);

					{copie en local de tous les fichiers AVI de la liste}
					dwRet := SendDlgItemMessage(Fen, 101, LB_GETTEXT, nNombreFichier, LongInt(@szSource));
					dwSize := SendDlgItemMessage(Fen, 101, LB_GETITEMDATA, nNombreFichier, 0);
					while dwRet <> LB_ERR do begin
						SetCursor(LoadCursor(0,IDC_WAIT));
						{On éclate le nom}
						FileSplit(szSource, szDir, szNom, szExt);

						{On reconstitue le chemin}
						{####StrCopy(szCible, PathVideoLoc);
						StrCat(szCible, szNom);
						StrCat(szCible, szExt);}
						StrCopy(szCible, DonneNomLocal(szSource));

						{while PeekMessage(MSG, 0, 0, 0,PM_REMOVE) do begin
							TranslateMessage(MSG);
							DispatchMessage(MSG);
						end;}

						{On Stoppe la video en cours }
						{StrCopy(MciCommandStr, 'STOP VIDEO WAIT');
						mciSendString(MciCommandStr,nil,0,0);
						StrCopy(MciCommandStr, 'CLOSE VIDEO WAIT');
						mciSendString(MciCommandStr,nil,0,0);

						if bVideoWave then begin
							StrCopy(MciCommandStr, 'STOP SON WAIT');
							mciSendString(MciCommandStr,nil,0,0);
							StrCopy(MciCommandStr, 'CLOSE SON WAIT');
							mciSendString(MciCommandStr,nil,0,0);
						end;}

						{ On regarde s'il n'est pas présent dans le répertoire local }
						if (NOT FileExist(szCible)) OR
							 (FileExist(szCible) AND ((DateFichier(szSource) <> DateFichier(szCible)) OR
							 (dwSize <> TailleFichier(szCible)))) then begin
							bOK := (DiskFree(3) - TailleLoc >= dwSize);
							while NOT bOK do begin
								{On éclate le nom}
								FileSplit(szCible, szDir1, szNom1, szExt1);
								{####StrCopy(szDir1, PathVideoLoc);}
								StrCat(szDir1, '*.*');
								FindFirst(szDir1, faArchive, DirInfo);
								{On efface le 1° fichier AVI inutilisé par la leçon}
								bFind := FALSE;
								While DosError = 0 do begin
									SetCursor(LoadCursor(0,IDC_WAIT));
									{On reconstitue le chemin}
									StrCopy(szOldFile, szDir);
									StrCat(szOldFile, PChar(DirInfo.Name));
									StrUpper(szOldFile);
									dwRet := SendDlgItemMessage(Fen, 101, LB_FINDSTRINGEXACT, 0, LongInt(@szOldFile));
									if (dwRet = LB_ERR) OR
										 ((dwRet <> LB_ERR) AND (DirInfo.Size <> SendDlgItemMessage(Fen, 101, LB_GETITEMDATA, dwRet, 0))) then begin
										{On éclate le nom}
										FileSplit(szCible, szDir1, szNom1, szExt1);
										{On reconstitue le chemin}
										{####StrCopy(szOldFile, PathVideoLoc);}
										StrCopy(szOldFile, szDir1);
										StrCat(szOldFile, PChar(DirInfo.Name));
										Efface(szOldFile);
										bFind := TRUE;
										break;
									end;
									FindNext(DirInfo);
								end;
								bOK := (DiskFree(3) - TailleLoc >= dwSize) OR NOT bFind;
							end;
							if (DiskFree(3) - TailleLoc >= dwSize) then begin
								CopyFile(szSource, szCible);
							end;
						end;

						{Décrémente le compteur}
						inc(lCurSize, longint(dwSize));
						{#### GDB 21/2/97 Test if Total Size of video file <> 0 }
						if lTotalSize <> 0 then begin
							nPercent := lCurSize DIV (lTotalSize DIV 100);
						end else begin
							nPercent := 0;
						end;
						wvsprintf(szCompteur, '%d%%', @nPercent);
						SetDlgItemText(Fen, 1002, szCompteur);
						dec(nNombreFichier);
						dwRet := SendDlgItemMessage(Fen, 101, LB_GETTEXT, nNombreFichier, LongInt(@szSource));
						dwSize := SendDlgItemMessage(Fen, 101, LB_GETITEMDATA, nNombreFichier, 0);
					end;
					EndDialog(Fen, 1);
					UpdateWindow(hLeconProc);
				end;
		 end;
	end;
	AttenteProc := FALSE;
end;

procedure	CreateScriptBlock(hBut : HWND; idBut : integer; hLst : HWND; idLst, noSel, nMode : integer);
var  ReponseName : szLongName;      { Nom du fichier réponse   }
		 TempName,
		 szMCIPath	 : szLongName;
		 szPasStr : Array[0..255] of Char;
		 szRet : Array[0..255] of Char;
		 Position : Integer;            { Position dans les leçons }
		 fText		: text;
		 nVal,
		 lRet			: integer;
		 bOnReturn : BOOL;
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+4, 0, 0, 0, nil, TRUE);
	{$ENDIF}

		GetQuestionRec(ListeSelectInt[noSel] + 1, tQuestion);

                //
                //tQuestion.ReponseTexte:=false;
                //

		{-- Lire commandes MCI à exécuter -- }
		if (idBut = idb_PlayQ) OR
			 (idBut = idb_PlayQR) OR
			 (idBut = idb_PriseNotes) OR
			 (idBut = idb_RecordR) then
		if (tQuestion.FichierMCI[0] <> #0) then begin
				StrCopy(szMCIPath, tLecon.PathLecon);
				StrCat(szMCIPath, '\');
				StrCat(szMCIPath, tQuestion.FichierMCI);
				StrCat(szMCIPath, '.CMD');
				if FileExist(szMCIPath) then begin
					 Assign(fText, PChar(szMCIPath));
					 reset(fText);
					 while not eof(fText) do begin
							readln(fText, mciMessage);
							AddMciCmdQueueString(mciMessage);
					 end;
					 close(fText);
					 lRet := FindMciCmdQueueString('ON START');
					 if lRet <> LB_ERR then begin
							GetMciCmdQueueString(mciMessage, lRet);
							While GetMciCmdQueueString(mciMessage, lRet) AND
										(StrLIComp(mciMessage, 'END', 3) <> 0) do begin
								AddMciQueueString(mciMessage);
							end;
					 end;
					 lRet := FindMciCmdQueueString('ON STOP');
					 if lRet <> LB_ERR then begin
							While GetMciCmdQueueString(mciMessage, lRet) AND
										(StrLIComp(mciMessage, 'END', 3) <> 0) do begin
									AddMciQueueString(mciMessage);
							end;
							AddMciQueueString('END');
					 end;
				end;
		end;

		if nMode <> -1 then begin
			StrPCopy(mciMessage, 'SETFOCUS ' + IntToStr(ListeSelectInt[noSel]));
			AddMciQueueString(mciMessage);
		end;

		if nMode <> -1 then begin
			StrPCopy(mciMessage, 'SETPOSITION ' + IntToStr(NoElev) + ' ' + IntToStr(-1));
			AddMciQueueString(mciMessage);
		end;

		{ -- QCM -- }
		If NOT FileExist(tQuestion.FichierQcm) Then Begin
			StrCopy(mciMessage, 'HIDE $TUTWIN');
			AddMciQueueString(mciMessage);
		End;

		If NOT FileExist(tQuestion.FichierGraph) Then Begin
			ProcessOptionsBitmap(tQuestion, mciMessage);
			if StrPos(mciMessage, 'HIDEN') <> nil then begin
				StrCopy(mciMessage, 'HIDE $BMPWIN');
				AddMciQueueString(mciMessage);
			end;
		End;

		If NOT FileExist(tQuestion.FichierTexte) Then Begin
			ProcessOptionsText(tQuestion, mciMessage);
			if StrPos(mciMessage, 'HIDEN') <> nil then begin
				StrCopy(mciMessage, 'HIDE $TXTWIN');
				AddMciQueueString(mciMessage);
			end;
		End;

		{-- Il y a un fichier texte (.TXT) --}
		if (idBut = idb_PlayQ) OR
			 (idBut = idb_PlayR) OR
			 (idBut = idb_PlayQR) OR
			 (idBut = idb_PriseNotes) OR
			 (idBut = idb_RecordR) then
		if FileExist(tQuestion.FichierTexte) then begin
			StrCopy(mciMessage, 'DISPLAY ');
			StrCat(mciMessage,tQuestion.FichierTexte);
			{--Taille et style des fenêtres--}
			ProcessOptionsText(tQuestion, mciMessage);
			AddMciQueueString(mciMessage);
		end;

		{-- Il y a un fichier graphique (.BMP) ou vidéo (.AVI) --}
		if (idBut = idb_PlayQ) OR
			 (idBut = idb_PlayR) OR
			 (idBut = idb_PlayQR) OR
			 (idBut = idb_PriseNotes) OR
			 (idBut = idb_RecordR) then
		if FileExist(tQuestion.FichierGraph) then begin
			{-- Affiche le LED en vert pour la vidéo --}
			if IsVideoFile(tQuestion.FichierGraph) then begin
				StrPCopy(mciMessage, 'DISPLAYLED '+IntToStr(hLed_V));
				AddMciQueueString(mciMessage);

				StrPCopy(mciMessage, 'SETVOLUME FROM '+IntToStr(GetDlgItem(hLst, 106)));
				AddMciQueueString(mciMessage);

				{-- Envoie le message Mci dans la hButue MciQueue --}
				StrCopy(mciMessage, 'DISPLAY ');
				if VideoLoc AND
					 FileExist(DonneNomLocal(tQuestion.FichierGraph)) AND
					 (DateFichier(tQuestion.FichierGraph) = DateFichier(DonneNomLocal(tQuestion.FichierGraph))) AND
					 (TailleFichier(tQuestion.FichierGraph) = TailleFichier(DonneNomLocal(tQuestion.FichierGraph)))then
					StrCat(mciMessage,DonneNomLocal(tQuestion.FichierGraph))
				else
					StrCat(mciMessage,tQuestion.FichierGraph);
				{--Taille et style des fenêtres--}
				ProcessOptionsBitmap(tQuestion, mciMessage);
				AddMciQueueString(mciMessage);
				{-- Si fichier vidéo alors fermer le Mci à la fin --}
				{StrCopy(mciMessage, 'close video notify');
				AddMciQueueString(mciMessage);}
			end else begin
				{-- Envoie le message Mci dans la hButue MciQueue --}
				StrCopy(mciMessage, 'DISPLAY ');
				StrCat(mciMessage,tQuestion.FichierGraph);
				{--Taille et style des fenêtres--}
				ProcessOptionsBitmap(tQuestion, mciMessage);
				AddMciQueueString(mciMessage);
			end;
		end;

		{-- Il y a un fichier Son (.WAV) --}
		if (idBut = idb_PlayQ) OR
			 (idBut = idb_PlayQR) OR
			 (idBut = idb_PriseNotes) OR
			 (idBut = idb_RecordR) then
		if FileExist(tQuestion.FichierQuestion) then begin
			StrPCopy(mciMessage, 'DISPLAYLED '+IntToStr(hLed_V));
			AddMciQueueString(mciMessage);
			StrPCopy(mciMessage, 'SETVOLUME FROM '+IntToStr(GetDlgItem(hLst, 106)));
			AddMciQueueString(mciMessage);
			if tQuestion.wStyle AND QS_SOUNDBAR = 0 then begin
				StrCopy(mciMessage, 'OPEN ');
				StrCat(mciMessage,tQuestion.FichierQuestion);
				StrCat(mciMessage, ' ALIAS SON WAIT');
				AddMciQueueString(mciMessage);
				StrCopy(mciMessage, 'PLAY SON NOTIFY');
				AddMciQueueString(mciMessage);
				StrCopy(mciMessage, 'CLOSE SON WAIT');
				AddMciQueueString(mciMessage);
			end else begin
				StrCopy(mciMessage, 'MCIWND ');
				StrCat(mciMessage,tQuestion.FichierQuestion);
				wvsprintf(szPasStr, ' AT %d %d %d', @tQuestion.SndBarX);
				StrCat(mciMessage, szPasStr);
				AddMciQueueString(mciMessage);
				StrCopy(mciMessage, 'PAUSE');
				AddMciQueueString(mciMessage);
				StrCopy(mciMessage, 'CALL USER DESTROYWINDOW (WORD) $RETURN');
				AddMciQueueString(mciMessage);
			end;
			StrPCopy(mciMessage, 'DISPLAYLED '+IntToStr(hLed_N));
			AddMciQueueString(mciMessage);
		end;

		if tQuestion.Mode AND QM_PAUSE <> 0 then begin
			StrPCopy(mciMessage, 'PAUSE ' + IntToStr(tQuestion.wPause));
			AddMciQueueString(mciMessage);
		end;

		if (idBut = idb_PlayR) OR
			 (idBut = idb_PlayQR) then
		{ -- Jouer  Réponse texte -- }
		if tQuestion.ReponseTexte then begin
			StrPCopy(mciMessage, 'DisplayLed '+IntToStr(hLed_J));
			AddMciQueueString(mciMessage);

			ReponseTxtFileName(ReponseName,NoElev,ListeSelectInt[noSel]+1);
			if NOT FileExist(ReponseName) then begin
				ReponseRtfFileName(ReponseName,NoElev,ListeSelectInt[noSel]+1);
			end;
			if FileExist(ReponseName) then begin
				StrCopy(mciMessage, 'Display ');
				StrCat(mciMessage,ReponseName);
				AddMciQueueString(mciMessage);
				StrCopy(mciMessage, 'PAUSE 5000');
				AddMciQueueString(mciMessage);
			end;
		end;

		if (idBut = idb_PlayR) OR
			 (idBut = idb_PlayQR) then
		{ -- Jouer Réponse son -- }
		if tQuestion.ReponseSon then begin
			ReponseFileName(ReponseName, NoElev, ListeSelectInt[noSel] + 1);
			if FileExist(ReponseName) then begin
				StrPCopy(mciMessage, 'DisplayLed '+IntToStr(hLed_V));
				AddMciQueueString(mciMessage);

				StrPCopy(mciMessage, 'SetVolume from ' + IntToStr(GetDlgItem(hLst, 107)));
				AddMciQueueString(mciMessage);

				StrCopy(mciMessage, 'open ');
				StrCat(mciMessage,ReponseName);
				StrCat(mciMessage, ' alias son notify');
				AddMciQueueString(mciMessage);
				StrCopy(mciMessage, 'play son notify');
				AddMciQueueString(mciMessage);
				StrCopy(mciMessage, 'close son notify');
				AddMciQueueString(mciMessage);

				StrPCopy(mciMessage, 'DisplayLed '+IntToStr(hLed_N));
				AddMciQueueString(mciMessage);
			end;
		end;

		if (idBut = idb_RecordR) then
		{ -- Enreg  Réponse texte -- }
		if tQuestion.ReponseTexte then begin
			StrPCopy(mciMessage, 'DisplayLed '+IntToStr(hLed_J));
			AddMciQueueString(mciMessage);
			StrCopy(mciMessage, PathTextes);
			StrCat(mciMessage, 'RTF.New');
		{ Reprise Question }
			if BOOL(tQuestion.Mode AND QM_TXTAPPEND) then begin
				if (StrPos(StrUpper(tQuestion.FichierTexte), 'RTF') <> nil) then begin
					ReponseRtfFileName(ReponseName,NoElev, ListeSelectInt[noSel]+1);
				end else begin
					ReponseTxtFileName(ReponseName,NoElev, ListeSelectInt[noSel]+1);
				end;
				{ Reprise Réponse }
				if BOOL(tQuestion.Mode AND QM_TXTADDIN) then begin
					{ Séquence n }
					if tQuestion.bAddIn > 0 then begin
						ReponseRtfFileName(TempName, NoElev, tQuestion.bAddIn);
						if FileExist(TempName) then begin
							CopyFile(TempName, ReponseName);
						end else begin
						{ Séquence n n'existe pas }
							if FileExist(tQuestion.FichierTexte) then begin
								CopyFile(tQuestion.FichierTexte, ReponseName);
							end else begin
								ReponseRtfFileName(ReponseName, NoElev, ListeSelectInt[noSel]+1);
								CopyFile(mciMessage, ReponseName);
							end;
						end;
					end else begin
						{ Pas Séquence n }
						if NOT FileExist(ReponseName) then begin
							if FileExist(tQuestion.FichierTexte) then begin
								CopyFile(tQuestion.FichierTexte, ReponseName);
							end else begin
								ReponseRtfFileName(ReponseName, NoElev, ListeSelectInt[noSel]+1);
								CopyFile(mciMessage, ReponseName);
							end;
						end;
					end;
				end else begin
					{ Pas Reprise Réponse }
					if FileExist(tQuestion.FichierTexte) then begin
						CopyFile(tQuestion.FichierTexte, ReponseName);
					end else begin
						ReponseRtfFileName(ReponseName, NoElev, ListeSelectInt[noSel]+1);
						CopyFile(mciMessage, ReponseName);
					end;
				end;
			end else begin
				{ Pas Reprise Question }
				StrCopy(mciMessage, PathTextes);
				StrCat(mciMessage, 'RTF.New');
				ReponseRtfFileName(ReponseName, NoElev, ListeSelectInt[noSel]+1);
				{ Reprise Réponse }
				if BOOL(tQuestion.Mode AND QM_TXTADDIN) then begin
					{ Séquence n }
					if tQuestion.bAddIn > 0 then begin
						ReponseRtfFileName(TempName, NoElev, tQuestion.bAddIn);
						if FileExist(TempName) then begin
							CopyFile(TempName, ReponseName);
						end else begin
							{ Séquence n n'existe pas }
							CopyFile(mciMessage, ReponseName);
						end;
					end else begin
						{ Pas Séquence n }
						if NOT FileExist(ReponseName) then begin
							CopyFile(mciMessage, ReponseName);
						end;
					end;
				end else begin
					{ Pas Reprise Réponse }
					CopyFile(mciMessage, ReponseName);
				end;
			end;
			StrCopy(mciMessage, 'RequestText ');
			StrCat(mciMessage, ReponseName);
			if BOOL(tQuestion.Mode AND QM_TXTAPPEND) then begin
				StrCat(mciMessage, ' Append');
			end;
			if BOOL(tQuestion.Mode AND QM_TXTADDIN) then begin
				if BOOL(tQuestion.Mode AND QM_TXTADDREL) then begin
					if BOOL(tQuestion.Mode AND QM_TXTADDAFT) then begin
						lRet := ListeSelectInt[noSel]+ 1 + tQuestion.bAddIn;
					end else begin
						lRet := ListeSelectInt[noSel]+ 1 - tQuestion.bAddIn;
						if lRet < 1 then lRet := 1;
					end;
				end else begin
					{ Absolue }
					if tQuestion.bAddIn > 0 then begin
						lRet :=  tQuestion.bAddIn;
					end;
				end;
				if tQuestion.bAddIn = 0 then begin
					{ Courante }
					lRet := 0;
				end;
				StrPCopy(szPasStr, ' Addin ' + IntToStr(lRet));
				StrCat(mciMessage, szPasStr);
			end;
			if BOOL(tQuestion.Mode AND QM_TXTATRECT) then begin
				StrPCopy(szPasStr, ' At ' + IntToStr(tQuestion.rtx1) + ' '
				+ IntToStr(tQuestion.rty1) + ' '
				+ IntToStr(tQuestion.rtx2) + ' '
				+ IntToStr(tQuestion.rty2));

				StrCat(mciMessage, szPasStr);
			end;
			AddMciQueueString(mciMessage);
		end;

	if (idBut = idb_PriseNotes) then
		{ -- Prise de Notes -- }
		begin

                        ReponseFileName(ReponseName, NoElev, 0);
			StrCopy(mciMessage, 'open new type waveaudio alias rec wait');
			AddMciQueueString(mciMessage);
			StrPCopy(mciMessage, 'set rec '+
															'time format ms '+
															'channels '+IntToStr(1)+' '+
															'bitspersample '+IntToStr(wNbBits)+' '+
															'samplespersec '+IntToStr(FrequEch)+' '+
															'alignment '+IntToStr(wNbBits DIV 8)+' '+
															'bytespersec '+IntToStr(FrequEch * (wNbBits DIV 8))+' '+
															'wait');
			AddMciQueueString(mciMessage);


			nVal := 1;
			if FileExist(tQuestion.FichierQuestion) then begin
				StrCopy(mciMessage, 'open ');
				StrCat(mciMessage, tQuestion.FichierQuestion);
				StrCat(mciMessage, ' alias question wait');
				SendMci(mciMessage, @szRet, 0);
				StrCopy(mciMessage, 'status question length wait');
				if SendMci(mciMessage, @szRet, 0) = 0 then begin
					Val(szRet, nVal, lRet);
					if lRet <> 0 then begin
					   nVal := 1;
					end;
				end;
				StrCopy(mciMessage, 'close question wait');
				SendMci(mciMessage, @szRet, 0);
			end;

			StrPCopy(mciMessage, 'DisplayLed ' + IntToStr(hLed_J) + ' ' + IntToStr((longint(nVal) * DilateDuree) DIV 100));
			AddMciQueueString(mciMessage);

			//StrPCopy(mciMessage, 'PAUSE ' + ' ' + IntToStr((longint(nVal) * DilateDuree) DIV 100));
			//AddMciQueueString(mciMessage);

			StrPCopy(mciMessage, 'record rec from 0 to '
								 + IntToStr((longint(nVal) * DilateDuree) DIV 100)
								 + ' notify');
			AddMciQueueString(mciMessage);

			StrPCopy(mciMessage, 'DisplayLed '+IntToStr(hLed_N));
			AddMciQueueString(mciMessage);

			StrCopy(mciMessage, 'save rec ');
			StrCat(mciMessage, ReponseName);
			StrCat(mciMessage, ' wait');
			AddMciQueueString(mciMessage);

			StrCopy(mciMessage, 'close rec wait');
			AddMciQueueString(mciMessage);

			StrCopy(mciMessage, 'Share ');
			StrCat(mciMessage, ReponseName);
			AddMciQueueString(mciMessage);
	end;

	if (idBut = idb_RecordR) then
		{ -- Enreg  Réponse son -- }
		if tQuestion.ReponseSon AND (tQuestion.DureeReponse <> 0) then begin
			ReponseFileName(ReponseName, NoElev, ListeSelectInt[noSel]+1);
			if tQuestion.wStyle AND QS_RECIN = 0 then begin
				StrCopy(mciMessage, 'open new type waveaudio alias rec wait');
				AddMciQueueString(mciMessage);
				if NOT bRecDefault then begin
					StrPCopy(mciMessage, 'set rec '+
															'time format ms '+
															'channels '+IntToStr(1)+' '+
															'bitspersample '+IntToStr(wNbBits)+' '+
															'samplespersec '+IntToStr(FrequEch)+' '+
															'alignment '+IntToStr(wNbBits DIV 8)+' '+
															'bytespersec '+IntToStr(FrequEch * (wNbBits DIV 8))+' '+
															{'format tag PCM '+}
															'wait');
					AddMciQueueString(mciMessage);
				end;
			end else begin
				if tQuestion.bRecIn <> 0 then begin
					ReponseFileName(TempName, NoElev, tQuestion.bRecIn);
					if FileExist(TempName) then begin
						CopyFile(TempName, ReponseName);
					end;
				end;
				if FileExist(ReponseName) then begin
					StrCopy(mciMessage, 'open ');
					StrCat(mciMessage, ReponseName);
					StrCat(mciMessage, ' type waveaudio alias rec wait');
					AddMciQueueString(mciMessage);
				end else begin
					StrCopy(mciMessage, 'open new type waveaudio alias rec wait');
					AddMciQueueString(mciMessage);
					if NOT bRecDefault then begin
						StrPCopy(mciMessage, 'set rec '+
																'time format ms '+
																'channels '+IntToStr(1)+' '+
																'bitspersample '+IntToStr(wNbBits)+' '+
																'samplespersec '+IntToStr(FrequEch)+' '+
																'alignment '+IntToStr(wNbBits DIV 8)+' '+
																'bytespersec '+IntToStr(FrequEch * (wNbBits DIV 8))+' '+
																{'format tag PCM '+}
																'wait');
						AddMciQueueString(mciMessage);
					end;
				end;
			end;

			StrPCopy(mciMessage, 'DisplayLed ' + IntToStr(hLed_R) + ' ' + IntToStr(longint(tQuestion.DureeReponse) * 10 * DilateDuree));
			AddMciQueueString(mciMessage);

			if tQuestion.wStyle AND QS_RECIN = 0 then begin
				StrPCopy(mciMessage, 'record rec from 0 to '
								 + IntToStr(longint(tQuestion.DureeReponse) * 10 * DilateDuree)
								 + ' notify');
			end else begin
				nVal := 0;
				if tQuestion.bRecIn = 0 then begin
					tQuestion.bRecIn := ListeSelectInt[noSel] + 1;
				end;
				ReponseFileName(TempName, NoElev, tQuestion.bRecIn);
				if FileExist(TempName) then begin
					StrCopy(mciMessage, 'open ');
					StrCat(mciMessage, TempName);
					StrCat(mciMessage, ' alias prevrec wait');
					SendMci(mciMessage, @szRet, 0);
					StrCopy(mciMessage, 'status prevrec length wait');
					if SendMci(mciMessage, @szRet, 0) = 0 then begin
						Val(szRet, nVal, lRet);
						if lRet <> 0 then begin
							nVal := 0;
						end;
					end;
					StrCopy(mciMessage, 'close prevrec wait');
					SendMci(mciMessage, @szRet, 0);
				end;
				StrPCopy(mciMessage, 'record rec from '
								 + IntToStr(nVal)
								 + ' to '
								 + IntToStr(longint(tQuestion.DureeReponse) * 10 * DilateDuree + nVal)
								 + ' notify');
			end;
			AddMciQueueString(mciMessage);

			StrPCopy(mciMessage, 'DisplayLed '+IntToStr(hLed_N));
			AddMciQueueString(mciMessage);

			StrCopy(mciMessage, 'save rec ');
			StrCat(mciMessage, ReponseName);
			StrCat(mciMessage, ' wait');
			AddMciQueueString(mciMessage);

			StrCopy(mciMessage, 'close rec wait');
			AddMciQueueString(mciMessage);

			StrCopy(mciMessage, 'Share ');
			StrCat(mciMessage, ReponseName);
			AddMciQueueString(mciMessage);

	end;

	{ -- QCM -- }
	If FileExist(tQuestion.FichierQcm) Then Begin

		StrPCopy(mciMessage, 'SETVOLUME FROM '+IntToStr(GetDlgItem(hLst, 106)));
		AddMciQueueString(mciMessage);

                {$IFDEF _TUTOR}
		{WriteLn('PlayQcm ',tQuestion.FichierQcm);}
		StrCopy(mciMessage, 'PLayQcm ');
		StrCat(mciMessage, tQuestion.FichierQcm);
		ProcessQcmId(ListeSelectInt[noSel]+1, mciMessage);
		ProcessQcmWinPos(tQuestion, mciMessage);
		{ -- On affche sans jouer -- }
		if (idBut <> idb_RecordR) then begin
			StrCat(mciMessage, ' NOTIFY');
		end;
		AddMciQueueString(mciMessage);
                {$ENDIF}
	End;

	//if (idBut = idb_RecordR) then begin
        if ((idBut = idb_PlayQ) OR (idBut = idb_RecordR)) then begin
		nbQuestion := SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_GETCOUNT, 0, 0);
                GetEtudiantRec(NoElev,tEtudiant);
                tEtudiant.MaxPoints := nbQuestion;
                tEtudiant.Minpoints := 2;
                SetEtudiantRec(NoElev,tEtudiant);
		QuestionsPrevues := QuestionsPrevues + 1;
		if QuestionsPrevues > nbQuestion then QuestionsPrevues := nbQuestion;
		Position := (QuestionsPrevues * 100) DIV nbQuestion;
		StrPCopy(mciMessage, 'SetPosition '+IntToStr(NoElev) +' ' + IntToStr(Position));
		AddMciQueueString(mciMessage);
	end;

	{-- Déselectionner le chapitre --}
	if nMode <> -1 then begin
		StrPCopy(mciMessage, 'UnSelect '+IntToStr(ListeSelectInt[noSel] + 1));
		AddMciQueueString(mciMessage);
	end;

		{ -- Il y a un fichier a excuter -- }
		if (idBut = idb_PlayQ) OR
			 (idBut = idb_PlayQR) OR
			 (idBut = idb_RecordR) then
		if tQuestion.FichierExecutable[0] <> #0 then begin
			 StrCopy(mciMessage, 'WINEXEC ');
			 StrCat(mciMessage, tQuestion.FichierExecutable);
			 AddMciQueueString(mciMessage);
		end;

		bOnReturn := FALSE;
		{-- Il y a des commandes MCI à executer -- }
		if (idBut = idb_PlayQ) OR
			 (idBut = idb_PlayQR) OR
			 (idBut = idb_RecordR) then
		if (tQuestion.FichierMCI[0] <> #0) then begin
				if FileExist(szMCIPath) then begin
					 lRet := FindMciCmdQueueString('ON RETURN');
					 if lRet <> LB_ERR then begin
							if nMode <> -1 then begin
								StrCopy(mciMessage, 'TESTCALL');
								AddMciQueueString(mciMessage);
								bOnReturn := TRUE;
							end;
							inc(lRet);
							While GetMciCmdQueueString(mciMessage, lRet) AND
										(StrLIComp(mciMessage, 'END', 3) <> 0) do begin
									AddMciQueueString(mciMessage);
							end;
					 end;
				end;
		end;

		{-- Il y a des commandes MCI à executer -- }
		if (idBut = idb_PlayQ) OR
			 (idBut = idb_PlayQR) OR
			 (idBut = idb_RecordR) then
		if (tQuestion.FichierMCI[0] <> #0) then begin
				if FileExist(szMCIPath) then begin
					 lRet := FindMciCmdQueueString('ON END');
					 if lRet <> LB_ERR then begin
						 GetMciCmdQueueString(mciMessage, lRet);
					 end else begin
						 lRet := 0;
					 end;
					 While GetMciCmdQueueString(mciMessage, lRet) AND
								 (StrLIComp(mciMessage, 'END', 3) <> 0) do begin
							AddMciQueueString(mciMessage);
					 end;
				end;
		end;

		{-- Test branchement  Appel ou Retour --}
		{#### GDB 23/12/96 Test Call avant Mci/Lavac Commands impossible sinon retour à la
		leçon appelante avant de jouer les commandes dans la leçon appelée.}
		if (nMode <> -1)then begin
			if bOnReturn then begin
				bOnReturn := FALSE;
			end else begin
				StrCopy(mciMessage, 'TESTCALL');
				AddMciQueueString(mciMessage);
			end;
		end;

end;

{*************************************************************}
procedure CreateScript(hBut : HWND; idBut : integer; hLst : HWND; idLst, nMode : integer);
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+5, 0, 0, 0, nil, TRUE);
	{$ENDIF}


	{ -- Récupère la liste des séquences sélectionnées -- }
	nbSel := SendDlgItemMessage(hLst,idLst,LB_GETSELCOUNT,0,0);
	SendDlgItemMessage(hLst,idLst,LB_GETSELITEMS,nbSel,DWORD(@ListeSelectInt));

	{ -- Resets -- }
	ResetMciQueue;
	ResetMciCloseQueue;
	ResetMciCmdQueue;
	ResetMciCmdCloseQueue;

	{-- Met le curseur sablier pour le chargement des leçons --}
	SetCursor(LoadCursor(0,IDC_WAIT));

	{ -- Parcoure la liste des séquences sélectionnées -- }
	if nMode <> -1 then begin
		for noSel := 1 to nbSel do begin
			CreateScriptBlock(hBut, idBut, hLst, idLst, noSel, nMode);
		end;
	end else begin
			CreateScriptBlock(hBut, idBut, hLst, idLst, 1, nMode);
	end;

	{-- Terminer le script de MciQueue par 'END' --}
	StrCopy(mciMessage, 'END');
	AddMciQueueString(mciMessage);
end;
{*************************************************************}

{*************************************************************}
procedure StartScript;
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+6, 0, 0, 0, nil, TRUE);
	{$ENDIF}

	{ On ne sauvegarde plus les déplacements des fenêtres élèves }
	SendMessage(window, WM_USER + 1000, WORD(FALSE), 0);
	StartMciQueue;
end;
{*************************************************************}

{*************************************************************}
procedure StopScript;
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+7, 0, 0, 0, nil, TRUE);
	{$ENDIF}

	StopMciQueue;
	{ On sauvegarde les déplacements des fenêtres élèves }
	{ SendMessage(window, WM_USER + 1000, WORD(TRUE), 0); }
end;
{*************************************************************}

{*************************************************************}
{**                  Fonction SubClsStsProc               **}
{** SE: 																						        **}
{** SI:   																							    **}
{*************************************************************}
function SubClsStsProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;
var dc : HDC;
                rc : TRECT;
                hBr : HBRUSH;

begin


	case Message of
                WM_PAINT :
			begin
                        	SubClsStsProc := BOOL(CallWindowProc(WNDPROC(lpOldStsProc), Dialog, Message, wParam, lParam));
                                {
                                dc := GetDC(GetDlgItem(hBoutonsProc, 113));
				GetClientRect(GetDlgItem(hBoutonsProc, 113), rc);
				InflateRect(rc, -0, -0);
                                hBr := CreateSolidBrush(RGB(226, 55, 55));
				FillRect(dc, rc, hBr);
				DeleteObject(hBr);
				ReleaseDC(GetDlgItem(hBoutonsProc, 113), dc);
                                }
                                exit;
			end;

                WM_LBUTTONDBLCLK,
		WM_LBUTTONDOWN,
        	WM_LBUTTONUP :
			begin
       			exit;
			end;
        end;
	SubClsStsProc := BOOL(CallWindowProc(WNDPROC(lpOldStsProc), Dialog, Message, wParam, lParam));
end;

{*************************************************************}
{**                  Fonction BoutonsProc                   **}
{** SE: Fonction de gestion de la zone de boutons           **}
{** SI: En fonction des messages envoyés à la dialogue      **}
{*************************************************************}
function BoutonsProc(Dialog: HWnd; Message, WParam: DWord;
  LParam: Longint): Bool; stdcall;
var R : TRECT;
		MciReturnStr,
		MciCommandStr : TMCISTR;
		MSG : TMSG;
                hBmp : THANDLE;
{--------------------------------------------------------------------------------------}
{--------------------------------------------------------------------------------------}
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+8, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	BoutonsProc := TRUE;


        //if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	{-- Traitement des messages de la dialogue --}
  case Message of
    {-- Initialisation lors de la création --}
                       //WM_NCCREATE:
                       //        begin
                       //        SendMessage(Dialog, WM_SETFONT, hFnt2, 0);
                       //        end;

		WM_INITDIALOG:
			begin
                                lpOldStsProc := TFARPROC(SetWindowLong(GetDlgItem(Dialog, 113), GWL_WNDPROC, LongInt(@SubClsStsProc)));
				{$IFNDEF _E0}
				AdjustToDesktop(Dialog);
				{$ENDIF}
				PlayingQ := FALSE;
				PlayingR := FALSE;
				RecordingR := FALSE;
                                PriseNotes := FALSE;
				Pause := FALSE;
				hOldLed := hLed_V;
				ShowWindow (GetDlgItem (Dialog, idb_Retour), SW_HIDE);
				ShowWindow(GetDlgItem(Dialog, idb_Reprendre), SW_HIDE);
				PostMessage(Dialog, WM_MMPAINT, 0, 0);

                                //hBmp := LoadImage(hInstRes, MAKEINTRESOURCE( 9001 ), IMAGE_BITMAP  , 0, 0, LR_DEFAULTCOLOR);
                                //hBmp := LoadBitmap(hInstRes, MAKEINTRESOURCE(OBM_OLD_DNARROW));

                                //hBmp := LoadImage(0, PChar('C:\LAVAC\ico\headphone-icon.bmp'), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                //SendDlgItemMessage( Dialog, idb_PlayQ, BM_SETIMAGE, IMAGE_BITMAP, hBmp );
                                //hBmp := LoadImage(0, 'C:\LAVAC\ico\Lokheed-Sennheiser-Hd-280.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                //hBmp := LoadImage(0, 'C:\LAVAC\ico\Iconshock-Real-Vista-Networking-Headphone2.ico', IMAGE_ICON, 96, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                hBmp := LoadImage(0, 'C:\LAVAC\ico\LISTEN_GREEN.ico', IMAGE_ICON, 96, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, idb_PlayQ, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                DeleteObject(hBmp);
                                hBmp := LoadImage(0, 'C:\LAVAC\ico\LISTEN_RED.ico', IMAGE_ICON, 96, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, idb_PlayR, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                DeleteObject(hBmp);
                                hBmp := LoadImage(0, 'C:\LAVAC\ico\LISTEN_GREEN_RED.ico', IMAGE_ICON, 96, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, idb_PlayQR, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                DeleteObject(hBmp);
                                hBmp := LoadImage(0, 'C:\LAVAC\ico\MugenB16-Microphones-Mic-2.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, idb_RecordR, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                DeleteObject(hBmp);
                                //hBmp := LoadImage(0, 'C:\LAVAC\ico\Gakuseisean-Ivista-2-Alarm-Pause.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                hBmp := LoadImage(0, 'C:\LAVAC\ico\Oxygen-Icons.org-Oxygen-Actions-media-playback-pause.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                //hBmp := LoadImage(0, 'C:\LAVAC\ico\PAUSE.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, idb_Pause, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                DeleteObject(hBmp);
                                //hBmp := LoadImage(0, 'C:\LAVAC\ico\Gakuseisean-Ivista-2-Alarm-Play.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                hBmp := LoadImage(0, 'C:\LAVAC\ico\Oxygen-Icons.org-Oxygen-Actions-media-playback-start.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                //hBmp := LoadImage(0, 'C:\LAVAC\ico\PLAY.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, idb_Reprendre, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                DeleteObject(hBmp);
                                //hBmp := LoadImage(0, 'C:\LAVAC\ico\Oxygen-Icons.org-Oxygen-Apps-kblogger.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);

                                hBmp := LoadImage(0, 'C:\LAVAC\ico\Hopstarter-Soft-Scraps-Edit-Document.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, idb_PriseNotes, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                DeleteObject(hBmp);

                                hBmp := LoadImage(0, 'C:\LAVAC\ico\Hopstarter-Soft-Scraps-Document.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, idb_LectureNotes, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                DeleteObject(hBmp);
                                hBmp := LoadImage(0, 'C:\LAVAC\ico\Custom-Icon-Design-Pretty-Office-6-Logout.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, idb_Quit, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                DeleteObject(hBmp);
                                hBmp := LoadImage(0, 'C:\LAVAC\ico\GREY.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, 113, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                //SendDlgItemMessage( Dialog, 113, STM_SETICON, hBmp, 0);
                                DeleteObject(hBmp);




 			end;

		WM_MMPAINT :
			begin
				GetWindowRect(Dialog, R);
				MapWindowPoints(HWND_DESKTOP, GetParent(Dialog), R, 2);
				if (bWin95 OR bWinNT) then begin
					SetWindowPos(Dialog, 0, R.left - 3, R.top - 3, R.right - R.left + 1, R.bottom - R.top, SWP_NOZORDER OR SWP_NOREDRAW);
				end else begin
					SetWindowPos(Dialog, 0, 0, 0, R.right - R.left + 1, R.bottom - R.top, SWP_NOZORDER OR SWP_NOMOVE OR SWP_NOREDRAW);
				end;
				ShowWindow(Dialog, SW_SHOW);
			end;

		{-- Traitement des boutons de la dialogue --}
		WM_COMMAND:
			case LoWord(wParam) of
				{-- Gestion du bouton Professeur --}
				idb_PlayQ :
					begin
						if NOT PlayingR AND NOT PlayingQ AND NOT RecordingR then begin
							{-- On joue les questions --}
							PlayingQ := TRUE;
							SetDlgItemText(Dialog, 601, mmLoadString(hInstRes, STR_STOPTEACH));
                                                        QuestionsPrevues := QuestionsFaite;
							//CreateScript(Dialog, wParam, hLeconProc, idl_ListeQ, HIWORD(lParam));
							CreateScript(Dialog, LoWord(wParam), hLeconProc, idl_ListeQ, HiWord(wParam));
							bItsARet := FALSE;
							StartScript;
                                                        //WinExec('"C:\Program Files (x86)\OpenOffice 4\program\swriter.exe" "C:\LAVAC\ELEVES\toto\1204B.V_.A_n\notes.rtf"', SW_NORMAL);
						end else begin
							{-- Afficher le LED noir une fois le script terminé --}
							AfficheLed(hLed_N);
							{PlayingQ := FALSE;}
							StopScript;
							{-- Redonne le focus au bouton 'Professeur' --}
							SetFocus(GetDlgItem(hBoutonsProc,idb_PlayQ));
							If bItsACall Then bItsARet :=TRUE;
						end;
					end;

				{-- Gestion du bouton Etudiant --}
				idb_PlayR:
					begin
						if NOT PlayingR AND NOT PlayingQ AND NOT RecordingR  then begin
							PlayingR := TRUE;
							SetDlgItemText(Dialog, 602, mmLoadString(hInstRes, STR_STOPSTUD));
							CreateScript(Dialog, LoWord(wParam), hLeconProc, idl_ListeQ, HiWord(wParam));
							bItsARet := FALSE;
							StartScript;
						end else begin
							AfficheLed(hLed_N);
							{PlayingR := FALSE;}
							StopScript;
							SetFocus(GetDlgItem(hBoutonsProc,idb_PlayR));
							If bItsACall Then bItsARet :=TRUE;
						end;
					end;

				{-- Gestion du bouton Professeur / Etudiant --}
				idb_PlayQR:
					begin
						if NOT PlayingR AND NOT PlayingQ AND NOT RecordingR  then begin
							PlayingQ := TRUE;
							PlayingR := TRUE;
							SetDlgItemText(Dialog, 603, mmLoadString(hInstRes, STR_STOPTEACHSTUD));
							CreateScript(Dialog, LoWord(wParam), hLeconProc, idl_ListeQ, HiWord(wParam));
							bItsARet := FALSE;
							StartScript;
						end else begin
							AfficheLed(hLed_N);
							{PlayingQ := FALSE;
							PlayingR := FALSE;}
							StopScript;
							SetFocus(GetDlgItem(hBoutonsProc,idb_PlayQR));
							If bItsACall Then bItsARet :=TRUE;
						end;
          end;

        {-- Gestion du bouton Enregistrement --}
				idb_RecordR:
					begin
                                                PriseNotes := FALSE;
						if NOT PlayingR AND NOT PlayingQ AND NOT RecordingR then begin
							RecordingR := TRUE;
							SetDlgItemText(Dialog, 604, mmLoadString(hInstRes, STR_STOPREC));
							if NOT GetDilateDuree(DilateDuree) then DilateDuree := 100;
							QuestionsPrevues := QuestionsFaite;
							//CreateScript(Dialog, wParam, hLeconProc, idl_ListeQ, HIWORD(lParam));
							CreateScript(Dialog, LoWord(wParam), hLeconProc, idl_ListeQ, HiWord(wParam));
							bItsARet := FALSE;
							StartScript;
						end else begin
							If bItsACall Then bItsARet :=TRUE;

                                                        //
                                                        //RecordingR := FALSE;
                                                        //

							AfficheLed(hLed_N);
							StopScript;
							SetFocus(GetDlgItem(hBoutonsProc,idb_Enregistre));
							ShowWindow(hQcmProc, SW_HIDE);
						end;
					end;

				idb_PriseNotes,
                                idb_LectureNotes:
					begin
						if NOT PlayingR AND NOT PlayingQ AND NOT RecordingR then begin
                                                //WinExec('"C:\Program Files (x86)\OpenOffice 4\program\swriter.exe" "C:\LAVAC\ELEVES\toto\1204B.V_.A_n\notes.rtf"', SW_SHOWNOACTIVATE);
                                                        if ShellExecute(0, Nil, szWriterApp, szNotesRtf, Nil, SW_SHOWNORMAL) <= 32 then begin
                                                           MessageBox(Window, szWriterApp, 'Impossible d''exécuter l''application (OpenOffice)', MB_OK OR MB_ICONSTOP OR MB_APPLMODAL);
                                                           if MessageBox(Window, 'Désirez vous être redirigé vers le site d''OpenOffice afin de le télécharger et de l''installer ?', 'Question', MB_YESNO OR MB_ICONQUESTION OR MB_APPLMODAL) = IDYES then begin
                                                              if ShellExecute(0, Nil, 'https://www.openoffice.org/fr/Telecharger/', '', Nil, SW_SHOWNORMAL) <= 32 then begin
                                                                 MessageBox(Window, 'https://www.openoffice.org/fr/Telecharger/', 'Impossible d''accéder au site (OpenOffice)', MB_OK OR MB_ICONSTOP OR MB_APPLMODAL);
                                                              end;
                                                           end;
                                                        end else begin
                                                          //MessageBox(Window, szWriterApp, szNotesRtf, MB_OK OR MB_ICONSTOP OR MB_APPLMODAL);
                                                        end;
							PlayingQ := TRUE;
                                                        PriseNotes := TRUE;
                                                        RecordingR := TRUE;
							//SetDlgItemText(Dialog, 604, mmLoadString(hInstRes, STR_STOPREC));
							//if NOT GetDilateDuree(DilateDuree) then DilateDuree := 100;
                                                        if LoWord(wParam) = idb_PriseNotes then
                                                           DilateDuree := 300
                                                        else
                                                           DilateDuree := 100;
							QuestionsPrevues := QuestionsFaite;
							//CreateScript(Dialog, wParam, hLeconProc, idl_ListeQ, HIWORD(lParam));
							CreateScript(Dialog, idb_PriseNotes, hLeconProc, idl_ListeQ, HiWord(wParam));
							bItsARet := FALSE;
							StartScript;
						end else begin
							If bItsACall Then bItsARet :=TRUE;

                                                        //
                                                        //RecordingR := FALSE;
                                                        //

							AfficheLed(hLed_N);
							StopScript;
							SetFocus(GetDlgItem(hBoutonsProc,idb_Enregistre));
							ShowWindow(hQcmProc, SW_HIDE);
						end;
					end;

				idb_Reprendre :
					begin
						PostMessage(Dialog, WM_COMMAND, idb_Pause, MAKELONG(GetDlgItem(Dialog, wParam), HIWORD(wParam)));
					end;

				idb_Pause:
					begin
						if NOT Pause then begin
							if PlayingR OR PlayingQ OR RecordingR then begin
								PauseMciQueue;
								AfficheLed(hLed_J);
								Pause := TRUE;
								SetDlgItemText(Dialog, 605, mmLoadString(hInstRes, STR_NEXT));
								ShowWindow(GetDlgItem(Dialog, idb_Reprendre), SW_SHOW);
								ShowWindow(GetDlgItem(Dialog, idb_Pause), SW_HIDE);
								SetFocus(GetDlgItem(Dialog, idb_Reprendre));
							end;
						end else begin
							if PlayingR OR PlayingQ OR RecordingR then begin
								if NOT ResumeMciQueue then
									StartScript;
								AfficheLed(hOldLed);
							end;
							Pause := FALSE;
							SetDlgItemText(Dialog, 605, mmLoadString(hInstRes, STR_PAUSE));
							ShowWindow(GetDlgItem(Dialog, idb_Pause), SW_SHOW);
							ShowWindow(GetDlgItem(Dialog, idb_Reprendre), SW_HIDE);
							SetFocus(GetDlgItem(hBoutonsProc, idb_Pause));
						end;
					end;

				idb_AppelProf:
					begin
						if NOT bFTP then begin
							tEtudiant.Appel := TRUE;
							{StrCopy(tEtudiant.FichierSonAppel, '');}
							SetEtudiantRec(NoElev, tEtudiant);
						end else begin
							StrCopy(tEtudiant.Nom, szNomEleve);
							StrCopy(tEtudiant.LessonName, tLecon.Nom);
							BackupReponses(NoElev, tEtudiant, FALSE);
							FtpPutAnswer(NoElev);
						end;
					end;

                                idb_Quit:
					 begin
						 PostMessage(Window, WM_CLOSE, 0, 0);
					 end;

         idb_Retour : begin
                      {$IFDEF _TUTOR}
	              SendMessage (MainQcmWin^.HWindow, UM_Retour, 0, 0);
                      {$ENDIF}
	              End;
		end;
	end;
	BoutonsProc := FALSE;
end;
{**         Fin de la Fonction BoutonsProc                  **}
{*************************************************************}

procedure ResetSequenceList(hList : HWND; id : WORD);
var
		lpSeqProp : PSEQPROP;
begin
	SendDlgItemMessage(hList, id, LB_RESETCONTENT, 0, 0);

	{while SendDlgItemMessage(hList, id, LB_GETCOUNT, 0, LongInt(0)) > 0 do begin
		lpSeqProp := PSEQPROP(SendDlgItemMessage(hList, id, LB_GETITEMDATA, 0, LongInt(0)));
		if (lpSeqProp = PSEQPROP(LB_ERR)) then lpSeqProp := nil;
		if (lpSeqProp <> nil) then begin
			SendDlgItemMessage(hList, id, LB_SETITEMDATA, 0, LongInt(0));
			dispose(lpSeqProp);
		end;
		SendDlgItemMessage(hList, id, LB_DELETESTRING, 0, LongInt(0));
	end;}

end;
Procedure NormalizeSeqProp ( lpSeqProp : PSEQPROP);
begin
	if (lpSeqProp^.hLogFnt.lfFaceName[0] = #0) then begin
		with lpSeqProp^.hLogFnt do begin
		 lfHeight:= -11;
		 lfWidth:= 0;
		 lfEscapement:= 0;
		 lfOrientation:= 3;
		 lfWeight:= FW_BOLD {FW_NORMAL};
		 lfItalic:= 0;
		 lfUnderline:= 0;
		 lfStrikeOut:= 0;
		 lfCharSet:= 0;
		 lfOutPrecision:= 3;
		 lfClipPrecision:= 2;
		 lfQuality:= 1;
		 lfPitchAndFamily:= 34;
		 StrCopy(lfFaceName, 'Arial');
		end;
		lpSeqProp^.FrColRef := RGB(0, 0, 0);
		lpSeqProp^.BkColRef := RGB(255, 255, 255);
	end;
end;

{*************************************************************}
{**                  Fonction SubClsSeqProc               **}
{** SE: 						**}
{** SI:   																							    **}
{*************************************************************}
function SubClsSeqProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

begin


	case Message of

		WM_RBUTTONDOWN :
			begin
       			 SendMessage(GetParent(Dialog), WM_PARENTNOTIFY, WM_RBUTTONDOWN, lParam);
			end;
	end;
	SubClsSeqProc := BOOL(CallWindowProc(WNDPROC(lpOldSeqProc), Dialog, Message, wParam, lParam));
end;

{*************************************************************}
{**                  Fonction LeconProc                     **}
{** SE: Fonction de gestion de la zone des lecons           **}
{** SI: En fonction des messages envoyés à la dialogue      **}
{*************************************************************}
function LeconProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

{--------------------------------------------------------------------------------------}
var AncienneLecon,
		NouvelleLecon, szDir, szDir1 : szLongName;
		szNom, szNom1 : Array[0..9] of Char;
		szExt, szExt1 : Array[0..4] of Char;
		IsAvi, bOk : Boolean;
		DirInfo : TSearchRec;
		ScrollPos,
		ScrollValue : Integer;
		hWavOut : HWAVEOUT;
		_WaveFormat : TWAVEFORMAT;
		WaveFormat : TPCMWAVEFORMAT;
		stCBRect : TRECT;
		MSG : TMSG;
		pt	: TPOINT;
		lg					  : longint;
		action,
		state,
		item					: WORD;
		OldPen				: HPEN;
		OldBrush			: HBRUSH;
		R,
		rct : TRECT;
		lIndex : longint;

const	rCombo : TRECT = ();
			rDlg   : TRECT = ();
			MinPos : integer = 0;
			MaxPos : integer = 0;
			bRDown : boolean = FALSE;
			szText : array[0..255] of char = #0;
			szFormated : array[0..255] of char = #0;
			TabStopPos : array[0..1] of integer = (0, 0);
			hBkBrush	 : HBRUSH = 0;
                        hBmp : THandle = 0;

var lpSeqProp : PSEQPROP;
		hOldFont	: HFONT;
		p		: PCHAR;
		p2	        : PCHAR;
		p3		: PCHAR;
		nRet		: integer;

                dwMyRet : DWORD;

      clrBackground : TCOLORREF;
      clrForeground : TCOLORREF;
      x, y : integer;
      tm : TEXTMETRIC;
      psz : PChar;
      posTxt : LongInt;
{--------------------------------------------------------------------------------------}
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+9, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	LeconProc := TRUE; {--Message traité, renvoie TRUE (par defaut)--}

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of

		{WM_ERASEBKGND :
			begin
				GetClientRect(Dialog, rct);
				SelectObject(HDC(wParam), GetStockObject(LTGRAY_BRUSH));
				Rectangle(HDC(wParam), rct.left, rct.top, rct.right, rct.bottom);
				exit;
			end;}

		{Initialisation de la dialogue gérant les leçons}
		WM_INITDIALOG:
			begin

                                hBmp := LoadImage(0, 'C:\LAVAC\ico\Icons8-Ios7-Media-Controls-High-Volume - Green.ico', IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, 115, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                DeleteObject(hBmp);

                                hBmp := LoadImage(0, 'C:\LAVAC\ico\Icons8-Ios7-Media-Controls-High-Volume - Red.ico', IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                //hBmp := LoadImage(0, 'C:\LAVAC\ico\Icons8-Ios7-Very-Basic-Settings-Filled.ico', IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, 116, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                DeleteObject(hBmp);

                                //hBmp := LoadImage(0, 'C:\LAVAC\ico\Icons8-Ios7-Media-Controls-High-Volume - Red.ico', IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                hBmp := LoadImage(0, 'C:\LAVAC\ico\Icons8-Ios7-Very-Basic-Settings-Filled.ico', IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, 117, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                DeleteObject(hBmp);

				lpOldSeqProc := TFARPROC(SetWindowLong(GetDlgItem(Dialog, idl_ListeQ), GWL_WNDPROC, LongInt(@SubClsSeqProc)));
				PostMessage(Dialog, WM_MMPAINT, 0, 0);
			end;

		WM_MMPAINT :
			begin
				GetWindowRect(Dialog, R);
				MapWindowPoints(HWND_DESKTOP, GetParent(Dialog), R, 2);
				if (bWin95 OR bWinNT) then begin
					SetWindowPos(Dialog, 0, R.left - 3, R.top - 3, R.right - R.left, R.bottom - R.top, SWP_NOZORDER OR SWP_NOREDRAW);
				end;
				{$IFNDEF _E0}
				AdjustToDesktop(Dialog);
				{$ENDIF}
				{sauve position fenêtre}
				GetWindowRect(Dialog, rDlg);
				MapWindowPoints(0, Window, rDlg, 2);
				Dec(rDlg.right, rDlg.left);
				Dec(rDlg.bottom, rDlg.top);
				GetWindowRect(GetDlgItem(Dialog, 101), rCombo);
				MapWindowPoints(0, Dialog, rCombo, 2);
				Dec(rCombo.right, rCombo.left);
				Dec(rCombo.bottom, rCombo.top);
				if (bWin95 OR bWinNT) then begin
					SendMessage(GetDlgItem(Dialog, idl_Lecon), CB_GETDROPPEDCONTROLRECT, 0 , LongInt(@rCombo));
					MapWindowPoints(HWND_DESKTOP, Dialog, rCombo, 2);
				end;

				Tout := FALSE;
				{Reconstitue le chemin du fichier Lecons.lst}
				LessonInDlgCombo(Dialog, idl_lecon, FALSE);
				MinPos := 0;
				MaxPos := 32767;
				SetScrollRange(GetDlgItem(Dialog, 106), SB_CTL, MinPos,MaxPos, FALSE);
				SetTrackRange(GetDlgItem(Dialog, 106), MinPos,MaxPos, FALSE);
				SetTrackMark(GetDlgItem(Dialog, 106), (MinPos + Maxpos) DIV 3 * 2,
																							(MinPos + Maxpos) DIV 3 * 2, FALSE);
				SetScrollPos(GetDlgItem(Dialog, 106), SB_CTL, (MinPos + Maxpos) DIV 3 * 2, FALSE);
				SetTrackPos(GetDlgItem(Dialog, 106), (MinPos + Maxpos) DIV 3 * 2, FALSE);

				SetScrollRange(GetDlgItem(Dialog, 107), SB_CTL, MinPos,MaxPos, FALSE);
				SetTrackRange(GetDlgItem(Dialog, 107), MinPos,MaxPos, FALSE);
				SetTrackMark(GetDlgItem(Dialog, 107), (MinPos + Maxpos) DIV 3 * 2,
																							(MinPos + Maxpos) DIV 3 * 2, FALSE);
				SetScrollPos(GetDlgItem(Dialog, 107), SB_CTL, (MinPos + Maxpos) DIV 3 * 2, FALSE);
				SetTrackPos(GetDlgItem(Dialog, 107), (MinPos + Maxpos) DIV 3 * 2, FALSE);
				ShowWindow(Dialog, SW_SHOW);
			end;

		WM_PAINT:
			begin {mise à jours Leds et Status etudiant...}
				BeginPaint(Dialog,PS);

				GetEtudiantRec(NoElev,tEtudiant);
				With tEtudiant Do DrawPosition(PS.hDC, GetDlgItem(hLeconProc,105),
							 Position, Score, MaxPoints, Minpoints);
				EndPaint(Dialog,PS);
			end;

                //WM_CTLCOLORLISTBOX :
		WM_CTLCOLOR :
			begin
				if HWND(LOWORD(lParam)) = GetDlgItem(Dialog, 102) then begin
					item := SendDlgItemMessage(Dialog, 102, LB_GETTOPINDEX, 0, 0);
					if integer(item) > integer(LB_ERR) then begin
						lpSeqProp := nil;
						item := SendDlgItemMessage(Dialog, 102,
															LB_GETTEXT,
															item,
															DWORD(@lpSeqProp));
						if integer(item) = integer(LB_ERR) then exit;
						if (lpSeqProp <> nil) AND
							 (lpSeqProp^.hLogFnt.lfFaceName[0] <> #0) then begin
							SetTextColor(HDC(wParam), lpSeqProp^.FrColRef);
							SetBkColor(HDC(wParam), lpSeqProp^.BkColRef);
							DeleteObject(hBkBrush);
							hBkBrush := CreateSolidBrush(lpSeqProp^.BkColRef);
							LeconProc := BOOL(hBkBrush);
							exit;
						end;
					end;
				end;
			end;

		WM_DESTROY:
			begin
				DeleteObject(hBkBrush);
				hBkBrush := 0;
                                //SetWindowLong(GetDlgItem(Dialog, 102), GWL_WNDPROC, LongInt(@lpOldSeqProc));
			end;

{ TLOGFONT }
{	TMeasureItemStruct = record
		CtlType: Word;
		CtlID: Word;
		itemID: Word;
		itemWidth: Word;
		itemHeight: Word;
		itemData: Longint;
	end;}

		WM_MEASUREITEM :
                        begin
			if PMeasureItemStruct(lParam)^.CtlID = 101 then begin
				item := PMeasureItemStruct(lParam)^.itemID;
				GetClientRect(GetDlgItem(Dialog, 101), r);
				PMeasureItemStruct(lParam)^.itemWidth := r.right;
				PMeasureItemStruct(lParam)^.itemHeight := 14;
		        end;
			if PMeasureItemStruct(lParam)^.CtlID = 102 then begin
				item := PMeasureItemStruct(lParam)^.itemID;
				GetClientRect(GetDlgItem(Dialog, 102), r);
				PMeasureItemStruct(lParam)^.itemWidth := r.right;
				PMeasureItemStruct(lParam)^.itemHeight := 14;
				lpSeqProp := PSEQPROP(PMeasureItemStruct(lParam)^.itemData);
				if (lpSeqProp <> nil) AND
					 (lpSeqProp^.hLogFnt.lfFaceName[0] <> #0) then begin
					if lpSeqProp^.hLogFnt.lfHeight >= 0 then begin
						PMeasureItemStruct(lParam)^.itemHeight := lpSeqProp^.hLogFnt.lfHeight;
					end;
					if lpSeqProp^.hLogFnt.lfHeight > 1000 then begin
						PMeasureItemStruct(lParam)^.itemHeight := 0;
					end;
					if lpSeqProp^.hLogFnt.lfHeight < 0 then begin
							PMeasureItemStruct(lParam)^.itemHeight := -lpSeqProp^.hLogFnt.lfHeight;
					end;
					dc := GetDC(GetDlgItem(Dialog, 102));
					LPtoDP(dc, PMeasureItemStruct(lParam)^.itemHeight, 1);
					ReleaseDC(GetDlgItem(Dialog, 102), dc);
					PMeasureItemStruct(lParam)^.itemHeight := PMeasureItemStruct(lParam)^.itemHeight * 3 DIV 2;
				end;
		        end;

                        end;

	{TDeleteItemStruct = record
		CtlType: Word;
		CtlID: Word;
		itemID: Word;
		hwndItem: HWnd;
		itemData: Longint;
	end;}
		WM_DELETEITEM :
			if PMeasureItemStruct(lParam)^.CtlID = 102 then begin
				lpSeqProp := PSEQPROP(PDeleteItemStruct(lParam)^.itemData);
				if lpSeqProp <> nil then begin
					StrDispose(lpSeqProp^.pszText);
					Dispose(lpSeqProp);
				end;
			end;

	{TDrawItemStruct = record
		CtlType: Word;
		CtlID: Word;
		itemID: Word;
		itemAction: Word;
		itemState: Word;
		hwndItem: HWnd;
		hDC: HDC;
		rcItem: TRect;
		itemData: Longint;
	end;}
		WM_DRAWITEM :
                        begin
			if PMeasureItemStruct(lParam)^.CtlID = 101 then begin
 				dc := PDrawItemStruct(lParam)^.hDC;
				r := PDrawItemStruct(lParam)^.rcItem;
				item := PDrawItemStruct(lParam)^.itemID;
				action := PDrawItemStruct(lParam)^.itemAction;
				state := PDrawItemStruct(lParam)^.itemState;

                                // The colors depend on whether the item is selected.
				if Boolean(state AND ODS_SELECTED) then begin
                                   clrForeground := SetTextColor(dc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                                   clrBackground := SetBkColor(dc, GetSysColor(COLOR_HIGHLIGHT));
                                end else begin
                                    clrForeground := SetTextColor(dc, GetSysColor(COLOR_WINDOWTEXT));
                                    clrBackground := SetBkColor(dc, GetSysColor(COLOR_WINDOW));
                                end;

                                // Get and display the text for the list item.
                                SendMessage(PDrawItemStruct(lParam)^.hwndItem, CB_GETLBTEXT,
                                                             item, DWORD(@szText[0]));
                                if Boolean(state AND ODS_SELECTED) then begin
                                   SetWindowText(hDescWin, szText);
                                   StrCopy(szXmlSearch, szText);
                                   psz := StrPos(szXmlSearch, 'VOA SE ');
                                   if (psz <> nil) then StrCopy(szXmlSearch, @psz[7]);
                                   //SetWindowText(hDescWin, szXmlSearch);
                                   if fnxmlparser(szXmlFile, szXmlSearch, szXmlTitle, szXmDescription, szXmlAuthor) <> 0 then begin
                                      //MessageBox(Window, szXmDescription, szXmlTitle, MB_OK);
                                      //MessageBox(Window, szXmlAuthor, 'Auteur', MB_OK);
                                      StrCopy(szDescWin, szXmlTitle);
                                      StrCat(szDescWin, #13 + #10 + #13 + #10);
                                      StrCat(szDescWin, szXmDescription);
                                      StrCat(szDescWin, #13 + #10 + #13 + #10);

                                      psz := StrPos(szXmlAuthor, 'FN:');
                                      if (psz <> nil) then StrCopy(szXmlAuthor, @psz[3]);
                                      psz := StrPos(szXmlAuthor, #10);
                                      psz[0] := #0;
                                      StrCat(szDescWin, 'Auteur : ');
                                      StrCat(szDescWin, szXmlAuthor);

                                      SetWindowText(hDescWin, szDescWin);
                                      szXmlTitle[0] := #0;
                                      szXmDescription[0] := #0;
                                      szXmlAuthor[0] := #0;
                                   end;
                                end;

                                // Calculate the vertical and horizontal position.
                                GetTextMetrics(dc, @tm);
                                y := (PDrawItemStruct(lParam)^.rcItem.bottom + PDrawItemStruct(lParam)^.rcItem.top - tm.tmHeight) div 2;
                                x := LOWORD(GetDialogBaseUnits()) div 4;

                                ExtTextOut(dc, x, y,
                                           ETO_CLIPPED or ETO_OPAQUE, @(PDrawItemStruct(lParam)^.rcItem),
                                           szText, StrLen(szText), nil);

                                // Restore the previous colors.
                                SetTextColor(dc, clrForeground);
                                SetBkColor(dc, clrBackground);

                                // If the item has the focus, draw the focus rectangle.
                                if Boolean(state AND  ODS_FOCUS) then
                                    DrawFocusRect(dc, (PDrawItemStruct(lParam)^.rcItem));
                        end;
        		if PMeasureItemStruct(lParam)^.CtlID = 102 then begin
				dc := PDrawItemStruct(lParam)^.hDC;
				r := PDrawItemStruct(lParam)^.rcItem;
				item := PDrawItemStruct(lParam)^.itemID;
				action := PDrawItemStruct(lParam)^.itemAction;
				state := PDrawItemStruct(lParam)^.itemState;
				lpSeqProp := PSEQPROP(PDrawItemStruct(lParam)^.itemData);
				if Boolean(action AND ODA_SELECT) OR
					 Boolean(action AND ODA_DRAWENTIRE) then begin
					if Boolean(state AND ODS_SELECTED) then begin
						if (lpSeqProp <> nil) AND
							 (lpSeqProp^.hLogFnt.lfFaceName[0] <> #0) then begin
							OldPen := SelectObject(dc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_HIGHLIGHT)));
							OldBrush := SelectObject(dc, CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)));
							{OldPen := SelectObject(dc, CreatePen(PS_SOLID, 1, NOT lpSeqProp^.BkColRef));
							OldBrush := SelectObject(dc, CreateSolidBrush(NOT lpSeqProp^.BkColRef));}
							Rectangle(dc, r.left, r.top, r.right, r.bottom);
							{SetBkColor(DC, NOT lpSeqProp^.BkColRef);}
							SetBkColor(DC, GetSysColor(COLOR_HIGHLIGHT));
							SetTextColor(DC, NOT lpSeqProp^.FrColRef);
						end else begin
							OldPen := SelectObject(dc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_HIGHLIGHT)));
							OldBrush := SelectObject(dc, CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)));
							Rectangle(dc, r.left, r.top, r.right, r.bottom);
							SetBkColor(DC, GetSysColor(COLOR_HIGHLIGHT));
							SetTextColor(DC, GetSysColor(COLOR_HIGHLIGHTTEXT));
						end;
					end else begin
						if (lpSeqProp <> nil) AND
							 (lpSeqProp^.hLogFnt.lfFaceName[0] <> #0) then begin
							OldPen := SelectObject(dc, CreatePen(PS_SOLID, 1, lpSeqProp^.BkColRef));
							OldBrush := SelectObject(dc, CreateSolidBrush(lpSeqProp^.BkColRef));
							Rectangle(dc, r.left, r.top, r.right, r.bottom);
							SetBkColor(DC, lpSeqProp^.BkColRef);
							SetTextColor(DC, lpSeqProp^.FrColRef);
						end else begin
							OldPen := SelectObject(dc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOW)));
							OldBrush := SelectObject(dc, CreateSolidBrush(GetSysColor(COLOR_WINDOW)));
							Rectangle(dc, r.left, r.top, r.right, r.bottom);
							SetBkColor(DC, GetSysColor(COLOR_WINDOW));
							SetTextColor(DC, GetSysColor(COLOR_MENUTEXT));
						end;
					end;
					DeleteObject(SelectObject(dc, OldBrush));
					DeleteObject(SelectObject(dc, OldPen));
					if (lpSeqProp <> nil) AND (lpSeqProp^.pszText <> nil) then begin
						lg := StrLen(StrCopy(szText, lpSeqProp^.pszText));
					end else begin
						{lg := StrLen(StrCopy(szText, 'Sans Nom'));}
						lg := StrLen(StrCopy(szText, ''));
					end;
					if (lpSeqProp <> nil) AND
						 (lpSeqProp^.hLogFnt.lfFaceName[0] <> #0) then begin
						if (lpSeqProp^.hLogFnt.lfHeight < 1000) then begin
							hOldFont :=SelectObject(dc, CreateFontIndirect(lpSeqProp^.hLogFnt));
							p := StrPos(szText, '#');
							while p <> nil do begin
								p[0] := #9;
								p := StrPos(szText, '#');
							end;
							if HIBYTE(lpSeqProp^.hLogFnt.lfOrientation) = 0 then begin
								//longint(pt) := GetTabbedTextExtent(dc, '000 - ', 6, 0, TabStopPos);
								dwMyRet := GetTabbedTextExtent(dc, '000 - ', 6, 0, TabStopPos);
                                                                pt.x := LOWORD(dwMyRet);
                                                                pt.y := HIWORD(dwMyRet);

								LPtoDP(dc, pt, 1);
								TabStopPos[0] := pt.x + 1;
							end else begin
								TabStopPos[0] := HIBYTE(lpSeqProp^.hLogFnt.lfOrientation);
							end;
							if lg > 0 then begin
								p := StrPos(szText, '-');
								if (LOBYTE(lpSeqProp^.hLogFnt.lfOrientation) > 2) AND
									 (p = nil) then begin
										StrCopy(szFormated, '? - ');
										StrCat(szFormated, szText);
										StrCopy(szText, szFormated);
										p := StrPos(szText, '-');
										lpSeqProp^.hLogFnt.lfOrientation := 0;
								end else begin
									if (p <> nil) then begin
										p[0] := #0;
										if StrLen(szText) > 6 then begin
											p[0] := '-';
											StrCopy(szFormated, '? - ');
											StrCat(szFormated, szText);
											StrCopy(szText, szFormated);
											p := StrPos(szText, '-');
											lpSeqProp^.hLogFnt.lfOrientation := 0;
										end else begin
											p[0] := '-';
											StrCopy(szFormated, szText);
										end;
									end else begin
										StrCopy(szFormated, szText);
									end;
								end;
								if p <> nil then begin
									case LOBYTE(lpSeqProp^.hLogFnt.lfOrientation) of
										0..2 :
											begin
												StrCopy(szFormated, @p[2]);
											end;

										3 :
											begin
												p[0] := #0;
												Val(szText, item, nRet);
												Str(item, szFormated);
												p2 := @szText[0];
												while p2[0] = ' ' do begin
													p2 := @p2[1];
												end;
												p3 := StrPos(p2, ' ');
												if p3 <> nil then p3[0] := #0;
												StrCopy(szFormated, p2);
												StrCat(szFormated, ' -'+#9);
												StrCat(szFormated, @p[2]);
											end;

										4 :
											begin
												StrCopy(szFormated, ''+#9);
												StrCat(szFormated, @p[2]);
											end;

										5 :
											begin
												Str(item + 1, szFormated);
												StrCat(szFormated, ' -'+#9);
												StrCat(szFormated, @p[2]);
											end;

									end;
								end;
								lg := StrLen(szFormated);
								case LOBYTE(lpSeqProp^.hLogFnt.lfOrientation) of
									0 :
										begin
											TabbedTextOut(dc, r.left + 2, r.top, szFormated, lg, 1, TabStopPos, 0);
										end;

									1 :
										begin
											SetTextAlign(dc, TA_CENTER);
											ExtTextOut(dc, (r.right - r.left) DIV 2, r.top, ETO_CLIPPED, @r, szFormated, lg, nil);
											SetTextAlign(dc, TA_LEFT);
										end;

									2 :
										begin
											SetTextAlign(dc, TA_RIGHT);
											ExtTextOut(dc, r.right - TabStopPos[0], r.top, ETO_CLIPPED, @r, szFormated, lg, nil);
											SetTextAlign(dc, TA_LEFT);
										end;

									3..5 :
										begin
											p := StrPos(szFormated, #9);
											if p <> nil then begin
												p[0] := #0;
												// longint(pt) := GetTabbedTextExtent(dc, szFormated, StrLen(szFormated), 0, TabStopPos);
                                								dwMyRet := GetTabbedTextExtent(dc, szFormated, StrLen(szFormated), 0, TabStopPos);
                                                                                                pt.x := LOWORD(dwMyRet);
                                                                                                pt.y := HIWORD(dwMyRet);

												LPtoDP(dc, pt, 1);
												nRet := pt.x;
												//longint(pt) := GetTabbedTextExtent(dc, ' ', 1, 0, TabStopPos);
                                								dwMyRet := GetTabbedTextExtent(dc, ' ', 1, 0, TabStopPos);
                                                                                                pt.x := LOWORD(dwMyRet);
                                                                                                pt.y := HIWORD(dwMyRet);

												LPtoDP(dc, pt, 1);
												inc(nRet, pt.x);
												p[0] := #9;
											end;
											TabbedTextOut(dc, r.left + (TabStopPos[0] - nRet), r.top, szFormated, lg, 1, TabStopPos, 0);
										end;

								end;
								DeleteObject(SelectObject(dc, hOldFont));
							end;
						end;
					end else begin
						if lg > 0 then begin
							TextOut(dc, r.left + 2, r.top, szText, lg);
						end;
					end;
				end;
				{if Boolean(action AND ODA_FOCUS) then begin
				end;
				if Boolean(state AND ODS_FOCUS) then begin
							Rectangle(dc, r.left, r.top, r.right, r.bottom);
				end;}
			end;

                        end;

		WM_HSCROLL:
			begin
				ScrollPos := GetScrollPos(hiWord(LParam),SB_CTL);
				if ScrollPos = 0  then ScrollPos := GetTrackPos(hAscPlaying); //hiWord(LParam));
				{GetScrollRange(hiWord(LParam),SB_CTL,MinPos,MaxPos);}
				Case WPAram of
					SB_LINEUP        : ScrollValue := -(MaxPos DIV 32 + 1);
					SB_LINEDOWN      : ScrollValue := +(MaxPos DIV 32 + 1);
					SB_PAGEUP        : ScrollValue := -(MaxPos DIV 32 + 1);
					SB_PAGEDOWN      : ScrollValue := +(MaxPos DIV 32 + 1);
					SB_THUMBPOSITION,
					SB_THUMBTRACK : ScrollValue := LoWord(LParam)-ScrollPos;
				else
					ScrollValue := 0;
				end;
				ScrollValue := max(-SCrollPos, min(ScrollValue,MaxPos-ScrollPos));
				ScrollPos := ScrollPos + ScrollValue;
				SendMessage(hiWord(LParam), WM_USER + 5, 1, ScrollPos);
				SetScrollPos(hiWord(LParam),SB_CTL,ScrollPos,TRUE);

				for i := 0 to auxGetNumDevs do begin
						{ auxSetVolume(WORD(i), DWORD(MakeLong(WORD(ScrollPos * 2),WORD(ScrollPos * 2))));
						midiOutSetVolume(WORD(i), DWORD(MakeLong(WORD(ScrollPos * 2),WORD(ScrollPos * 2))));}

						{si l'ascensseur règlé est celui d'un son en train de jouer
						 on règle le volume tout de suite}
						//if hAscPlaying = lParam then
                                                if ScrollPos > 0 then
							waveOutSetVolume(WORD(i), DWORD(MakeLong(WORD(ScrollPos * 2),WORD(ScrollPos * 2))));

						{WaveFormat.wf.wFormatTag := WAVE_FORMAT_PCM;
						WaveFormat.wf.nChannels := 1;
						WaveFormat.wf.nSamplesPerSec := 11025;
						WaveFormat.wf.nAvgBytesPerSec := 11025;
						WaveFormat.wf.nBlockAlign := 1;
						WaveFormat.wBitsPerSample := 8;
						waveOutOpen(PHWAVEOUT(@hWavOut), WORD(WAVE_MAPPER),
											 PWAVEFORMAT(@WaveFormat),
											 DWORD(Dialog),DWORD(0),CALLBACK_WINDOW);
						waveOutSetVolume(hWavOut, DWORD(MakeLong(WORD(ScrollPos * 2),WORD(ScrollPos * 2))));
						waveOutClose(hWavOut);}
				end;
			end;

		WM_PARENTNOTIFY :
			begin
                                //MessageBox(Dialog, 'WM_PARENTNOTIFY', 'WM_PARENTNOTIFY', MB_OK OR MB_ICONEXCLAMATION);
				case LOWORD(wParam) of
					WM_RBUTTONDOWN :
						if NOT bRDown then begin
							bRDown := TRUE;
							// pt := TPOINT(lParam);
                                                        pt.x := GET_X_LPARAM(lParam);
                                                        pt.y := GET_Y_LPARAM(lParam);
							lIndex := SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETTOPINDEX, 0, 0);
							dwReturn := 0;
							while dwReturn <> LB_ERR do begin
								dwReturn := SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETITEMRECT, lIndex, longint(@rct));
								//MapWindowPoints(GetDlgItem(Dialog, idl_ListeQ), Dialog, rct, 2);
								if (pt.x >= rct.left) AND (pt.x <= rct.right) AND
								   (pt.y >= rct.top) AND (pt.y <= rct.bottom) then begin
									SendDlgItemMessage(Dialog, idl_ListeQ, LB_SETSEL, WORD(TRUE), lIndex);
									wReturn := 0;
									if PlayingQ then wReturn := idb_PlayQ;
									if PlayingR then wReturn := idb_PlayR;
									if PlayingQ AND PlayingR then wReturn := idb_PlayQR;
         								if RecordingR then wReturn := idb_RecordR;
                 							if PriseNotes then wReturn := idb_PriseNotes;
									{ Jouer cette séquence ... }
									if wReturn <> 0 then begin
										if Pause then SendMessage(hBoutonsProc, WM_COMMAND, idb_Pause, 0);
										SendMessage(hBoutonsProc, WM_COMMAND, wReturn, 0);
										PostMessage(hBoutonsProc, WM_COMMAND, wReturn, MakeLong(GetDlgItem(hBoutonsProc, wReturn), 0));
									end;
								end;
								inc(lIndex);
							end;
							bRDown := FALSE;
						end;
				end;
			end;

		{ lire séquence 1 }
		WM_USER + 1001 :
			begin
				while PeekMessage(MSG, 0, 0, 0,PM_REMOVE) do begin
					TranslateMessage(MSG);
					DispatchMessage(MSG);
				end;
				SendDlgItemMessage(Dialog, idl_ListeQ, LB_SETSEL, WORD(TRUE), 0);
				while PeekMessage(MSG, 0, 0, 0,PM_REMOVE) do begin
					TranslateMessage(MSG);
					DispatchMessage(MSG);
				end;
				PostMessage(hBoutonsProc, WM_COMMAND, idb_RecordR, MakeLong(GetDlgItem(hBoutonsProc, idb_RecordR), 0));
			end;

		{L'utilisateur demande qqe}
		WM_COMMAND:
			case LoWord(wParam) of
				idl_Lecon:
                                        begin
                                              //Case HiWord(LPARAM) of
                                                //GetDlgItemText(Dialog, 5000, szDescWin, SizeOf(szDescWin));
                                                //SetWindowText(hDescWin, szDescWin);
                                              Case HiWord(wParam) of
                                                  {déroule la combobox et la rempli avec les noms de leçons
                                                  présentes dans le fichier Lecons.lst}
							CBN_CLOSEUP:
								begin
									ProcessCloseUp(Dialog, LOWORD(lParam), rDlg, rCombo);
                                                                        ShowWindow(hDescWin, SW_HIDE);
								end;

							CBN_DROPDOWN:
								begin
                                                                     GetWindowRect(GetDlgItem(Dialog, 101), r);
                                                                     SetWindowPos(hDescWin, 0, r.right, r.top, 0, 0, SWP_NOZORDER OR SWP_NOSIZE {OR SWP_NOREDRAW } OR SWP_SHOWWINDOW);
                                                                     //ShowWindow(hDescWin, SW_SHOW);
								     ProcessDropDown(Dialog, LOWORD(lParam), rDlg, rCombo);

								     GetDlgItemText(Dialog, idl_Lecon, AncienneLecon, SizeOf(AncienneLecon));
								     LessonInDlgCombo(Dialog, idl_Lecon, TRUE);
								end;

							{Choix d'une lecon}
							CBN_SELCHANGE:
								begin
									{WriteLn('CBN_SELCHANGE':15, 'LECONPROC':10, wParam:6, LOWORD(lParam):6, HIWORD(lParam):6);}
									{récupère le nom de la leçon}

									GetDlgItemText(Dialog, idl_Lecon, NouvelleLecon, SizeOf(NouvelleLecon));
//                                                                        SetWindowText(hDescWin, NouvelleLecon);
									if StrComp(AncienneLecon, NouvelleLecon) <> 0 then begin
										QuestionsFaite := 0;
                                                                                GetEtudiantRec(NoElev,tEtudiant);
                                                                                tEtudiant.Score := 0;
                                                                                SetEtudiantRec(NoElev,tEtudiant);
									end;

									{Rempli la liste des chapitres}
									ResetSequenceList(Dialog, idl_ListeQ);
									GetLessonRec(GetCurItemData(Dialog, idl_Lecon) + 1,	tLecon);
									StrCopy(PathFichier,tLecon.PathLecon);
									StrCat(PathFichier, '\QUESTION.LST');
									FileMode := OF_SHARE_DENY_NONE OR  0;
									Assign(fQuestion,PChar(PathFichier));
									{$i-}
									reset(fQuestion);
									{$i+}
									while (IOResult = 0) AND NOT EOF(fQuestion) do begin
										SetCursor(LoadCursor(0,IDC_WAIT));
										{$i-}
										Read(fQuestion,tQuestion);
										{$i+}

										lpSeqProp := new(PSEQPROP);
										if lpSeqProp <> nil then begin
											lpSeqProp^.pszText := StrNew(tQuestion.Nom);
											if lpSeqProp^.pszText = nil then lpSeqProp^.pszText := StrNew(' ');
											CopyLogFont16to32(lpSeqProp^.hLogFnt, tQuestion.hLogFnt);
											lpSeqProp^.FrColRef := tQuestion.FrColRef;
											lpSeqProp^.BkColRef := tQuestion.BkColRef;
											NormalizeSeqProp(lpSeqProp);
										end else begin
											MessageBeep(WORD(-1));
										end;

										SendDlgItemMessage(Dialog, idl_ListeQ, LB_ADDSTRING, 0, LongInt(lpSeqProp));
									end;
									{$i-}
									close(fQuestion);
									FileMode := OF_SHARE_DENY_NONE OR  2;
									{$i+}
									InOutRes := 0;

									{Initialise les valeurs qcm}
									InvalidateRect(GetDlgItem(hLeconProc,105), nil, FALSE);
									ShowWindow(hQcmProc, SW_HIDE);
                                                                        {$IFDEF _TUTOR}
									InitialiseQcm(NoElev);
									If Not MainQcmWin^.bAutoSel Then With MainQcmWin^ Do Begin
										 If lpRepCollection <> Nil Then Dispose (lpRepCollection, Done);
										 lpRepCollection := New (PRepCollection, Init (10, 5));
										 nLastPlay := 0;
									End;
                                                                        {$ENDIF}

									VideoLoc := StartVideoLoc;
									if VideoLoc then begin
										{Affiche de la dialogue d'attente qui traite l'initialisation}
										//lpAttenteProc := MakeProcInstance(@AttenteProc, HInstance);
										//lpAttenteProc := @AttenteProc;
										//DialogBox(hInstRes, 'ATTENTE_EL', Window, DLGPROC(lpAttenteProc));
										//FreeProcInstance(lpAttenteProc);
									end;

								{$IFNDEF _E0}
									if NOT bItsACall AND NOT bItsARet then begin
										PostMessage(Dialog, WM_USER + 1001, 0, 0);
									end;
								{$ENDIF}
                                                                        StrCopy(tEtudiant.LessonName, NouvelleLecon);
                                                                        SetEtudiantRec(NoElev, tEtudiant);
                                                                        ReponseRtfFileName(szNotesRtf, NoElev, 0);
                                                                        CopyFile(szNotesTemplateRtf, szNotesRtf);

								end;
						end;
					end;

				idl_ListeQ:
					begin
						//if HIWORD(lParam) = LBN_SELCHANGE then begin
         					if HIWORD(wParam) = LBN_SELCHANGE then begin
							{ Change le prof }
							{WriteLn('LBN_SELCHANGE':15, 'LECONPROC':10, wParam:6, LOWORD(lParam):6, HIWORD(lParam):6);}
							nbSel := SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_GETSELCOUNT, 0, 0);
							SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_GETSELITEMS, nbSel, DWORD(@ListeSelectInt));
							{####}
							LBSetMultiSel(hListBar, idl_ListeQ, @ListeSelectInt, nbSel);
							{####}
							SendMessage(hListBar, WM_COMMAND, idl_ListeQ, MakeLong(WORD(-1), LBN_SELCHANGE));
						end;
					end;

				//idl_BtnTout:
                                117:  // Config audio
					begin
                                              //if ShellExecute(Window, Nil, 'cmd', '/c control mmsys.cpl,,1', Nil, SW_HIDE) <= 32 then
                                                 ShellExecute(Window, Nil, 'cmd', '/c control mmsys.cpl,,0', Nil, SW_HIDE)

                                        {
						wReturn := SendDlgItemMessage(Dialog,idl_ListeQ,LB_GETCOUNT,0,LongInt(0));
						if NOT Tout then begin
							SendDlgItemMessage(Dialog,idl_ListeQ,LB_SELITEMRANGE,WORD(TRUE),MakeLong(0,wReturn));
							SetDlgItemText(Dialog,idl_BtnTout, mmLoadString(hInstRes, STR_NONE));
							Tout := TRUE;
						end else begin
							SendDlgItemMessage(Dialog,idl_ListeQ,LB_SELITEMRANGE,WORD(FALSE),MakeLong(0,wReturn));
							SetDlgItemText(Dialog,idl_BtnTout, mmLoadString(hInstRes, STR_ALL));
							Tout := FALSE;
						end;
                                        }
					end;
			end;
		else LeconProc := FALSE; {--Message non traité, renvoie FALSE--}
	end;
end;
{**         Fin de la Fonction LeconProc                    **}
{*************************************************************}

{*************************************************************}
{**                  Fonction SubClsTxtProc               **}
{** SE: 																						        **}
{** SI:   																							    **}
{*************************************************************}
function SubClsTxtProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var dc			: HDC;
		r				: TRECT;
		ps  		: TPAINTSTRUCT;
		dwStyle	: DWORD;

begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+10, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	case Message of

		WM_NCPAINT :
			begin
				SubClsTxtProc := BOOL(CallWindowProc(DLGPROC(lpOldTxtProc), Dialog, Message, wParam,	lParam));
				GetWindowRect(Dialog, r);
				MapWindowPoints(0, Dialog, r, 2);
				dc := GetWindowDC(Dialog);

				dwStyle := GetWindowLong(Dialog, GWL_STYLE);
				if (dwStyle AND WS_HSCROLL) = WS_HSCROLL then begin
					dec(r.bottom, GetSystemMetrics(SM_CYHSCROLL) - 1);
				end;

				if (dwStyle AND WS_VSCROLL) = WS_VSCROLL then begin
					dec(r.right, GetSystemMetrics(SM_CXVSCROLL) - 1);
				end;

				if (dwStyle AND WS_HSCROLL) = WS_HSCROLL then begin
					SelectObject(dc, GetStockObject(BLACK_PEN));
				end else begin
					SelectObject(dc, GetStockObject(WHITE_PEN));
				end;

				MoveTo(dc, r.left + 1, r.bottom);
				LineTo(dc, r.right, r.bottom);

				if (dwStyle AND WS_VSCROLL) = WS_VSCROLL then begin
					SelectObject(dc, GetStockObject(BLACK_PEN));
				end else begin
					SelectObject(dc, GetStockObject(WHITE_PEN));
				end;

				LineTo(dc, r.right, r.top - 1);

				if ((dwStyle AND WS_HSCROLL) = WS_HSCROLL) AND
					 ((dwStyle AND WS_VSCROLL) = WS_VSCROLL) then begin
					SelectObject(dc, GetStockObject(WHITE_PEN));
					MoveTo(dc, r.right + 1, r.bottom + GetSystemMetrics(SM_CYHSCROLL) - 1);
					LineTo(dc, r.right + GetSystemMetrics(SM_CXVSCROLL) - 1, r.bottom + GetSystemMetrics(SM_CYHSCROLL)- 1);
					LineTo(dc, r.right + GetSystemMetrics(SM_CXVSCROLL) - 1, r.bottom);
				end;

				SelectObject(dc, CreatePen(PS_SOLID, 1, RGB(128, 128, 128)));

				MoveTo(dc, r.right - 1, r.top + 1);
				LineTo(dc, r.left + 1, r.top + 1);
				LineTo(dc, r.left + 1, r.bottom);

				DeleteObject(SelectObject(dc, GetStockObject(BLACK_PEN)));
				ReleaseDC(Dialog, dc);
				exit;
			end;

			WM_MOUSEACTIVATE :
			begin
				 SendMessage(GetParent(Dialog), Message, wParam, lParam);
			end;

	end;
	SubClsTxtProc := BOOL(CallWindowProc(WNDPROC(lpOldTxtProc), Dialog, Message, wParam, lParam));
end;

{*************************************************************}
{**                  Fonction TexteProc                     **}
{** SE: Fonction de gestion de la zone de texte             **}
{** SI: En fonction des messages envoyés à la dialogue      **}
{**                                                         **}
{**   La dialogue est Overlapped pour pouvoir s'afficher    **}
{** sur la fenêtre vidéo.                                   **}
{*************************************************************}
function TexteProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

{--------------------------------------------------------------------------------------}
const
		Wnd_x : Integer = 0;
		Wnd_y : Integer = 0;
		Wnd_w : Integer = 0;
		Wnd_h : Integer = 0;
		nWidth : integer = 0;

{--------------------------------------------------------------------------------------}
var R :TRect;
		pt : TPOINT;
		szFormat,
		szLink,
		szLine 	: array[0..255]of char;
		pLink		: PChar;


{--------------------------------------------------------------------------------------}
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+11, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	TexteProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of
		wm_InitDialog:
			begin
				PostMessage(Dialog, WM_MMPAINT, 0, 0);
			end;

		WM_MMPAINT :
			begin
				{ Start SubClassing de Ctl 101 pour effet 3D }
				//lpSubClsTxtProc := MakeProcInstance(@SubClsTxtProc, hInstance);
				lpSubClsTxtProc := @SubClsTxtProc;
				lpOldTxtProc := TFARPROC(SetWindowLong(GetDlgItem(Dialog, 101), GWL_WNDPROC, LongInt(lpSubClsTxtProc)));

				GetWindowRect(Dialog, R);
				MapWindowPoints(HWND_DESKTOP, GetParent(Dialog), R, 2);
				if (bWin95 OR bWinNT) then begin
					nWidth := GetSystemMetrics(SM_CXFRAME);
					SetWindowPos(Dialog, 0,
											 R.left - nWidth - 3, R.top - nWidth - 1,
											 R.right - R.left + nWidth, R.bottom - R.top + nWidth,
											 SWP_NOZORDER OR SWP_NOREDRAW);
				end else begin
					SetWindowPos(Dialog, 0, R.left - 1, R.top + 1, 0, 0, SWP_NOZORDER OR SWP_NOSIZE OR SWP_NOREDRAW);
					nWidth := GetSystemMetrics(SM_CXDLGFRAME);
				end;

                                SetWindowPos(Dialog, 0, (R.left * 110) div 100 , (R.top * 95) div 100, ((R.right - R.left) * 125) div 100, ((R.bottom - R.top) * 116) div 100, SWP_NOZORDER OR SWP_NOREDRAW);

				{$IFNDEF _E0}
				AdjustToDesktop(Dialog);
				{$ENDIF}
				GetWindowRect(Dialog,R);
				MapWindowPoints(0, Window, R, 2);
				Wnd_x := R.Left;
				Wnd_y := R.Top;
				Wnd_w := R.Right - R.Left;
				Wnd_h := R.Bottom - R.Top;
				{ #### MoveWindow(Dialog, Wnd_x, Wnd_y, Wnd_w, Wnd_h, FALSE);}
				{MoveWindow(GetDlgItem(Dialog,101), nWidth, nWidth, Wnd_w - 2 * nWidth, Wnd_h - 2 * nWidth, FALSE);}
				{ShowScrollBar(GetDlgItem(hTexteProc,101),SB_VERT,FALSE);}
				StrCopy(tQuestion.FichierTexte, '');
				SetDlgItemText(hTexteProc, 101, '');
				{SetWindowLong(GetDlgItem(hTexteProc, 101), GWL_STYLE, GetWindowLong(GetDlgItem(hTexteProc, 101), GWL_STYLE) OR ES_RIGHT);}
{$IFNDEF _E0}  { Elève... }
				SendDlgItemMessage(hTexteProc, 101, EM_SETREADONLY, WORD(TRUE), DWORD(0));
{$ENDIF}
				ShowWindow(Dialog, SW_SHOW);
			end;

		WM_GETMINMAXINFO :
			Begin
				PMinMaxInfo(lParam)^.ptMinTrackSize.X := 0;
				PMinMaxInfo(lParam)^.ptMinTrackSize.Y := 0;
			End;

	 {-- Destruction de la Dialog --}
		WM_DESTROY :
			begin
				{ Stop SubClassing de Ctl 101 pour effet 3D }
				SetWindowLong(GetDlgItem(Dialog, 101), GWL_WNDPROC, LongInt(lpOldTxtProc));
				//FreeProcInstance(lpSubClsTxtProc);
			end;

		{WM_CTLCOLOR :
			begin
				if integer(HIWORD(lParam)) = CTLCOLOR_EDIT then begin
					SetTextColor(HDC(wParam), tQuestion.FrColRef);
					SetBkColor(HDC(wParam), tQuestion.BkColRef);
					TexteProc := BOOL(hBkBrush);
					exit;
				end;
			end;}

{$IFDEF _E0}  { Créateur... }
		WM_SETCURSOR :
			begin
				if LOWORD(lParam) = HTCAPTION then begin
					SetCursor(LoadCursor(0,IDC_SIZE));
					SetWindowLong(Dialog, DWL_MSGRESULT, MAKELONG(WORD(TRUE), 0));
					exit;
				end;
			end;

		WM_MOUSEACTIVATE :
		begin
			 CheckRadioButton(hListBar, 1200, 1207, 1202);
			 PostMessage(Dialog, WM_USER, 0, 0);
		end;

		UM_SETSTATUSTEXT :
		begin
			 GetWindowText(Dialog, szFormat, SizeOf(szFormat));
			 GetDlgItemText(Dialog, 102, szLink, SizeOf(szLink));
			 pLink := @szLink;
			 wvsprintf(szLine, szFormat, pLink);
			 SetDlgItemText(hStatusBar, 101, szLine);

			 if hOldHandled <> hTexteProc then begin
				 if hOldHandled <> 0 then begin
					 SetWindowPos(hOldHandled, 0, 0, 0, 0, 0, SWP_DRAWFRAME OR SWP_NOMOVE OR SWP_NOSIZE OR SWP_NOZORDER OR SWP_NOACTIVATE);
					 UpdateHandle(hOldHandled);
				 end;
				 UpdateHandle(hTexteProc);
				 hOldHandled := hTexteProc;
			 end;

		end;

		WM_NCHITTEST :
			begin
				SetWindowLong(Dialog, 0{DWL_MSGRESULT}, ProcessHitTest(Dialog, message, wParam, lParam));
				exit;
			end;

		WM_PAINT :
			begin
				UpdateWindow(hBoutonsProc);
				UpdateWindow(hLeconProc);
				dc := BeginPaint(Dialog, ps);
				EndPaint(Dialog, ps);
				if IsDlgButtonChecked(hListBar, 1202) = 1 then begin
					dc := GetWindowDC(Dialog);
					ShowHandle(dc, Dialog);
					ReleaseDC(Dialog, dc);
				end;
			end;
{$ELSE}  { Créateur... }
		WM_PAINT :
			begin
				UpdateWindow(hBoutonsProc);
				UpdateWindow(hLeconProc);
				dc := BeginPaint(Dialog, ps);
				EndPaint(Dialog, ps);
			end;
{$ENDIF}  { Créateur... }

		WM_WINDOWPOSCHANGING : { TWINDOWPOS }
		begin
			UpdateHandle(Dialog);
			if IsZoomed(Dialog) then begin
				GetWindowRect(GetParent(Dialog), r);
				MapWindowPoints(0, Window, r, 2);
				{PWINDOWPOS(lParam)^.x := -GetSystemMetrics(SM_CXDLGFRAME);
				PWINDOWPOS(lParam)^.y := -GetSystemMetrics(SM_CYDLGFRAME);
				PWINDOWPOS(lParam)^.cx := r.right - r.left + 2 * GetSystemMetrics(SM_CXDLGFRAME) - 1;
				PWINDOWPOS(lParam)^.cy := r.bottom - r.top + 2 * GetSystemMetrics(SM_CXDLGFRAME) - 1;}

				PWINDOWPOS(lParam)^.x := 0;
				PWINDOWPOS(lParam)^.y := 0;
				PWINDOWPOS(lParam)^.cx := r.right - r.left - 2;
				PWINDOWPOS(lParam)^.cy := r.bottom - r.top - 2;
			end;
		end;

		WM_WINDOWPOSCHANGED : { TWINDOWPOS }
		begin
			UpdateHandle(Dialog);
		end;

		WM_SYSCOMMAND :
			case wParam of
				1 :
					begin
						MoveWindow(Dialog,Wnd_x,Wnd_y,Wnd_w,Wnd_h,TRUE);
					end;
			end;

		WM_MOVE : begin
                          {$IFDEF _TUTOR}
				if MainQcmWin^.bSizable  then begin
                          {$ELSE}
                                begin
                          {$ENDIF}
					GetWindowRect(Dialog, r);
					MapWindowPoints(0, GetParent(Dialog), r, 2);
   					LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@SetTextPos), 0, longint(@r));
				end;
                end;


		WM_SIZE :
			begin
				MoveWindow(GetDlgItem(Dialog,101), nWidth, nWidth, LOWORD(lParam) - 2 * nWidth, HIWORD(lParam) - 2 * nWidth, TRUE);
				{ -- sauver la nouvelle position -- }
				PostMessage(Dialog, WM_MOVE, 0, 0);
			end;

		wm_Command:
			case LoWord(wParam) of
				idok:
					begin
					end;
			end;
	end;
	TexteProc := FALSE;
end;
{**         Fin de la Fonction TexteProc                    **}
{*************************************************************}

{*************************************************************}
function SonProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var	szFormat,
		szLink,
		szLine 	: array[0..255]of char;
		pLink		: PChar;

begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+12, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	SonProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of
		wm_InitDialog:
			begin
				StrCopy(tQuestion.FichierQuestion, '');
			end;

		UM_SETSTATUSTEXT :
		begin
			 GetWindowText(Dialog, szFormat, SizeOf(szFormat));
			 GetDlgItemText(Dialog, 102, szLink, SizeOf(szLink));
			 pLink := @szLink;
			 wvsprintf(szLine, szFormat, pLink);
			 SetDlgItemText(hStatusBar, 101, szLine);

			 if hOldHandled <> hSonProc then begin
				 if hOldHandled <> 0 then begin
					 SetWindowPos(hOldHandled, 0, 0, 0, 0, 0, SWP_DRAWFRAME OR SWP_NOMOVE OR SWP_NOSIZE OR SWP_NOZORDER OR SWP_NOACTIVATE);
					 UpdateHandle(hOldHandled);
				 end;
				 UpdateHandle(hSonProc);
				 hOldHandled := hSonProc;
			 end;

		end;

		mm_MCINotify :
			begin
				StrCopy(mciMessage, 'close sonQ');
				mciSendString(@mciMessage,nil,wReturn,Dialog);
			end;

		wm_Command:
			case LoWord(wParam) of
				106 :
					begin
						if hInstSBPMixer = 0 then begin
							ExecSBPMixer;
						end else begin
							SetActiveWindow(hWndSBPMixer);
							if hWndSBPMixer <> GetActiveWindow then begin
								ExecSBPMixer;
							end;
            end;
          end;
        111:
          begin
            GetDlgItemText(hSonProc,101,PropositionName,SizeOf(PropositionName));
						StrCopy(mciMessage, 'open ');
						StrCat(mciMessage,PropositionName);
						StrCat(mciMessage, ' alias sonQ');
            mciSendString(@mciMessage,nil,wReturn,Dialog);
						StrCopy(mciMessage, 'cue sonQ play');
            mciSendString(@mciMessage,nil,wReturn,Dialog);
						StrCopy(mciMessage, 'play sonQ notify');
            mciSendString(@mciMessage,nil,wReturn,Dialog);
          end;
      end;
	end;
  SonProc := FALSE;
end;

{*************************************************************}
{**                  Fonction SubClsBmpProc               **}
{** SE: 																						        **}
{** SI:   																							    **}
{*************************************************************}
function SubClsBmpProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var dc			: HDC;
		r				: TRECT;
		ps  		: TPAINTSTRUCT;
		dwStyle	: DWORD;

begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+13, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	case Message of

			WM_KEYDOWN:
			 begin
                                 case (wParam) of
								 VK_UP   : PostMessage (Dialog,WM_VSCROLL,SB_LINEUP,0);
								 VK_DOWN : PostMessage (Dialog,WM_VSCROLL,SB_LINEDOWN,0);
								 VK_PRIOR: PostMessage (Dialog,WM_VSCROLL,SB_PAGEUP,0);
								 VK_NEXT : PostMessage (Dialog,WM_VSCROLL,SB_PAGEDOWN,0);

								 VK_HOME : PostMessage (Dialog,WM_HSCROLL,SB_PAGEUP,0);
								 VK_END  : PostMessage (Dialog,WM_HSCROLL,SB_PAGEDOWN,0);
								 VK_LEFT : PostMessage (Dialog,WM_HSCROLL,SB_LINEUP,0);
								 VK_RIGHT: PostMessage (Dialog,WM_HSCROLL,SB_LINEDOWN,0);
				 end;
				 exit;
			 end;

			WM_KEYUP:
				begin
				 case (wParam) of
						VK_UP,
						VK_DOWN,
						VK_PRIOR,
						VK_NEXT : PostMessage (Dialog,WM_VSCROLL,SB_ENDSCROLL,0);

						VK_HOME,
						VK_END,
						VK_LEFT,
						VK_RIGHT : PostMessage (Dialog,WM_HSCROLL,SB_ENDSCROLL,0);
				end;
				exit;
			end;

			WM_HSCROLL,
			WM_VSCROLL:
				begin
					PostMessage(GetParent(Dialog), Message, wParam, lParam);
				end;

		WM_SETCURSOR :
			begin
				{SetCursor(LoadCursor(0,IDC_UPARROW));
				exit;}
			end;

		WM_NCPAINT :
			begin
				SubClsBmpProc := BOOL(CallWindowProc(WNDPROC(lpOldBmpProc), Dialog, Message, wParam,	lParam));

                                GetWindowRect(Dialog, r);
				MapWindowPoints(0, Dialog, r, 2);
				dc := GetWindowDC(Dialog);

                                dwStyle := GetWindowLong(Dialog, GWL_STYLE);

				if (dwStyle AND WS_VSCROLL) = WS_VSCROLL then begin
					SelectObject(dc, GetStockObject(BLACK_PEN));
				end else begin
					SelectObject(dc, GetStockObject(WHITE_PEN));
				end;

				MoveTo(dc, r.left + 1, r.bottom);
				LineTo(dc, r.right, r.bottom);
				LineTo(dc, r.right, r.top - 1);

				if (dwStyle AND WS_HSCROLL) = WS_HSCROLL then begin
					dec(r.bottom, GetSystemMetrics(SM_CYHSCROLL) - 1);
				end;

				if (dwStyle AND WS_VSCROLL) = WS_VSCROLL then begin
					dec(r.right, GetSystemMetrics(SM_CXVSCROLL) - 1);
				end;

				MoveTo(dc, r.left + 1, r.bottom);
				LineTo(dc, r.right, r.bottom);
				LineTo(dc, r.right, r.top - 1);

				if ((dwStyle AND WS_HSCROLL) = WS_HSCROLL) AND
					 ((dwStyle AND WS_VSCROLL) = WS_VSCROLL) then begin
					SelectObject(dc, GetStockObject(WHITE_PEN));
					MoveTo(dc, r.right + 1, r.bottom + GetSystemMetrics(SM_CYHSCROLL) - 1);
					LineTo(dc, r.right + GetSystemMetrics(SM_CXVSCROLL) - 1, r.bottom + GetSystemMetrics(SM_CYHSCROLL)- 1);
					LineTo(dc, r.right + GetSystemMetrics(SM_CXVSCROLL) - 1, r.bottom);
				end;

				SelectObject(dc, CreatePen(PS_SOLID, 1, RGB(128, 128, 128)));

				MoveTo(dc, r.right - 1, r.top + 1);
				LineTo(dc, r.left + 1, r.top + 1);
				LineTo(dc, r.left + 1, r.bottom);

				DeleteObject(SelectObject(dc, GetStockObject(BLACK_PEN)));
				ReleaseDC(Dialog, dc);
				exit;
			end;

		WM_ERASEBKGND :
			begin
				if GetWindow(Dialog, GW_CHILD) = 0 then UpdateWindow(GetParent(Dialog));
				exit;
				{GetClientRect(Dialog, r);
				dc := HDC(wParam);
				SaveDC(dc);
				ExcludeClipRect(dc,
								r.left,  r.top,
								r.right, r.bottom);
				SubClsBmpProc := BOOL(CallWindowProc(lpOldBmpProc, Dialog, Message, wParam,	lParam));
				RestoreDC(dc, -1);
				exit;}
			end;

		MM_MCINOTIFY :
			begin
				SendMessage(hMciQueueProc, message, wParam, lParam);
			end;

	end;
	SubClsBmpProc := BOOL(CallWindowProc(WNDPROC(lpOldBmpProc), Dialog, Message, wParam,	lParam));
end;

{*************************************************************}
{**                  Fonction GraphiqueProc                 **}
{** SE: Fonction de gestion de la zone de graphisme bit-map **}
{** SI: En fonction des messages envoyés à la dialogue      **}
{**                                                         **}
{**   La dialogue est Overlapped pour pouvoir s'afficher    **}
{** sur la fenêtre vidéo.                                   **}
{*************************************************************}
function GraphiqueProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

{--------------------------------------------------------------------------------------}
const
		Wnd_x : Integer = 0;
		Wnd_y : Integer = 0;
		Wnd_w : Integer = 0;
		Wnd_h : Integer = 0;

{--------------------------------------------------------------------------------------}
var dc	: HDC;
		r		: TRECT;
		ps  : TPAINTSTRUCT;
		iMax,
		iMin,
		iPos,
		dn							: integer;
		nReturn 				: integer;
		szHandle 				: array[0..6] of char;
		MciCommandStr		: TMCISTR;
		MciReturnStr		: TMCISTR;
		pt : TPOINT;
		szFormat,
		szLink,
		szLine 	: array[0..255]of char;
		nW			: integer;
		dw			: DWORD;
		wRet		: WORD;

const
		hdib		: THandle = 0;
		di			: TDIBINFO = ();
		OldDIB	: HANDLE = 0;
		bDrawn  : BOOL = FALSE;
		bDraw	  : BOOL = TRUE;
		nWidth : integer = 0;
		{ arg list... }
		pLink		: PChar = nil;
		biW			: integer = 0;
		biH			: integer = 0;
		biBC		: integer = 0;
		pComp		: PChar = nil;
		biSI		: integer = 0;
		wndW		: integer = 0;
		wndH		: integer = 0;
		{ ...ne pas intervertir !!! }

{--------------------------------------------------------------------------------------}
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+14, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	GraphiqueProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of

		{-- Initialisation de la dialogue --}
		wm_InitDialog:
			begin
				{ Affichage de la Dialog }
				PostMessage(Dialog, WM_MMPAINT, 0, 0);
			end;

	 {-- Affichage de la Dialog --}
		WM_MMPAINT :
			begin
                                GetWindowRect(Dialog, R);
				MapWindowPoints(HWND_DESKTOP, GetParent(Dialog), R, 2);
				if (bWin95 OR bWinNT) then begin
					nWidth := GetSystemMetrics(SM_CXFRAME);
					SetWindowPos(Dialog, 0,
											 R.left - nWidth - 3, R.top - nWidth - 2,
											 R.right - R.left + nWidth, R.bottom - R.top + nWidth,
											 SWP_NOZORDER OR SWP_NOREDRAW);
				end else begin
					SetWindowPos(Dialog, 0, R.left - 1, R.top, 0, 0, SWP_NOZORDER OR SWP_NOSIZE OR SWP_NOREDRAW);
					nWidth := GetSystemMetrics(SM_CXDLGFRAME);
				end;

                                SetWindowPos(Dialog, 0, (R.left * 110) div 100 , (R.top * 50) div 100, ((R.right - R.left) * 125) div 100, ((R.bottom - R.top) * 100) div 100, SWP_NOZORDER OR SWP_NOREDRAW);

                                {$IFNDEF _E0}
				AdjustToDesktop(Dialog);
				{$ENDIF}
				GetWindowRect(Dialog,r);
				MapWindowPoints(0, Window, R, 2);
				Wnd_x := R.Left;
				Wnd_y := R.Top;
				Wnd_w := R.Right - R.Left;
				Wnd_h := R.Bottom - R.Top;

				{ Start SubClassing de Ctl 101 pour recevoir les WM_xSCROLL }
				//lpSubClsBmpProc := MakeProcInstance(@SubClsBmpProc, hInstance);
				lpSubClsBmpProc := @SubClsBmpProc;
				lpOldBmpProc := TFARPROC(SetWindowLong(GetDlgItem(Dialog, 101), GWL_WNDPROC, LongInt(lpSubClsBmpProc)));
				OldDIB := 0;
				di.hdd := 0;
				di.hdib := 0;
				if di.havi <> 0 then DestroyWindow(di.havi);
				di.havi := 0;
				di.len := 0;
				StrCopy(di.achFileName, '');
				di.hwin := GetDlgItem(Dialog, 101);
				di.hpar := Dialog;
				bStreched := TRUE;
				di.iZoom := 0;
				InitDib(di, hdib, TRUE);
				SizeWindowToImage(di);
				InvalidateRect(di.hWin, nil, FALSE);
				ShowWindow(Dialog, SW_SHOW);
			end;

		WM_GETMINMAXINFO :
			Begin
				PMinMaxInfo(lParam)^.ptMinTrackSize.X := 0;
				PMinMaxInfo(lParam)^.ptMinTrackSize.Y := 0;
			End;

	 {-- Destruction de la Dialog --}
		WM_DESTROY :
			begin
				{WriteLn('Destruction de l''image');}
				ReleaseBitmap(hdib);
				DrawDibClose(di.hdd);
				di.hdd := 0;
				{ Stop SubClassing de Ctl 101 pour recevoir les WM_xSCROLL }
				SetWindowLong(GetDlgItem(Dialog, 101), GWL_WNDPROC, LongInt(lpOldBmpProc));
				//FreeProcInstance(lpSubClsBmpProc);
			end;

{$IFDEF _E0}  { Créateur... }
		WM_SETCURSOR :
			begin
				if LOWORD(lParam) = HTCAPTION then begin
					SetCursor(LoadCursor(0,IDC_SIZE));
					SetWindowLong(Dialog, DWL_MSGRESULT, MAKELONG(WORD(TRUE), 0));
					exit;
				end;
			end;

		WM_MOUSEACTIVATE :
		begin
			 GetWindowText(GetDlgItem(hListBar, 1205), szLine, SizeOf(szLine));
			 if StrComp(szLine, mmLoadString(hInstRes, STR_LINKAVI)) = 0 then begin
				 CheckRadioButton(hListBar, 1200, 1207, 1205);
			 end else begin
				 CheckRadioButton(hListBar, 1200, 1207, 1201);
			 end;
			 PostMessage(Dialog, WM_USER, 0, 0);
		end;

		UM_SETSTATUSTEXT :
		begin
			dw := di.bi.biCompression;
			case dw of
					 BI_RGB :   dw := MKFOURCC('N', 'o', 'n', 'e');
					 BI_RLE4:   dw := MKFOURCC('R', 'l', 'e', '4');
					 BI_RLE8:   dw := MKFOURCC('R', 'l', 'e', '8');
			end;
			GetWindowText(Dialog, szFormat, SizeOf(szFormat));
			GetDlgItemText(Dialog, 102, szLink, SizeOf(szLink));
			pLink := @szLink;
			if di.hdib > 0 then begin
				if szLink[0] <> #0 then StrCat(szFormat, ' (%dx%dx%d ''%4.4ls'' %dk) Wnd(%dx%d)');
				biW		:= di.bi.biWidth;
				biH		:= di.bi.biHeight;
				biBC	:= di.bi.biBitCount;
				pComp	:= PChar(@dw);
				biSI	:= di.bi.biSizeImage DIV 1024;

				if (bWin95 OR bWinNT) then begin
					nW := GetSystemMetrics(SM_CXFRAME) + 2;
				end else begin
					nW := GetSystemMetrics(SM_CXDLGFRAME) + 2;
				end;
				GetClientRect(Dialog, r);
				InflateRect(r, -nW,  -nW);
				wndW	:= r.right - r.left;
				wndH	:= r.bottom - r.top;
			end;
			wvsprintf(szLine, szFormat, pLink);
			SetDlgItemText(hStatusBar, 101, szLine);

			if hOldHandled <> hGraphiqueProc then begin
				if hOldHandled <> 0 then begin
					SetWindowPos(hOldHandled, 0, 0, 0, 0, 0, SWP_DRAWFRAME OR SWP_NOMOVE OR SWP_NOSIZE OR SWP_NOZORDER OR SWP_NOACTIVATE);
					UpdateHandle(hOldHandled);
				end;
				UpdateHandle(hGraphiqueProc);
				hOldHandled := hGraphiqueProc;
			end;

		end;

		WM_NCHITTEST :
			begin
				SetWindowLong(Dialog, 0{DWL_MSGRESULT}, ProcessHitTest(Dialog, message, wParam, lParam));
				exit;
			end;

		WM_PAINT :
			begin
				UpdateWindow(hBoutonsProc);
				UpdateWindow(hLeconProc);
				dc := BeginPaint(Dialog, ps);
				EndPaint(Dialog, ps);
				if (IsDlgButtonChecked(hListBar, 1201) = 1) OR
					 (IsDlgButtonChecked(hListBar, 1205) = 1) then begin
					dc := GetWindowDC(Dialog);
					ShowHandle(dc, Dialog);
					ReleaseDC(Dialog, dc);
				end;
			end;
{$ELSE}  { Créateur... }
		WM_PAINT :
			begin
				UpdateWindow(hBoutonsProc);
				UpdateWindow(hLeconProc);
				dc := BeginPaint(Dialog, ps);
				EndPaint(Dialog, ps);
			end;
{$ENDIF}  { Créateur... }

		WM_WINDOWPOSCHANGING : { TWINDOWPOS }
		begin
			UpdateHandle(Dialog);
			if IsZoomed(Dialog) then begin
				GetWindowRect(GetParent(Dialog), r);
				MapWindowPoints(0, Window, r, 2);
				{WINDOWPOS(lParam)^.x := -GetSystemMetrics(SM_CXDLGFRAME);
				PWINDOWPOS(lParam)^.y := -GetSystemMetrics(SM_CYDLGFRAME);
				PWINDOWPOS(lParam)^.cx := r.right - r.left + 2 * GetSystemMetrics(SM_CXDLGFRAME)   - 1;
				PWINDOWPOS(lParam)^.cy := r.bottom - r.top + 2 * GetSystemMetrics(SM_CYDLGFRAME) - 1;  }
				PWINDOWPOS(lParam)^.x := 0;
				PWINDOWPOS(lParam)^.y := 0;
				PWINDOWPOS(lParam)^.cx := r.right - r.left - 2;
				PWINDOWPOS(lParam)^.cy := r.bottom - r.top - 2;
			end;
		end;

		WM_WINDOWPOSCHANGED : { TWINDOWPOS }
		begin
			UpdateHandle(Dialog);
		end;

		WM_USER + 1000 :
			begin
				{ Init DrawsDib }
				di.hwin := GetDlgItem(Dialog, 101);
				di.hpar := Dialog;
				di.iZoom := 0;
				di.bi.biWidth  := 10;
				di.bi.biHeight := 10;
				StrCopy(di.achFileName, '');
				ReleaseBitmap(hdib);
				{if di.hdd <> 0 then DrawDibClose(di.hdd);}
				InitDib(di, 0, TRUE);
			end;

			WM_USER + 1004 :
				begin
					if wParam = 0 then begin
						bStreched := TRUE;
						di.iZoom := 0;
					end else begin
						bStreched := FALSE;
						if wParam > 0 then begin
							di.iZoom := wParam;
						end else begin
							di.iZoom := ZOOM;
						end;
					end;
					SizeWindowToImage(di);
					InvalidateRect(di.hwin, nil, FALSE);
				end;

			WM_USER + 1005 :
				begin
					MoveWindow(Dialog, Wnd_x, Wnd_y, Wnd_w, Wnd_h, TRUE);
				end;

			WM_USER + 1006 :
				begin
					{Renvoi pointeur su di}
					SetWindowLong(Dialog, DWL_MSGRESULT, DWORD(@di));
					Exit;
				end;

			{ Fermer la vidéo en cours }
			WM_USER + 1010 :
				begin
					StrCopy(MciCommandStr, 'STOP VIDEO WAIT');
					mciSendString(MciCommandStr,nil,0,0);
					StrCopy(MciCommandStr, 'CLOSE VIDEO WAIT');
					mciSendString(MciCommandStr,nil,0,0);

					if bVideoWave then begin
						StrCopy(MciCommandStr, 'STOP SON WAIT');
						mciSendString(MciCommandStr,nil,0,0);
						StrCopy(MciCommandStr, 'CLOSE SON WAIT');
						mciSendString(MciCommandStr,nil,0,0);
					end;

					if di.havi <> 0 then DestroyWindow(di.havi);
					di.havi := 0;

				end;

			{ Charger la nouvelle image }
			WM_USER + 1011 :
				begin

					OldDIB := 0;
					di.hdib := 0;
					if di.havi <> 0 then DestroyWindow(di.havi);
					di.havi := 0;
					di.len := 0;
					StrCopy(di.achFileName, PChar(lParam));
					ReleaseBitmap(hdib);
					LoadBitmapFile(di.achFileName, hdib);
					di.hwin := GetDlgItem(Dialog, 101);
					di.hpar := Dialog;
					if bStreched then begin
						di.iZoom := 0;
					end else begin
						if wParam > 0 then begin
							di.iZoom := wParam;
						end else begin
							di.iZoom := ZOOM;
						end;
					end;
					{DrawDibClose(di.hdd);}
					InitDib(di, hdib, FALSE);

					bDraw := FALSE;
					{InvalidateRect(di.hWin, nil, FALSE);
					UpdateWindow(di.hWin);}

				end;

			{ Charger la nouvelle video }
			WM_USER + 1012 :
				begin

					StrCopy(di.achFileName, PChar(lParam));
					if bVideoWave then begin
						StrCopy(szVideoWave, di.achFileName);
						pVideoWave := StrPos(szVideoWave, '.');
						if pVideoWave <> nil then begin
							pVideoWave[0] := #0;
							StrCat(szVideoWave, '.WAV');
							StrECopy(StrECopy(StrECopy(
							MciCommandStr, 'OPEN '),szVideoWave),' ALIAS SON WAIT');
							mciSendString(MciCommandStr, nil, 0, 0);
						end;
					end;

					if bVideoNotChild then begin
						StrECopy(StrECopy(StrECopy(
							MciCommandStr, 'OPEN '),di.achFileName),' ALIAS VIDEO STYLE POPUP WAIT');
					end else begin
						StrPcopy(szHandle, IntToStr(GetDlgItem(Dialog, 101)));
						StrECopy(StrECopy(StrECopy(StrECopy(StrECopy(
							MciCommandStr, 'OPEN '),di.achFileName),' ALIAS VIDEO STYLE CHILD PARENT '), szHandle), ' WAIT');
					end;
					SendMci(MciCommandStr, nil, 0);

					StrCopy(MciCommandStr, 'STATUS VIDEO WINDOW HANDLE WAIT');
					if SendMci(MciCommandStr, @MciReturnStr, 0) = 0 then begin
						Val(MciReturnStr, di.havi, nReturn);
						if nReturn = 0 then begin

							if bVideoNotChild then begin
								SetWindowPos(di.havi, 0, 0, 0, 0, 0, SWP_NOZORDER);
							end;

							ShowWindow(di.havi, SW_HIDE);
							di.len := 1;
							StrCopy(MciCommandStr, 'STATUS VIDEO LENGTH WAIT');
							if SendMci(MciCommandStr, @MciReturnStr, 0) = 0 then begin
								Val(MciReturnStr, di.len, nReturn);
								if nReturn <> 0 then di.len := -1;
							end;
							dec(di.len);
							ReleaseBitmap(hdib);
							{if di.hdd <> 0 then DrawDibClose(di.hdd);}
							InitDib(di, 0, FALSE);
							OldDIB := 0;
							di.hdib := HANDLE(-1);
							GetClientRect(di.havi, di.rcSource);
							di.bi.biWidth  := di.rcSource.right;
							di.bi.biHeight := di.rcSource.bottom;
							di.hwin := GetDlgItem(Dialog, 101);
							di.hpar := Dialog;
							if bStreched then begin
								di.iZoom := 0;
							end else begin
								if wParam > 0 then begin
									di.iZoom := wParam;
								end else begin
									di.iZoom := ZOOM;
								end;
							end;
						end else begin
							WriteLn('Invalid Video Window Handle : ', MciCommandStr);
						end;
					end else begin
						WriteLn('Video Window Handle not found.');
					end;

					StrCopy(MciCommandStr, 'STOP VIDEO WAIT');
					AddMciCloseQueueString(MciCommandStr);

					if bVideoWave then begin
						StrCopy(MciCommandStr, 'STOP SON WAIT');
						AddMciCloseQueueString(MciCommandStr);
						StrCopy(MciCommandStr, 'CLOSE SON WAIT');
						AddMciCloseQueueString(MciCommandStr);
					end;

					bDraw := FALSE;
					{InvalidateRect(di.hWin, nil, FALSE);
					UpdateWindow(di.hWin);}

				end;

			{ Jouer la nouvelle image }
			WM_USER + 1013 :
				begin

					SizeWindowToImage(di);
					bDrawn := FALSE;
					SendMessage(Dialog, WM_QUERYNEWPALETTE, 0, 0);
					bDraw := TRUE;
					InvalidateRect(di.hWin, nil, FALSE);
				end;

			{ Jouer la nouvelle video }
			WM_USER + 1014 :
				begin

					SizeWindowToImage(di);
					dc := GetDC(di.hwin);
					if (di.hdib <> OldDIB) then begin
						FillRect(dc, di.rcDraw, GetStockObject(DKGRAY_BRUSH));
						OldDIB := di.hdib;
					end;
					ReleaseDC(di.hwin, dc);
					bDraw := TRUE;

					mciSendString('CUE VIDEO WAIT', nil, 0, 0);

					if bVideoNotNotify then begin
						if SendMci('PLAY VIDEO FROM 0', nil, 0) = 0 then begin
							SetTimer(hMciQueueProc, 3, 100, nil);
						end;
					end else begin
						if bVideoWave then begin
							mciSendString('PLAY SON', nil, 0, 0);
						end;
						StrCopy(MciCommandStr, 'PLAY VIDEO  FROM 0 NOTIFY');
						SendMci(MciCommandStr, nil, hMciQueueProc);
					end;
					ShowWindow(di.havi, SW_SHOW);
				end;

			{ Charger la nouvelle video avec tracker }
			WM_USER + 1015 :
				begin

					StrCopy(di.achFileName, PChar(lParam));
					if di.havi <> 0 then DestroyWindow(di.havi);
					di.havi := MCIWndCreate(GetDlgItem(Dialog, 101),
                                                   hInstance,
                                                   WS_CHILD OR
						   MCIWNDF_NOERRORDLG OR
						   MCIWNDF_NOMENU {OR MCIWNDF_NOOPEN} OR $0080,
                                                   PChar(lParam));

					di.len := 1;
					ReleaseBitmap(hdib);
					{if di.hdd <> 0 then DrawDibClose(di.hdd);}
					InitDib(di, 0, FALSE);
					OldDIB := 0;
					di.hdib := HANDLE(-1);
					GetClientRect(di.havi, di.rcSource);
					di.bi.biWidth  := di.rcSource.right;
					di.bi.biHeight := di.rcSource.bottom;
					di.hwin := GetDlgItem(Dialog, 101);
					di.hpar := Dialog;
					if bStreched then begin
						di.iZoom := 0;
					end else begin
						if wParam > 0 then begin
							di.iZoom := wParam;
						end else begin
							di.iZoom := ZOOM;
						end;
					end;

					bDraw := FALSE;
					{InvalidateRect(di.hWin, nil, FALSE);
					UpdateWindow(di.hWin);}

				end;

			{ Jouer la nouvelle video avec tracker }
			WM_USER + 1016 :
				begin

					SizeWindowToImage(di);
					dc := GetDC(di.hwin);
					if (di.hdib <> OldDIB) then begin
						FillRect(dc, di.rcDraw, GetStockObject(DKGRAY_BRUSH));
						OldDIB := di.hdib;
					end;
					ReleaseDC(di.hwin, dc);
					bDraw := TRUE;

					StrCopy(MciCommandStr, 'CUE');
					SendMessage(di.havi, MCIWNDM_SENDSTRING, 0, longint(@MciCommandStr));

					ShowWindow(di.havi, SW_SHOW);

					StrCopy(MciCommandStr, 'PLAY FROM 0 NOTIFY');
					SendMessage(di.havi, MCIWNDM_SENDSTRING, 0, longint(@MciCommandStr));

					{SendMessage(di.havi, MCIWNDM_PLAYREVERSE, 0, 0);}

					StrCopy(MciCommandStr, 'PAUSE');
					InsMciQueueString(MciCommandStr, 0);

				end;

			WM_VSCROLL:
				begin
						GetScrollRange(di.hwin,SB_VERT,iMin,iMax);
						iPos := GetScrollPos(di.hwin,SB_VERT);
						GetClientRect(di.hwin,r);

						case wParam of
								 SB_LINEDOWN:      dn :=  r.bottom DIV 16 + 1;
								 SB_LINEUP:        dn := -r.bottom DIV 16 + 1;
								 SB_PAGEDOWN:      dn :=  r.bottom DIV 2  + 1;
								 SB_PAGEUP:        dn := -r.bottom DIV 2  + 1;
								 SB_THUMBTRACK,
								 SB_THUMBPOSITION: dn := LOWORD(lParam)-iPos;
						else                   dn := 0;
						end;

						dn := BOUND(iPos+dn,iMin,iMax) - iPos;
						if (dn <> 0) then	begin
								ScrollWindow(di.hwin,0,-dn,nil,nil);
								SetScrollPos(di.hwin,SB_VERT,iPos + dn, TRUE);
								PostMessage(GetDlgItem(Dialog, 101), WM_NCPAINT, 0, 0);
								PostMessage(GetDlgItem(Dialog, 101), WM_PAINT, 0, 0);
								{UpdateWindow(di.hwin);}
						end;
						exit;
				 end;

			 WM_HSCROLL:
				 begin
						GetScrollRange(di.hwin,SB_HORZ,iMin,iMax);
						iPos := GetScrollPos(di.hwin,SB_HORZ);
						GetClientRect(di.hwin,r);

						case (wParam) of
								 SB_LINEDOWN:      dn :=  r.right DIV 16 + 1;
								 SB_LINEUP:        dn := -r.right DIV 16 + 1;
								 SB_PAGEDOWN:      dn :=  r.right DIV 2  + 1;
								 SB_PAGEUP:        dn := -r.right DIV 2  + 1;
								 SB_THUMBTRACK,
								 SB_THUMBPOSITION: dn := LOWORD(lParam)-iPos;
						else				           dn := 0;
						end;
						dn := ALIGNB(dn);
						dn := BOUND(iPos+dn,iMin,iMax) - iPos;
						if (dn <> 0) then	begin
								ScrollWindow(di.hwin,-dn,0,nil,nil);
								SetScrollPos(di.hwin,SB_HORZ,iPos + dn, TRUE);
								PostMessage(GetDlgItem(Dialog, 101), WM_NCPAINT, 0, 0);
								PostMessage(GetDlgItem(Dialog, 101), WM_PAINT, 0, 0);
								{UpdateWindow(di.hwin);}
						end;
						exit;
				 end;

{	TMeasureItemStruct = record
		CtlType: Word;
		CtlID: Word;
		itemID: Word;
		itemWidth: Word;
		itemHeight: Word;
		itemData: Longint;
	end;}

		WM_MEASUREITEM :
			begin
				GetClientRect(GetDlgItem(Dialog, 101), r);
				PMeasureItemStruct(lParam)^.itemWidth := r.right;
				PMeasureItemStruct(lParam)^.itemHeight := r.bottom;
			end;

	{TDrawItemStruct = record
		CtlType: Word;
		CtlID: Word;
		itemID: Word;
		itemAction: Word;
		itemState: Word;
		hwndItem: HWnd;
		hDC: HDC;
		rcItem: TRect;
		itemData: Longint;
	end;}

		WM_DRAWITEM :
			if ((PDrawItemStruct(lParam)^.itemAction AND ODA_DRAWENTIRE) = ODA_DRAWENTIRE) AND
					bDraw then begin
				dc := PDrawItemStruct(lParam)^.hDC;
				if (di.hdib <> 0) then begin
					SetWindowOrgEx(dc, GetScrollPos(di.hwin, SB_HORZ), GetScrollPos(di.hwin, SB_VERT), nil);
					if (di.hdib <> HANDLE(-1)) then begin
						if NOT BOOL(DrawDibDraw(di.hdd, dc,
																		di.rcDraw.left,
																		di.rcDraw.top,
																		di.rcDraw.right - di.rcDraw.left,
																		di.rcDraw.bottom - di.rcDraw.top,
																		di.lpbi, nil,
																		di.rcSource.left,
																		di.rcSource.top,
																		di.rcSource.right - di.rcSource.left,
																		di.rcSource.bottom - di.rcSource.top,
																		DDF_BACKGROUNDPAL)) then
						begin
							MessageBox(window, 'Unable to draw DIB.', 'DrawDib', MB_APPLMODAL OR MB_ICONSTOP);
							FillRect(dc, di.rcDraw, GetStockObject(DKGRAY_BRUSH));
						end;
					end;
				end else begin
					if (di.havi <> 0) AND IsWindowVisible(di.havi) then begin
						 ShowWindow(di.havi, SW_HIDE);
					end;
					GetClientRect(di.hwin, r);
					FillRect(dc, r, GetStockObject(DKGRAY_BRUSH));
				end;
				if NOT bDrawn then begin
					bDrawn := TRUE;
					PostMessage(hMciQueueProc,mm_MciNotify,0,0);
				end;
				{####MainQcmWin^.lpRepCollection^.Draw(di.hwin);}
			end;

	WM_PALETTECHANGED :
		begin
			if (di.hdd = 0) OR
				 (di.hdib = HANDLE(-1)) OR
				 (di.hdib = 0) then Exit;

			dc := GetDC(di.hwin);
			wRet := DrawDibRealize(di.hdd, dc, TRUE);
			if wRet <> 0 then	begin
				InvalidateRect(di.hwin, nil, FALSE);
			end;
			ReleaseDC(di.hwin, dc);
			Exit;
		end;

	WM_QUERYNEWPALETTE :
		begin
			if (di.hdd = 0) OR
				 (di.hdib = HANDLE(-1)) OR
				 (di.hdib = 0) then Exit;

			dc := GetDC(di.hwin);
			if (di.hdib <> OldDIB) then begin
				{ #### 256 couleurs ... #### }
				FillRect(dc, di.rcDraw, GetStockObject(DKGRAY_BRUSH));
				OldDIB := di.hdib;
			end;
			wRet := DrawDibRealize(di.hdd, dc, FALSE);
			if wRet <> 0 then	begin
				InvalidateRect(di.hwin, nil, FALSE);
			end;
			ReleaseDC(di.hwin, dc);
			Exit;
		end;

		{-- Change la taille de la fenêtre --}
		WM_MOVE : begin
                	{$IFDEF _TUTOR}
				if MainQcmWin^.bSizable  then begin
					GetWindowRect(Dialog, r);
					MapWindowPoints(0, GetParent(Dialog), r, 2);
					LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@SetImagePos), 0, longint(@r));
				end;
                        {$ENDIF}
		end;

		WM_SIZE :
			begin
				SizeWindowToImage(di);
				if (di.iZoom = 0) AND (di.hwin <> 0) then begin
					InvalidateRect(di.hwin, nil, FALSE);
				end;
				{ -- sauver la nouvelle position -- }
				PostMessage(Dialog, WM_MOVE, 0, 0);
			end;

		wm_Command:
			case LoWord(wParam) of
				idok:
					begin
					end;
			end;
	end;
	GraphiqueProc := FALSE;
end;
{**         Fin de la Procédure GraphiqueProc               **}
{*************************************************************}
function RestoreProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var
	nFin : integer;

begin

	RestoreProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of
		wm_InitDialog:
			begin
				hRestore := Dialog;
				CenterDialog(Dialog);
				RestoreReponsesInit(NoElev, tEtudiant);
			end;

		wm_Command: begin
			case LoWord(wParam) of
				idok:
					begin
						RestoreReponsesDone(NoElev, tEtudiant);
						EndDialog(Dialog, wParam);
					end;
				idcancel:
					begin
						EndDialog(Dialog, wParam);
					end;
			end;
		end;
	end;
	RestoreProc := FALSE;
end;

{*************************************************************}
{**                  Fonction MessageProc                   **}
{** SE: Procédure de traitement des messages envoyés        **}
{**     aux objets de la dialogue Message                   **}
{*************************************************************}
function MessagesProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var
	szLicence : array[0..255] of char;
        szLine : array[0..255] of char;
	nFin : integer;
{--------------------------------------------------------------------------------------}
const
	hDIB2: THandle = 0;
	pDIB2: PBitmapInfo = nil;
	pBits2 : Pointer = nil;
	hPal2 : THandle = 0;
	pPal2 : PLOGPALETTE = nil;
	Palette2 : HPalette = 0;
        hBmp : THandle = 0;

{--------------------------------------------------------------------------------------}
var    szImage : szLongName;
			 {Caption : Array[0..255]of char;
			 c	: Array[0..1]of char;}

{--------------------------------------------------------------------------------------}
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+15, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	MessagesProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of
		wm_InitDialog:
			begin

                                CenterDialog(Dialog);

				StrCopy(szNomEleve, tEtudiant.Nom);
				SetDlgItemText(Dialog,106,szNomEleve);
				SetFocus(GetDlgItem(Dialog,106));
				{$IFDEF _ASSIST}
					LoadBitmapResource(hInstRes, 'MABITMAP',hDIB2,pDIB2,pBits2,hPal2,pPal2,Palette2);
				{$ELSE}
					LoadBitmapResource(hInstRes, MAKEINTRESOURCE(LAVAC_DIB),hDIB2,pDIB2,pBits2,hPal2,pPal2,Palette2);
				{$ENDIF}
				{SetDlgItemText(Dialog, 10000, mmLoadString(hInstRes, -1));}
				StrCopy(szLicence, PathLavac);
				StrCat(szLicence, 'LAVAC.LIC');

                                GetPrivateProfileString('LAVAC64', 'LINE_1', '', szLine, SizeOf(szLine), gszIni);
                                StrCopy(szLicence, szLine);
                                StrCat(szLicence, #13+ #10);
                                GetPrivateProfileString('LAVAC64', 'LINE_2', '', szLine, SizeOf(szLine), gszIni);
                                StrCat(szLicence, szLine);
                                StrCat(szLicence, #13+ #10);
                                GetPrivateProfileString('LAVAC64', 'LINE_3', '', szLine, SizeOf(szLine), gszIni);
                                StrCat(szLicence, szLine);
                                StrCat(szLicence, #13+ #10);
				SetDlgItemText(Dialog, 10000, szLicence);
				//SetDlgItemText(Dialog, 10000, licGetText(Dialog, szLicence));

                                GetPrivateProfileString('LAVAC64', 'NAME', '', szLine, SizeOf(szLine), gszIni);
                                SetDlgItemText(Dialog, 106, szLine);

                                hBmp := LoadImage(0, 'C:\LAVAC\ico\LAVAC64.ico', IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                SendDlgItemMessage( Dialog, 1000, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                //hBmp := LoadImage(0, 'C:\LAVAC\ico\LAVAC64.bmp', IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                //SendDlgItemMessage( Dialog, 1000, BM_SETIMAGE, IMAGE_BITMAP, hBmp );
                                DeleteObject(hBmp);
                                //MessageBox(Window, PChar(sxml), 'sxml', MB_OK OR MB_APPLMODAL OR MB_ICONSTOP);

			end;

		wm_paint :
			begin
				//BeginPaint(Dialog,PS);
				//AfficheBitmapIn(GetDlgItem(Dialog,103),2,8, hDIB2, pDIB2, pBits2, Palette2, FALSE, FALSE);
				//EndPaint(Dialog,PS);
			end;

		wm_Command: begin
			case LoWord(wParam) of
				idok:
					begin
						GetDlgItemText(Dialog,106, szNomEleve, SizeOf(szNomEleve));

                                                SetDlgItemText(hLeconProc,5002, szNomEleve);

						Correction := False;
						if StrLen(szNomEleve) > 0 then begin
							InitEtudiantLst;
							{if NoELEV<10 then
								StrPCopy(tEtudiant.Nom, '  '+IntToStr(NoELEV)+' - ')
							else
								StrPCopy(tEtudiant.Nom,IntToStr(NoELEV)+' - ');
							StrCat(tEtudiant.Nom,szNomEleve);}
                                                        WritePrivateProfileString('LAVAC64', 'NAME', szNomEleve, gszIni);

							StrCopy(tEtudiant.Nom, szNomEleve);
							tEtudiant.Appel := False;
							{StrCopy(tEtudiant.FichierSonAppel, '');}
							tEtudiant.LeconEnCours := -1;
							tEtudiant.QuestionEnCours := -1;
							tEtudiant.ReponseEnCours := -1;
							tEtudiant.Score := 0;
							tEtudiant.MaxPoints := 0;
							tEtudiant.MinPoints := 0;
							if tEtudiant.LessonName[0] = #0 then StrCopy(tEtudiant.LessonName, 'None');
							SetEtudiantRec(NoElev,tEtudiant);
						end else begin
							MessageBeep(0);
							SetFocus(GetDlgItem(Dialog,106));
							Exit;
						end;
						if IsDlgButtonChecked(Dialog,109)=1 {restaure} then begin
							CheckDlgButton(Dialog,109,0);
							GetDlgItemText(Dialog,106, tEtudiant.Nom, SizeOf(tEtudiant.Nom));
							StrCopy(szNomEleve, tEtudiant.Nom);
							nFin := DialogBox(hInstRes, 'Restore', Window, DLGPROC(@RestoreProc));
							if nFin = IDOK then begin
							end;
							{RestoreReponses(NoElev, tEtudiant);}
							{StrECopy(StrECopy(StrECopy(StrECopy(StrECopy(StrECopy(StrECopy(StrECopy(StrECopy(
							szMessage, mmLoadString(hInstRes, STR_ENDRESTORE)),
							#13),
							#10),
							mmLoadString(hInstRes, STR_STUDENT)),
							tEtudiant.Nom),
							#13),
							#10),
							mmLoadString(hInstRes, STR_LESSON)),
							tEtudiant.LessonName);
							MessageBox(Window,szMessage, mmLoadString(hInstRes, STR_RESTORE),MB_OK OR MB_ICONINFORMATION);}
							if IsDlgButtonChecked(hMessagesProc, 108)=1 {mode correction} then begin
								Correction := TRUE;
							end else begin
							end;
							SetEtudiantRec(NoElev,tEtudiant);
							SetDlgItemText(Dialog,106,tEtudiant.Nom);
						end else begin
							tEtudiant.Position := 0;
							StrCopy(tEtudiant.Nom, '');
						end;
						if StrLen(szNomEleve) > 0 then begin
							SetTimer(window,timer_Heure,duree_timer_heure,nil);
							SetTimer(window,timer_Messages,duree_timer_Messages,nil);
							ReleaseBitmapRessource(hDIB2,hPal2);
							{KillTimer(Dialog, timer_Scroll);}
							EndDialog(Dialog,1)
						end;
					end;
			end;
		end;
	end;
	MessagesProc := FALSE;
end;
{**         Fin de la Procédure MessagesProc                **}
{*************************************************************}

function OpenLessonProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var
	wTyp			: WORD;
	szText		: array[0..1] of char;
	szBmp			: array[0..fsFileName] of Char;
	wRet			: WORD;
	r		 			: TRECT;
	dc	 			: HDC;
	OldPen 		: HPEN;
	OldBrush	: HBRUSH;
	lg 				: LongInt;
	OldBmp,
	hBmp 			: hBitmap;
	BmpDC 		: hDC;
	pszFile		: PChar;
	item 			: WORD;
	action		: WORD;
	state			: WORD;
	PathFichier : szLongName;

Const
	nIndex		: integer = 0;
	OldPathLecons		: szLongName= '';

begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+16, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	OpenLessonProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of
		wm_InitDialog:
			begin
				OldPathLecons := PathLecons;
				CenterDialog(Dialog);
				LessonInDlgLB(Dialog, 101, TRUE);
				nIndex := lParam;
				if nIndex <> LB_ERR then begin
					SendDlgItemMessage(Dialog, 101, LB_SETCURSEL, WORD(nIndex), 0);
					SendDlgItemMessage(Dialog, 101, LB_SETCARETINDEX, WORD(nIndex), MAKELONG(0, 0));
				end;

				SendDlgItemMessage(Dialog, 104, LB_SETCOLUMNWIDTH, 40, 0);
				SendDlgItemMessage(Dialog, 104, LB_SETITEMHEIGHT, 0, Longint(16));
				for i:= 0 to 25 do begin
					wTyp := GetDriveType(i);
					szText[0] := Chr(i + Ord('A'));
					szText[1] := #0;
					if wTyp <> 0 then begin
						wRet := SendDlgItemMessage(Dialog, 104, LB_ADDSTRING, 0, longint(@szText));
						SendDlgItemMessage(Dialog, 104, LB_SETITEMDATA, wRet, Longint(wTyp));
						if szText[0] = UpCase(PathLecons[0]) then begin
							SendDlgItemMessage(Dialog, 104, LB_SETCURSEL, wRet, 0);
						end;
					end;
				end;
			end;

{	TMeasureItemStruct = record
		CtlType: Word;
		CtlID: Word;
		itemID: Word;
		itemWidth: Word;
		itemHeight: Word;
		itemData: Longint;
	end;}

		WM_MEASUREITEM :
			begin
				GetClientRect(GetDlgItem(Dialog, 104), r);
				PMeasureItemStruct(lParam)^.itemWidth := r.right;
				PMeasureItemStruct(lParam)^.itemHeight := 16;{####r.bottom;}
			end;

	{TDrawItemStruct = record
		CtlType: Word;
		CtlID: Word;
		itemID: Word;
		itemAction: Word;
		itemState: Word;
		hwndItem: HWnd;
		hDC: HDC;
		rcItem: TRect;
		itemData: Longint;
	end;}

		WM_DRAWITEM :
			begin
				dc := PDrawItemStruct(lParam)^.hDC;
				r := PDrawItemStruct(lParam)^.rcItem;
				item := PDrawItemStruct(lParam)^.itemID;
				action := PDrawItemStruct(lParam)^.itemAction;
				state := PDrawItemStruct(lParam)^.itemState;
				if Boolean(action AND ODA_SELECT) OR
					 Boolean(action AND ODA_DRAWENTIRE) then begin
					if Boolean(state AND ODS_SELECTED) then begin
						OldPen := SelectObject(dc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_HIGHLIGHT)));
						OldBrush := SelectObject(dc, CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)));
						Rectangle(dc, r.left, r.top, r.right, r.bottom);
						SetBkColor(DC, GetSysColor(COLOR_HIGHLIGHT));
						SetTextColor(DC, GetSysColor(COLOR_HIGHLIGHTTEXT));
					end else begin
						OldPen := SelectObject(dc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOW)));
						OldBrush := SelectObject(dc, CreateSolidBrush(GetSysColor(COLOR_WINDOW)));
						Rectangle(dc, r.left, r.top, r.right, r.bottom);
						SetBkColor(DC, GetSysColor(COLOR_WINDOW));
						SetTextColor(DC, GetSysColor(COLOR_MENUTEXT));
					end;
					DeleteObject(SelectObject(dc, OldBrush));
					DeleteObject(SelectObject(dc, OldPen));
					lg := SendMessage(PDrawItemStruct(lParam)^.hWndItem,
														LB_GETTEXT,
														item,
														Longint(@szText));
					if lg > 0 then TextOut(dc, r.left + 26, r.top + 1, szText, lg);
					wTyp := SendMessage(PDrawItemStruct(lParam)^.hWndItem,
														LB_GETITEMDATA,
														item,
														0);
					Case wTyp of
						DRIVE_REMOVABLE :	StrCopy(szBmp, 'REMOVABL');
						DRIVE_FIXED 		:	StrCopy(szBmp, 'FIXEDDRV');
						DRIVE_REMOTE 		: StrCopy(szBmp, 'REMOTE');
						DRIVE_CDROM 		: StrCopy(szBmp, 'CDROM');
					end;
					hBmp := LoadBitmap(HInstRes, szBmp);
					BmpDC := CreateCompatibleDC(dc);
					OldBmp := SelectObject(BmpDC, hBmp);
					BitBlt(dc, r.left + 1,
										 r.top + 1,
										 r.left + 23 + 1,
										 r.top + 14 + 1,
										 BmpDC, 0, 0, SrcCopy);
					SelectObject(BmpDC, OldBmp);
					DeleteDC(BmpDC);
					DeleteObject(hBmp);
				end;
			end;

		wm_Command:
		begin
			case LoWord(wParam) of

				101:
					begin
						//Case HiWord(LPARAM) of
        					Case HiWord(wPAram) of
							LBN_DBLCLK :
								begin
									PostMessage(Dialog, Message, idok, 0);
								end;
						end;
					end;

				104:
					begin
						//Case HiWord(LPARAM) of
						Case HiWord(wParam) of
							LBN_SELCHANGE:
								begin
									wRet := SendMessage(LoWord(LPARAM), LB_GETCURSEL, 0, 0);
									wRet := SendMessage(LoWord(LPARAM), LB_GETTEXT, wRet, longint(@szText));

									StrPCopy(PathLecons, szText[0]+':\LAVAC\LECONS\');
									StrCopy(PathFichier, PathLecons);
									StrCat(PathFichier, 'LECONS.LST');
									LessonInDlgLB(Dialog, 101, TRUE);
									if NOT FileExist(PathFichier) then begin
										EnableWindow(GetDlgItem(Dialog, idok), FALSE);
									end else begin
										EnableWindow(GetDlgItem(Dialog, idok), TRUE);
									end;
								end;
						end;
					end;

				idok:
					begin
						LessonInDlgCombo(hListBar, idl_lecon, FALSE);
						LessonInDlgCombo(hLeconProc, idl_lecon, FALSE);
						EndDialog(Dialog, SendDlgItemMessage(Dialog, 101, LB_GETCURSEL, 0, 0));
					end;

				idcancel:
					begin
						PathLecons := OldPathLecons;
						EndDialog(Dialog, nIndex);
					end;
			end;
		end;
	end;
	OpenLessonProc := FALSE;
end;

{*************************************************************}
{**                  Fonction AboutEndProc                  **}
{** SE: Procédure de traitement des messages envoyés        **}
{**     aux objets de la dialogue Message                   **}
{*************************************************************}
function AboutEndProc(Dialog: HWnd; Message, WParam: DWord;
  LParam: Longint): Bool; stdcall;

var    szImage : szLongName;
	szLicence : array[0..255] of char;
        szLine : array[0..255] of char;
{--------------------------------------------------------------------------------------}

const
	hDIB2: THandle = 0;
	pDIB2: PBitmapInfo = nil;
	pBits2 : Pointer = nil;
	hPal2 : THandle = 0;
	pPal2 : PLOGPALETTE = nil;
	Palette2 : HPalette = 0;
	hBmp : THandle = 0;

	var DC : HDC;

{--------------------------------------------------------------------------------------}
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+17, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	AboutEndProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

        case Message of
		wm_InitDialog:
			begin
				CenterDialog(Dialog);
				SetFocus(GetDlgItem(Dialog,109));
				{$IFDEF _ASSIST}
					LoadBitmapResource(hInstRes, 'MABITMAP',hDIB2,pDIB2,pBits2,hPal2,pPal2,Palette2);
				{$ELSE}
					LoadBitmapResource(hInstRes, MAKEINTRESOURCE(LAVAC_DIB),hDIB2,pDIB2,pBits2,hPal2,pPal2,Palette2);
				{$ENDIF}
				{SetDlgItemText(Dialog, 10000, mmLoadString(hInstRes, -1));}
				StrCopy(szLicence, PathLavac);
				StrCat(szLicence, 'LAVAC.LIC');
				//SetDlgItemText(Dialog, 10000, licGetText(Dialog, szLicence));

                                GetPrivateProfileString('LAVAC64', 'LINE_1', '', szLine, SizeOf(szLine), gszIni);
                                StrCopy(szLicence, szLine);
                                StrCat(szLicence, #13+ #10);
                                GetPrivateProfileString('LAVAC64', 'LINE_2', '', szLine, SizeOf(szLine), gszIni);
                                StrCat(szLicence, szLine);
                                StrCat(szLicence, #13+ #10);
                                GetPrivateProfileString('LAVAC64', 'LINE_3', '', szLine, SizeOf(szLine), gszIni);
                                StrCat(szLicence, szLine);
                                StrCat(szLicence, #13+ #10);
				SetDlgItemText(Dialog, 10000, szLicence);
				//SetDlgItemText(Dialog, 10000, licGetText(Dialog, szLicence));

                                                                hBmp := LoadImage(0, 'C:\LAVAC\ico\LAVAC64.ico', IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                                                SendDlgItemMessage( Dialog, 1000, BM_SETIMAGE, IMAGE_ICON, hBmp );
                                                                //hBmp := LoadImage(0, 'C:\LAVAC\ico\LAVAC64.bmp', IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
                                                                //SendDlgItemMessage( Dialog, 1000, BM_SETIMAGE, IMAGE_BITMAP, hBmp );
                                                                DeleteObject(hBmp);

			end;

		wm_paint :
			begin

				//BeginPaint(Dialog,PS);
				//AfficheBitmapIn(GetDlgItem(Dialog,103),2,8, hDIB2, pDIB2, pBits2, Palette2, FALSE, FALSE);
				//EndPaint(Dialog,PS);
			end;

		wm_Command: begin
			case LoWord(wParam) of
				idb_quit, IDCANCEL:
					begin
						{sauvegarde}
						if (IsDlgButtonChecked(Dialog,109)=1) AND (wParam <> IDCANCEL) then begin
							CheckDlgButton(Dialog,109,0);
							if Correction then begin
								StrCopy(tEtudiant.Nom, szNomEleve);
								StrCopy(tEtudiant.LessonName, tLecon.Nom);
								BackupReponses(NoElev, tEtudiant, TRUE);
							end else begin
								StrCopy(tEtudiant.Nom, szNomEleve);
								StrCopy(tEtudiant.LessonName, tLecon.Nom);
								BackupReponses(NoElev, tEtudiant, TRUE);
							end;
						end;
						ReleaseBitmapRessource(hDIB2,hPal2);
            EndDialog(Dialog,wParam)
          end;
      end;
    end;
  end;
  AboutEndProc := FALSE;
end;
{**         Fin de la Procédure InitFirstInstance           **}
{*************************************************************}

{QCM}
{*************************************************************}
{**                    Fonction  QcmProc                    **}
{** SE: Gère les messages particuliers de la fenêtre QCM.   **}
{** SI: En fonction des messages envoyés.                   **}
{*************************************************************}
FUNCTION QcmProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): BOOL; stdcall;
VAR
	 AReqQcm	: PReqText;
	 r,
	 rI,
	 rT       : TRECT;
	 pt				: TPOINT;
		szFormat,
		szLink,
		szLine 	: array[0..255]of char;
		pLink		: PChar;

const
	rQcmWin : TRECT = ();

BEGIN

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+18, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

		 QcmProc := TRUE;
		 Case Message Of
{$IFDEF _E0}  { Créateur... }
					WM_SETCURSOR :
						if MainQcmWin^.wMode <> M_MAKE then begin
							if LOWORD(lParam) = HTCAPTION then begin
								SetCursor(LoadCursor(0,IDC_SIZE));
								SetWindowLong(Dialog, DWL_MSGRESULT, MAKELONG(WORD(TRUE), 0));
								exit;
							end;
						end;

					WM_NCHITTEST :
						begin
							if (MainQCMWin^.wMode <> M_MAKE) then begin
								SetWindowLong(Dialog, 0{DWL_MSGRESULT}, ProcessHitTest(Dialog, message, wParam, lParam));
							end else begin
								SetWindowLong(Dialog, 0{DWL_MSGRESULT}, HTCLIENT);
							end;
							exit;
						end;

					WM_MOUSEACTIVATE :
						begin
							CheckRadioButton(hListBar, 1200, 1207, 1204);
							PostMessage(Dialog, WM_USER, 0, 0);
						end;

					UM_SETSTATUSTEXT :
						if (MainQCMWin^.wMode <> M_MAKE) then begin
							GetWindowText(Dialog, szFormat, SizeOf(szFormat));
							pLink := @MainQcmWin^.szFichierQ;
							wvsprintf(szLine, szFormat, pLink);
							SetDlgItemText(hStatusBar, 101, szLine);

							if hOldHandled <> hQCMProc then begin
								if hOldHandled <> 0 then begin
									SetWindowPos(hOldHandled, 0, 0, 0, 0, 0,
															 SWP_DRAWFRAME OR SWP_NOMOVE OR SWP_NOSIZE OR SWP_NOZORDER OR SWP_NOACTIVATE);
									UpdateHandle(hOldHandled);
								end;
								UpdateHandle(hQCMProc);
								hOldHandled := hQCMProc;
							end;

						end;

					WM_PAINT :
						begin
							UpdateWindow(hBoutonsProc);
							UpdateWindow(hLeconProc);
							dc := BeginPaint(Dialog, ps);
							EndPaint(Dialog, ps);
							if (IsDlgButtonChecked(hListBar, 1204) = 1) AND
								 (MainQCMWin^.wMode <> M_MAKE) then begin
								dc := GetWindowDC(Dialog);
								ShowHandle(dc, Dialog);
								ReleaseDC(Dialog, dc);
							end;
						end;
{$ELSE}  { Créateur... }
		WM_PAINT :
			begin
				UpdateWindow(hBoutonsProc);
				UpdateWindow(hLeconProc);
				dc := BeginPaint(Dialog, ps);
				EndPaint(Dialog, ps);
			end;
{$ENDIF}  { Créateur... }

					wm_InitDialog:
						begin
							PostMessage(Dialog, WM_MMPAINT, 0, 0);
						end;

					WM_MMPAINT :
						begin
							GetWindowRect(hGraphiqueProc, rI);
							MapWindowPoints(HWND_DESKTOP, GetParent(Dialog), rI, 2);
							GetWindowRect(hTexteProc, rT);
							MapWindowPoints(HWND_DESKTOP, GetParent(Dialog), rT, 2);
							SetWindowPos(Dialog, 0, rI.left, rI.top, rI.right - rI.left, rT.bottom - rI.top, SWP_NOZORDER OR SWP_NOREDRAW);
							GetWindowRect(Dialog, rQcmWin);
							MapWindowPoints(HWND_DESKTOP, GetParent(Dialog), rQcmWin, 2);
						end;

					WM_WINDOWPOSCHANGING : { TWINDOWPOS }
						begin
							UpdateHandle(Dialog);
							if IsZoomed(Dialog) then begin
								GetWindowRect(GetParent(Dialog), r);
								MapWindowPoints(0, Window, r, 2);
								PWINDOWPOS(lParam)^.x := -GetSystemMetrics(SM_CXDLGFRAME);
								PWINDOWPOS(lParam)^.y := -GetSystemMetrics(SM_CYDLGFRAME);
								PWINDOWPOS(lParam)^.cx := r.right - r.left + 2 * GetSystemMetrics(SM_CXDLGFRAME) - 1;
								PWINDOWPOS(lParam)^.cy := r.bottom - r.top + 2 * GetSystemMetrics(SM_CYDLGFRAME) - 1;
							end;
						end;

						WM_WINDOWPOSCHANGED : { TWINDOWPOS }
							begin
								UpdateHandle(Dialog);
							end;

						WM_MOVE : begin
                                                        {$IFDEF _TUTOR}
							if MainQcmWin^.bSizable  then begin
								GetWindowRect(hQcmProc, r);
								MapWindowPoints(0, GetParent(hQcmProc), r, 2);
								LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@SetTutorPos), 0, longint(@r));
							end;
                                                        {$ENDIF}
						end;

					WM_SIZE :
						begin
                                                        {$IFDEF _TUTOR}
							SendMessage (lpQcmMkWin^.HWindow, WM_SIZE, wParam, lParam);
                                                        {$ENDIF}
							{ -- sauver la nouvelle position -- }
							PostMessage(Dialog, WM_MOVE, 0, 0);
						End;

					WM_GETMINMAXINFO :
						Begin
							PMinMaxInfo(lParam)^.ptMinTrackSize.X := 0;
							PMinMaxInfo(lParam)^.ptMinTrackSize.Y := 0;
						End;

					UM_PLAYQCM :
						Begin
							AReqQcm := PReqText (lParam);
							With AReqQcm^.Rect Do MoveWindow (Dialog, Left, Top, Right, Bottom, TRUE);
                                                        {$IFDEF _TUTOR}
							SendMessage (MainQcmWin^.HWindow, UM_PLAYQCM, wParam, lParam);
                                                        {$ENDIF}
						End;

					UM_ADDSEL :
						Begin
                                                        {$IFDEF _TUTOR}
							SendMessage (MainQcmWin^.HWindow, UM_ADDSEL, wParam, lParam);
                                                        {$ENDIF}
						End;

					UM_APPEL :
						Begin
                                                        {$IFDEF _TUTOR}
							MainQcmWin^.AppelLecon;
                                                        {$ENDIF}
						End;

					UM_INITPOS :
						begin
							SetWindowPos(Dialog, 0, rQcmWin.left, rQcmWin.top, rQcmWin.right - rQcmWin.left, rQcmWin.bottom - rQcmWin.top,
													 SWP_NOZORDER);
						end;

					UM_FULLPOS :
						begin
							GetClientRect(Window, r);
							SetWindowPos(Dialog, 0, 0, 0, r.right - r.left, r.bottom - r.top, SWP_NOZORDER);
						end;

		 End;
		 QcmProc := FALSE; {DefWindowProc(Dialog, Message, WParam, LParam);}
END;

function mdiSendMessage(hwndMdi, hwin : HWND;  msg, wParam : WORD; lParam : longint) : longint;
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+19, 0, 0, 0, nil, TRUE);
	{$ENDIF}

		if hwin = HWND(-1) then	begin
			hwin := GetWindow(hwndMdi, GW_CHILD);
			while hwin <> 0 do begin
				SendMessage(hwin, msg, wParam, lParam);
				hwin := GetWindow(hwin, GW_HWNDNEXT);
			end;
			mdiSendMessage := 0;
			Exit;
		end else begin
				if hwin = 0 then begin
					if IsWindowVisible(hQcmProc) then begin
						hwin := hGraphiqueProc;
					end else begin
                                                {$IFDEF _TUTOR}
						if MainQcmWin <> nil then begin
							hwin := MainQcmWin^.HWindow;
						end else begin
							hwin := 0;
						end;
                                                {$ELSE}
						hwin := 0;
                                                {$ENDIF}
					end;
				end;
				if hwin <> 0 then mdiSendMessage := SendMessage(hwin, msg, wParam, lParam);
		end;
end;

procedure AppExit; Far;
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+20, 0, 0, 0, nil, TRUE);
	{$ENDIF}

				{-- Stop Diadir nBios --}
{$IFNDEF _E0}  { Pas Créateur... }
				if bNetBios then FinEtudiant;
{$ENDIF}  { Pas Créateur... }

				{-- Détruit les objets --}
				DeleteObject(hDiagram);
				DeleteObject(hFond);

				{-- Détruit les fenêtres et les dialogues --}
				DestroyWindow(hSonProc);
				//FreeProcInstance(lpSonProc);
				DestroyWindow(hMciQueueProc);
				//FreeProcInstance(lpMciQueueProc);
				MMLavacDone;
				DestroyWindow(hTexteProc);
				//FreeProcInstance(lpTexteProc);
				hTextePRoc := 0;
				DestroyWindow(hGraphiqueProc);
				//FreeProcInstance(lpGraphiqueProc);
				DestroyWindow(hLeconProc);
				//FreeProcInstance(lpLeconProc);
				DestroyWindow(hBoutonsProc);
				//FreeProcInstance(lpBoutonsProc);

				{QCM}
                                {$IFDEF _TUTOR}
				Dispose (lpQcmMkWin, done);
                                {$ENDIF}
				DestroyWindow (hQcmProc);
				//FreeProcInstance (lpQcmProc);
                                {$IFDEF _TUTOR}
				FreeOleClientInstances; { Structures ole client}
				QcmAppli.Done;
				MainQcmWin := nil;
                                {$ENDIF}

				{-- Détruit les icônes --}
				DestroyIcon(hLed_J);
				DestroyIcon(hLed_N);
				DestroyIcon(hLed_R);
				DestroyIcon(hLed_V);

				{-- Détruit les timers --}
				KillTimer(window,timer_Heure);
				KillTimer(window,timer_Messages);

				DestroyWindow(Window);

{$IFDEF _E0} { Créateur...}
				if lpToolBarIF <> nil then lpToolBarIF^.free;
				lpToolBarIF := nil;
				DestroyWindow(hToolBar);
				FreeProcInstance(lpToolBarProc);

				DestroyWindow(hStatusBar);
				FreeProcInstance(lpStatusBarProc);

				DestroyWindow(hListBar);
				FreeProcInstance(lpListBarProc);

				DestroyWindow(hFrame);
				DestroyWindow(hApp);

{$ENDIF} { Créateur...}

				//DoneWinCrt;
end;

{*************************************************************}
{**                    Fonction  WindowProc                 **}
{** SE: Gère l'application dans la fenêtre principale.      **}
{** SI: En fonction des messages envoyés.                   **}
{*************************************************************}
function WindowProc(Window: HWnd; Message, WParam: DWord;
	LParam: Longint): Longint; stdcall;

{--------------------------------------------------------------------------------------}
var f : file of integer;
		nFin : integer;
		MciCommandStr		: TMCISTR;
		ps : TPAINTSTRUCT;
		dc : HDC;
		r  : TRECT;
		x,y : integer;
		iMax,
		iMin,
		iPos,
		dn							: integer;
		hWin						: HWND;
		rcParent,
		rc			: TRECT;
		nBorderx,
		nBordery : integer;
		nPaperw : integer;
		nPaperh : integer;
		nMargl : integer;
		nMargr : integer;
		nMargt : integer;
		nMargb : integer;
		szLecon1,
		szLecon2 : szLongName;
		MSG		 	 : TMSG;

const pListSel : PINTARRAY = nil;
			nSel 		 : integer = -1;

{--------------------------------------------------------------------------------------}
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+21, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	WindowProc := 0;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

        case Message of

		WM_PALETTECHANGED :
			begin
				{writeln('WndProc : PAL Changed');}
                                {$IFDEF _TUTOR}
				if MainQcmWin <> nil then SendMessage(MainQcmWin^.HWindow, message, wParam, lParam);
                                {$ENDIF}
				SendMessage(hGraphiqueProc, message, wParam, lParam);
				exit;
			end;

		WM_QUERYNEWPALETTE :
			begin
				{writeln('WndProc : PAL New');}
				WindowProc := mdiSendMessage(0, 0, message, wParam, lParam);
				exit;
			end;

		WM_VSCROLL:
			if Window = FrameWin then begin
					GetScrollRange(Window,SB_VERT,iMin,iMax);
					iPos := GetScrollPos(Window,SB_VERT);
					GetClientRect(Window,r);

					case wParam of
							 SB_LINEDOWN:      dn :=  r.bottom DIV 64 + 1;
							 SB_LINEUP:        dn := -r.bottom DIV 64 + 1;
							 SB_PAGEDOWN:      dn :=  r.bottom DIV 2  + 1;
							 SB_PAGEUP:        dn := -r.bottom DIV 2  + 1;
							 SB_THUMBTRACK,
							 SB_THUMBPOSITION: dn := LOWORD(lParam)-iPos;
					else                   dn := 0;
					end;

					dn := BOUND(iPos+dn,iMin,iMax) - iPos;
					if (dn <> 0) then	begin
							ScrollWindow(Window,0,-dn,nil,nil);
							SetScrollPos(Window,SB_VERT,iPos + dn, TRUE);
							PostMessage(Window, WM_NCPAINT, 0, 0);
							PostMessage(Window, WM_PAINT, 0, 0);
							{UpdateWindow(di.hwin);}
					end;
					exit;
			 end;

		 WM_HSCROLL:
			 if Window = FrameWin then begin
					GetScrollRange(Window,SB_HORZ,iMin,iMax);
					iPos := GetScrollPos(Window,SB_HORZ);
					GetClientRect(Window,r);

					case (wParam) of
							 SB_LINEDOWN:      dn :=  r.right DIV 64 + 1;
							 SB_LINEUP:        dn := -r.right DIV 64 + 1;
							 SB_PAGEDOWN:      dn :=  r.right DIV 2  + 1;
							 SB_PAGEUP:        dn := -r.right DIV 2  + 1;
							 SB_THUMBTRACK,
							 SB_THUMBPOSITION: dn := LOWORD(lParam)-iPos;
					else				           dn := 0;
					end;
					{dn := ALIGNB(dn);}
					dn := BOUND(iPos+dn,iMin,iMax) - iPos;
					if (dn <> 0) then	begin
							ScrollWindow(Window,-dn,0,nil,nil);
							SetScrollPos(Window,SB_HORZ,iPos + dn, TRUE);
							PostMessage(Window, WM_NCPAINT, 0, 0);
							PostMessage(Window, WM_PAINT, 0, 0);
							{UpdateWindow(di.hw in);}
					end;
					exit;
			 end;

		WM_PAINT :
			if Window = FrameWin then begin
				dc := BeginPaint(Window, ps);
				SetWindowOrgEx(dc, GetScrollPos(Window, SB_HORZ), GetScrollPos(Window, SB_VERT), nil);
				EndPaint(Window, ps);
			end;

		WM_USER + 1000 :
			begin
			{$IFDEF _E0}  { Créateur... }
				{ On sauvegarde ou pas les déplacements des fenêtres élèves }
				MainQcmWin^.bSizable := BOOL(wParam);
				hWin := GetWindow(hToolBar, GW_CHILD);
				while hWin <> 0 do begin
					EnableWindow(hWin, BOOL(wParam));
					hWin := GetWindow(hWin, GW_HWNDNEXT);
				end;
				hWin := GetWindow(hListBar, GW_CHILD);
				while hWin <> 0 do begin
					EnableWindow(hWin, BOOL(wParam));
					hWin := GetWindow(hWin, GW_HWNDNEXT);
				end;
				InvalidateRect(GetDlgItem(hListBar, 1000), nil, TRUE);
				hWin := GetWindow(hStatusBar, GW_CHILD);
				while hWin <> 0 do begin
					EnableWindow(hWin, BOOL(wParam));
					hWin := GetWindow(hWin, GW_HWNDNEXT);
				end;
			{$ELSE}
				EnableWindow(GetDlgItem(hLeconProc, idl_Lecon), BOOL(wParam));
			{$ENDIF}

				{ si stoppe purge lpSelection du branchement en cours }
				if BOOL(wParam) then begin
                                        {$IFDEF _TUTOR}
					SendMessage (MainQcmWin^.HWindow, UM_ResetSel, 0, 0);
                                        {$ENDIF}
				end;

			end;

		WM_USER + 1001 :
			begin

				if StrPos(StrUpper(szTextDefExt), 'RTF') <> nil then begin
					{####}
					{ Affiche la fenêtre texte à la taille du document }
					{RtfGetPageInfo(PropositionName, nPaperw, nPaperh, nMargl, nMargr, nMargt, nMargb);
					GetRealClientRect(GetDlgItem(hTexteProc, 101), rc);
					InflateRect(rc, 1, 1);
					GetWindowRect(hTexteProc, rcParent);
					MapWindowPoints(HWND_DESKTOP, hTexteProc, rcParent, 2);
					nBorderx := rcParent.right - rc.right;
					nBordery := rcParent.bottom - rc.bottom;
					rc.right := TwipsToPixels(nPaperw, 0);
					rc.bottom := TwipsToPixels(nPaperh, 1);
					WriteLn('Get in RTF ', nPaperw, ' ', nPaperh);
					WriteLn('1 pixel = ', PixelsToTwips(1, 0), ' x ', PixelsToTwips(1, 1), ' twips');
					WriteLn('1 twips = ', TwipsToPixels(1, 0), ' x ', TwipsToPixels(1, 1), ' pixel');
					WriteLn('567 TwipsToPixelsToTwips = ', TwipsToPixels(PixelsToTwips(567, 0), 0));
					WriteLn('567 PixelsToTwipsToPixels = ', PixelsToTwips(TwipsToPixels(567, 0), 0));

					SetWindowPos(hTexteProc, 0, 0, 0, rc.right + nBorderx, rc.bottom + nBordery,
											 SWP_NOZORDER OR SWP_NOMOVE);}
				end;

				if NOT FileExist(PropositionName) then begin
					Assign(f, PChar(PropositionName));
					{$I-}
					rewrite(f);
					close(f);
					{$I+}
					InOutRes := 0;
				end;
				Assign(f, PChar(PropositionName));
				GetFattr(f, wReturn);
				SetFattr(f, wReturn OR faShare);
				SetDlgItemText(hTexteProc, 102, PropositionName);
				ReadTextFile(PropositionName);
			end;

		{-- Début dAppel du prof --}
		 UM_DDREQCHAT :
			begin
				StopScript;
				sndPlaySoundResource('SONNERIE');
				CenterDialog(wParam);
				{#### GDB 4/12/96 Disable student window during direct dialog }
				SendMessage(wParam, UM_DDACKCHAT, 0, 0);
				EnableWindow(window, FALSE);
				KillTimer(window,timer_Heure);
				KillTimer(window,timer_Messages);
                                {$IFDEF _TUTOR}
				KillTimer(MainQcmWin^.HWindow, ID_TIMER);
                                {$ENDIF}
			end;

		{-- Fin Appel du prof --}
		 UM_DDENDCHAT :
			begin
				{MessageBox(0,'DDENDCHAT','',0);}
				sndPlaySoundResource('TONALITE');
				EnableWindow(window, TRUE);
				ShowWindow(wParam, SW_HIDE );
				SetTimer(window,timer_Heure,duree_timer_heure,nil);
				SetTimer(window,timer_Messages,duree_timer_Messages,nil);
                                {$IFDEF _TUTOR}
				SetTimer(MainQcmWin^.HWindow, ID_TIMER, 1000, nil);
                                {$ENDIF}
			end;

		WM_LBUTTONDOWN :
			begin
				{$IFDEF _E0}
				if SendDlgItemMessage(hListBar, idl_Lecon, CB_GETDROPPEDSTATE, WORD(0), DWORD(0)) <> 0 then begin
					SendDlgItemMessage(hListBar, idl_Lecon, CB_SHOWDROPDOWN, WORD(FALSE), DWORD(0));
					SendMessage(hListBar, WM_COMMAND, idl_Lecon,
											 MakeLong(GetDlgItem(hListBar, idl_Lecon), CBN_SELCHANGE));
				end;
				{$ELSE}
				if SendDlgItemMessage(hLeconProc, idl_Lecon, CB_GETDROPPEDSTATE, WORD(0), DWORD(0)) <> 0 then begin
					SendDlgItemMessage(hLeconProc, idl_Lecon, CB_SHOWDROPDOWN, WORD(FALSE), DWORD(0));
					SendMessage(hLeconProc, WM_COMMAND, idl_Lecon,
											 MakeLong(GetDlgItem(hLeconProc, idl_Lecon), CBN_SELCHANGE));
				end;
				{$ENDIF}
			end;

		{-- Gestion des messages command --}
		WM_COMMAND:
			case LoWord(wParam) of
				{Fichier/Quitter}
				101 : PostMessage(hToolBar, WM_COMMAND, 6000, 0);
				{Options/Grille Tuteur}
				102 :
					begin
                                                {$IFDEF _TUTOR}
						MainQcmWin^.bGrid := NOT MainQcmWin^.bGrid;
						if MainQcmWin^.bGrid then begin
							CheckMenuItem(GetMenu(window), wParam, MF_CHECKED);
						end else begin
							CheckMenuItem(GetMenu(window), wParam, MF_UNCHECKED);
						end;
                                                {$ELSE}
						CheckMenuItem(GetMenu(window), wParam, MF_UNCHECKED);
                                                {$ENDIF}
					end;
			end;

		{-- Gestion du Timer Prof / Elève --}
		WM_TIMER:
			begin
				case wParam of
					{-- Gestion du temps --}
					timer_heure:
						begin
							SetDlgItemText(hLeconProc,5000,SystemTime);
							PostMessage(hMessagesProc, Message, WParam, LParam);
						end;

					{-- Gestion du message --}
					timer_Messages + 1 :   // HACK
						if Not Correction then begin
							MessageSelFileName(MessageName, NoElev);
							if FileExist(MessageName) then begin
								StopScript;
								MessageBeep(MB_ICONEXCLAMATION);
								NoLecon := 0;
								QDebut := 0;
								QFin := 0;
								nMode := 0;
								{$i-}
								Assign(f, PChar(MessageName));
								FileMode := OF_SHARE_DENY_NONE OR  0;
								reset(f);
								read(f,NoLecon);
								read(f,QDebut);
								read(f,Qfin);
								read(f,nMode);
								Close(f);
								FileMode := OF_SHARE_DENY_NONE OR  2;
								{$i+}
								InOutRes := 0;
								{#### Attention à ce que le suivi envoie ... }
								SendDlgItemMessage(hLeconProc, idl_Lecon, CB_SETCURSEL, NoLecon - 1, 0);
								bItsACall := TRUE;
								SendMessage(hLeconProc,WM_COMMAND,idl_Lecon,MakeLong(0, CBN_SELCHANGE));
								bItsACall := FALSE;
								SendDlgItemMessage(hLeconProc,idl_ListeQ,LB_SELITEMRANGE,1,MakeLong(QDebut-1,QFin-1));
								{$i-}
								DeleteFile(MessageName);
								{$i+}
                InOutRes := 0;
								MessageBox(hGraphiqueProc, mmLoadString(hInstRes, STR_MSGSEL), mmLoadString(hInstRes, STR_MSG),
                  MB_OK+MB_ICONEXCLAMATION);
								case nMode of
                  1 : {} ;
									2 : PostMessage(hBoutonsProc,WM_COMMAND,idb_PlayQ,MakeLong(0,0));
                  3 : PostMessage(hBoutonsProc,WM_COMMAND,idb_RecordR,MakeLong(0,0));
                  4 : {} ;
                end;
              end;
							MessageBmpFileName(MessageName,NoElev);
							if FileExist(MessageName) then begin
								StopScript;
								MessageBeep(MB_ICONEXCLAMATION);
								StrCopy(MciCommandStr, 'DISPLAY ');
								StrCat(MciCommandStr,  StrUpper(MessageName));
								ProcessOptionsBitmap(tQuestion, MciCommandStr);
								mciDisplay(MciCommandStr);
								{$i-}
								DeleteFile(MessageName);
                {$i+}
                InOutRes := 0;
								ShowWindow(hGraphiqueProc, SW_SHOW);
								MessageBox(hGraphiqueProc, mmLoadString(hInstRes, STR_MSGBMP),
											mmLoadString(hInstRes, STR_MSG),MB_OK+MB_ICONEXCLAMATION);
              end;
              MessageTxtFileName(MessageName,NoElev);
							if NOT FileExist(MessageName) then begin
								MessageRtfFileName(MessageName,NoElev);
							end;
							if FileExist(MessageName) then begin
								StopScript;
								MessageBeep(MB_ICONEXCLAMATION);
                if NOT IsWindowVisible(hTexteProc) then
                   ShowWindow(hTexteProc, SW_SHOW);
                ReadTextFile(MessageName);
                {$i-}
								DeleteFile(MessageName);
                {$i+}
								InOutRes := 0;
								MessageBox(hTexteProc, mmLoadString(hInstRes, STR_MSGTXT),
										mmLoadString(hInstRes, STR_MSG),MB_OK+MB_ICONEXCLAMATION);
							end;
							MessageWavFileName(MessageName, NoElev);
							if NOT PlayingMessage then
							if FileExist(MessageName) then begin
								PlayingMessage := TRUE;
								StopScript;
								sndPlaySound('SystemExclamation', SND_SYNC);
								AfficheLed(hLed_N);

								hWin := MciWndCreate(window,
								        hInstance,
									WS_CHILD OR WS_OVERLAPPED OR
									WS_CAPTION OR WS_THICKFRAME OR WS_SYSMENU OR
									MCIWNDF_NOERRORDLG OR
									MCIWNDF_NOMENU,
                                                                        MessageName);

								{SetWindowText(hWin, mmLoadString(hInstRes, STR_MSGWAV));
								SetWindowPos(hWin, 0, 0, 0, 340, 0, SWP_NOZORDER);
								CenterDialog(hWin);
								FlashWindow(hWin, TRUE);
								BringWindowToTop(hWin);
								ShowWindow(hWin, SW_SHOW);

								SendMessage(hWin, MCI_PLAY, 0, 0);

								While IsWindow(hWin) do begin
									while PeekMessage(MSG, 0, 0, 0,PM_REMOVE) do begin
										TranslateMessage(MSG);
										DispatchMessage(MSG);
									end;
								end;}

								{sndPlaySound(, SND_ASYNC);}
								SendMessage(hWin, MCI_PLAY, 0, 0);
								While MessageBox(hTexteProc, mmLoadString(hInstRes, STR_MSGWAV),
											mmLoadString(hInstRes, STR_MSG),
											MB_RETRYCANCEL+MB_ICONEXCLAMATION) <> IDCANCEL do begin
									SendMessage(hWin, MCI_PLAY, 0, 0);
									{sndPlaySound(MessageName, SND_ASYNC);}
								end;

								DestroyWindow(hWin);

								sndPlaySound('SystemExclamation',SND_SYNC);
								AfficheLed(hLed_N);
								{$i-}
								DeleteFile(MessageName);
								{$i+}
                InOutRes := 0;
                PlayingMessage := FALSE;
              end;
						end;
        end;
			end;

		WM_CLOSE:
			begin

				{ShowWindow(hSonProc, SW_HIDE);}
				ShowWindow(hTexteProc, SW_HIDE);
				ShowWindow(hGraphiqueProc, SW_HIDE);
				ShowWindow(hLeconProc, SW_HIDE);
				ShowWindow(hBoutonsProc, SW_HIDE);
				ShowWindow(hQcmProc, SW_HIDE);
				{-- Crée la boite de dialogue finale --}
				//lpMessagesProc := MakeProcInstance(@AboutEndProc, HInstance);
				lpMessagesProc := @AboutEndProc;
				nFin := DialogBox(hInstRes, 'ABOUTEND_EL', Window, DLGPROC(lpMessagesProc));
				//FreeProcInstance(lpMessagesProc);

				if nFin = IDCANCEL then begin
					{ShowWindow(hSonProc, SW_SHOW);}
					ShowWindow(hTexteProc, SW_SHOW);
					ShowWindow(hGraphiqueProc, SW_SHOW);
					ShowWindow(hLeconProc, SW_SHOW);
					ShowWindow(hBoutonsProc, SW_SHOW);
					Exit;
				end;

				{On Stoppe la video en cours }
				StrCopy(MciCommandStr, 'STOP VIDEO WAIT');
				mciSendString(MciCommandStr,nil,0,0);
				StrCopy(MciCommandStr, 'CLOSE VIDEO WAIT');
				mciSendString(MciCommandStr,nil,0,0);

				if bVideoWave then begin
					StrCopy(MciCommandStr, 'STOP SON WAIT');
					mciSendString(MciCommandStr,nil,0,0);
					StrCopy(MciCommandStr, 'CLOSE SON WAIT');
					mciSendString(MciCommandStr,nil,0,0);
				end;

				//###
                                //DelAllReponseFile(NoElev);

				{-- Repositionne les variables globales --}
				StrCopy(tEtudiant.Nom, '');
				tEtudiant.Position := 0;
				tEtudiant.Appel := False;
				StrCopy(tEtudiant.LessonName, 'None');
				tEtudiant.LeconEnCours := -1;
				tEtudiant.QuestionEnCours := -1;
				tEtudiant.ReponseEnCours := -1;
				tEtudiant.Score     := 0;
				tEtudiant.MaxPoints := 0;
				tEtudiant.MinPoints := 0;
				SetEtudiantRec(NoElev, tEtudiant);

				AppExit;

			end;

{$IFDEF _E0} { Créateur...}
		{WM_ERASEBKGND :
			begin
				WindowProc := DefWindowProc(Window, Message, WParam, LParam);
				dc := HDC(wParam);
				GetWindowRect(Window, r);
				MapWindowPoints(0, Window, r, 2);
				y := r.top;
				while y <= r.bottom do begin
					x := r.left;
					while x <= r.right do begin
						MoveTo(dc, x, y);
						LineTo(dc, x + 1, y + 1);
						inc(x, PAS_GRILLE);
					end;
					inc(y, PAS_GRILLE);
				end;
				Exit;
			end;         }
{$ENDIF} { Créateur...}

		WM_DESTROY:
			begin
				{-- Quitte l'application --}
				if hRichedLib <> 0 then begin
					FreeLibrary(hRichedLib);
					hRichedLib := 0;
				end;
				PostQuitMessage(0);
				Exit;
			end;

		{Lorsque la fenêtre de l'application reprend le focus => bascule depuis un des }
		{modules de saisie (PaintBrush, NotePad, VidCap, ...). }
		WM_SETFOCUS:
			begin

				{WindowProc := DefWindowProc(Window, Message, WParam, LParam);
				exit;}

				{On était sous PaintBrush}
				if ItWasBitmap then begin
					wReturn := SetActiveWindow(hWndPBrush);
					PostMessage(hWndPBrush, WM_CLOSE, WORD(0), MakeLong(WORD(0),WORD(0)));
					if wReturn = 0 then begin
						Assign(f,PChar(PropositionName));
						GetFattr(f,wReturn);
						SetFattr(f,wReturn OR faShare);
						StrCopy(MciCommandStr, 'DISPLAY ');
						StrCat(MciCommandStr,  StrUpper(PropositionName));
						ProcessOptionsBitmap(tQuestion, MciCommandStr);
						mciDisplay(MciCommandStr);
						ItWasBitmap := FALSE;
					end;
				end;

				{On était sous VidCap}
				if ItWasVideo then begin
					wReturn := SetActiveWindow(hWndVidCap);
					PostMessage(hWndVidCap, WM_CLOSE, WORD(0), MakeLong(WORD(0),WORD(0)));
					{Si la fenêtre est déjà fermée on envoie le nom }
					{du fichier créé dans la zone prévue à cet effet}
					if wReturn = 0 then begin
						Assign(f,PChar(PropositionName));
						GetFattr(f,wReturn);
						SetFattr(f,wReturn OR faShare);

						{On Stoppe la video en cours
						StrCopy(MciCommandStr, 'STOP VIDEO WAIT');
						mciSendString(MciCommandStr,nil,0,0);
						StrCopy(MciCommandStr, 'CLOSE VIDEO WAIT');
						mciSendString(MciCommandStr,nil,0,0);

						if bVideoWave then begin
							StrCopy(MciCommandStr, 'STOP SON WAIT');
							mciSendString(MciCommandStr,nil,0,0);
							StrCopy(MciCommandStr, 'CLOSE SON WAIT');
							mciSendString(MciCommandStr,nil,0,0);
						end;

						StrCopy(MciCommandStr, 'DISPLAY ');
						StrCat(MciCommandStr,  StrUpper(PropositionName));
						ProcessOptionsBitmap(tQuestion, MciCommandStr);
						mciDisplay(MciCommandStr);}

						ItWasVideo := FALSE;
						{if StrComp(PropositionName, '') <> 0 then begin
							SetDlgItemText(HGraphiqueProc, 102, PropositionName);
							PostMessage(hToolBar, WM_COMMAND, 6019, 0);
						end;}
					end;
				end;

				{On était sous NotePad}
				if ItWasTexte then begin
					wReturn := SetActiveWindow(hWndNotePad);
					PostMessage(hWndNotePad, WM_CLOSE, WORD(0), MakeLong(WORD(0), WORD(0)));
					{#### hWndNotePad := 0;  à tester car jamais mis à zéro comme ces copains dailleurs }
					if wReturn = 0 then begin
						ItWasTexte := FALSE;
						ClosePosted := FALSE;
						PostMessage(Window, WM_USER + 1001, 0, 0);
					end;
				end;

				{On était sous SoundRec}
        if ItWasSon then begin
					wReturn := SetActiveWindow(hWndSoundRec);
					PostMessage(hWndSoundRec,WM_CLOSE,WORD(0),MakeLong(WORD(0),WORD(0)));
          if wReturn = 0 then begin
            Assign(f,PChar(PropositionName));
	    GetFattr(f,wReturn);
            SetFattr(f,wReturn OR faShare);
	    SetDlgItemText(HSonProc,102,PropositionName);
            ItWasSon := FALSE;
          end;
        end;
			end;

		{WM_INPUTLANGCHANGEREQUEST} $0050:
			begin
			end;

		{WM_INPUTLANGCHANGE} $0051 :
			begin
				GetCurCharset := BYTE(wParam);
			end;

		UM_NEXTQCMCREATE :
			if BOOL(wParam) then begin
				{ Mode creation tuteur }
				if pListSel = nil then begin
					pListSel := LBGetMultiSelList(hListBar, idl_ListeQ);
					nSel := LBGetListFirstSel(pListSel);
					ShowWindow(hQcmProc, SW_SHOWMAXIMIZED);
                                        {$IFDEF _TUTOR}
					CreerQcm(PropositionName, BOOL(wParam));
  					lParam := longint(@MainQcmWin^.szFichierQ);
                                        {$ENDIF}
					if NOT LinkTutor(hListBar, idl_ListeQ, nSel, LongInt(hQCMProc), lParam) then begin
						while LBGetListNextSel(pListSel) <> -1 do;
					end;
				end else begin
					nSel := LBGetListNextSel(pListSel);
					if nSel <> -1 then begin
						ShowWindow(hQcmProc, SW_SHOWMAXIMIZED);
                                                {$IFDEF _TUTOR}
						CreerQcm(PropositionName, BOOL(wParam));
						lParam := longint(@MainQcmWin^.szFichierQ);
                                                {$ENDIF}
                                                if NOT LinkTutor(hListBar, idl_ListeQ, nSel, LongInt(hQCMProc), lParam) then begin
							while LBGetListNextSel(pListSel) <> -1 do;
						end;
					end else begin
						LBFreeMultiSelList(pListSel);
						pListSel := nil;
						nSel := -1;
					end;
				end;
			end else begin
				{ Mode modification tuteur }
				if pListSel = nil then begin
					pListSel := LBGetMultiSelList(hListBar, idl_ListeQ);
					nSel := LBGetListFirstSel(pListSel);
					GetQuestionRec(nSel + 1, tQuestion);
					if tQuestion.FichierQCM[0] <> #0 then begin
                                                {$IFDEF _TUTOR}
						StrCopy(MainQcmWin^.szFichierQ, tQuestion.FichierQCM);
						SendMessage(MainQcmWin^.HWindow, UM_LOADQCM, 0, 0);
                                                {$ENDIF}
						ShowWindow(hQcmProc, SW_SHOWMAXIMIZED);
                                                {$IFDEF _TUTOR}
						CreerQcm(PropositionName, BOOL(wParam));
                                                {$ENDIF}
					end;
				end else begin
					nSel := LBGetListNextSel(pListSel);
					if nSel <> -1 then begin
						GetQuestionRec(nSel + 1, tQuestion);
						if tQuestion.FichierQCM[0] <> #0 then begin
                                                        {$IFDEF _TUTOR}
							StrCopy(MainQcmWin^.szFichierQ, tQuestion.FichierQCM);
							SendMessage(MainQcmWin^.HWindow, UM_LOADQCM, 0, 0);
                                                        {$ENDIF}
							ShowWindow(hQcmProc, SW_SHOWMAXIMIZED);
                                                        {$IFDEF _TUTOR}
							CreerQcm(PropositionName, BOOL(wParam));
                                                        {$ENDIF}
						end;
					end else begin
						LBFreeMultiSelList(pListSel);
						pListSel := nil;
						nSel := -1;
					end;
				end;
			end;

		wm_Activate:
			begin

				{WindowProc := DefWindowProc(Window, Message, WParam, LParam);
				exit;}

				if (wParam = WA_ACTIVE) then
					if (LoWord(lParam) <> 0) then begin
            if (LoWord(lParam) = hWndNotePad)  then begin
							PostMessage(Window,WM_SETFOCUS,WORD(0),MakeLong(WORD(0),WORD(0)));
            end;
						if (LoWord(lParam) = hWndSoundRec) then begin
							PostMessage(Window,WM_SETFOCUS,WORD(0),MakeLong(WORD(0),WORD(0)));
            end;
            if (LoWord(lParam) = hWndVidCap) then begin
							PostMessage(Window,WM_SETFOCUS,WORD(0),MakeLong(WORD(0),WORD(0)));
            end;
            if (LoWord(lParam) = hWndPBrush) then begin
							PostMessage(Window,WM_SETFOCUS,WORD(0),MakeLong(WORD(0),WORD(0)));
            end;
					end;
			 end;

	end;
	WindowProc := DefWindowProc(Window, Message, WParam, LParam);
end;
{**         Fin de la Procédure WindowProc                  **}
{*************************************************************}

function mciLoadTableResource(hDlg : HWND; nItem : integer) : BOOL;
const
	MCI_COMMAND_HEAD			= 0;
	MCI_STRING            = 1;
	MCI_END_COMMAND       = 2;
	MCI_INTEGER           = 3;
	MCI_RETURN       			= 4;
	MCI_FLAG              = 5;
	MCI_END_COMMAND_LIST  = 6;
	MCI_RECT              = 7;
	MCI_CONSTANT          = 8;
	MCI_END_CONSTANT      = 9;

var	hResInfo,
		hInst,
		hResData : THANDLE;
		dwResSize,
		dwOffs : DWORD;
		lpCur,
		lpNext,
		lpResData : Pointer;
		szBuf : Array[0..32] of char;

begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+22, 0, 0, 0, nil, TRUE);
	{$ENDIF}

	hInst := LoadLibrary('MCIAVI.DRV');
	hResInfo := FindResource(hInst, 'MCIAVI', RT_RCDATA);
	if hResInfo = 0 then begin
		MessageBeep(WORD(-1));
		FreeLibrary(hInst);
		exit;
	end;
	hResData := LoadResource(hInst, hResInfo);
	if hResData = 0 then begin
		MessageBeep(WORD(-1));
		FreeLibrary(hInst);
		exit;
	end;
	dwResSize := SizeofResource(hInst, hResInfo);
	lpResData := LockResource(hResData);
	lpCur := lpResData;
	dwOffs := StrLen(lpCur) + 1 +  SizeOf(DWORD);
	//lpNext := Ptr(PtrRec(lpResData).Hi + PtrRec(dwOffs).Hi * Ofs(AHIncr),
	lpNext := lpResData + dwOffs;
	While (dwOffs < dwResSize) AND
				(WORD(lpNext^) <> MCI_END_COMMAND_LIST) do begin
		StrPCopy(szBuf, IntToStr(WORD(lpNext^)));
		StrCat(szBuf, ':');
		StrCat(szBuf, lpCur);
		SendDlgItemMessage(hDlg, 120, CB_ADDSTRING, 0,  LongInt(@szBuf));
		if WORD(lpNext^) = MCI_COMMAND_HEAD then begin
			if BYTE(lpCur^) <> 0 then begin
				SendDlgItemMessage(hDlg, nItem, CB_ADDSTRING, 0,  LongInt(lpCur));
			end else begin
			end;
		end;
		inc(dwOffs, SizeOf(WORD));  // ??? SizeOf(DWORD) in 32-bits ???
		//lpCur := Ptr(PtrRec(lpResData).Hi + PtrRec(dwOffs).Hi * Ofs(AHIncr), PtrRec(dwOffs).Lo);
		lpCur := lpResData + dwOffs;

		inc(dwOffs, StrLen(lpCur) + 1 +  SizeOf(DWORD));
		//lpNext := Ptr(PtrRec(lpResData).Hi + PtrRec(dwOffs).Hi * Ofs(AHIncr), PtrRec(dwOffs).Lo);
		lpNext := lpResData + dwOffs;
	end;
	UnlockResource(hResData);
	FreeResource(hResData);
	FreeLibrary(hInst);
end;


{*************************************************************}
{                  fonction QuestionPropProc                       }
{ SE:                                                         }
{ SI:                                                         }
{*************************************************************}
function QuestionPropProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var rWin,
		rc,
		Rect : TRECT;
		gOptions,
		tOptions : byte;
		hWin : HWND;
		bSign : BOOL;
		szCaption : Array[0..255] of char;

const
		nPrevItem : integer = 0;
		nItem : integer = 0;
		hWndUpDown : HWND = 0;


begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+26, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	QuestionPropProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

        case Message of

		wm_InitDialog:
			begin

				GetWindowRect(GetDlgItem(Dialog, 206), rc);
				MapWindowPoints(HWND_DESKTOP, Dialog, rc, 2);
				InflateRect(rc, 1, 1);

				CenterDialog(Dialog);
				hOption := Dialog;

				{--lire record tQuestion--}
				FillChar(tQuestion, SizeOf(tQuestion), 0);
				nPrevItem := HIWORD(lParam);
				nItem := LOWORD(lParam);
				GetQuestionRec(nItem, tQuestion);
				GetWindowText(Dialog, szCaption, SizeOf(szCaption));
				StrCat(szCaption, ' : ');
				StrCat(szCaption, tQuestion.Nom);
				SetWindowText(Dialog, szCaption);

				{ if "Apply to all" was checked load previous options ... }
				if nPrevItem > 0 then begin
					GetQuestionRec(nPrevItem, tQuestion);
				end;

				if bWin95 then begin
					hWndUpDown := CreateWindowEx (
								0,
								UPDOWN_CLASS,
								'',
								WS_CHILD {OR WS_BORDER} OR WS_VISIBLE
								{OR UDS_AUTOBUDDY} OR UDS_SETBUDDYINT OR UDS_ARROWKEYS OR UDS_HORZ
								{OR	UDS_WRAP OR UDS_HORZ OR UDS_ARROWKEYS OR UDS_ALIGNRIGHT OR UDS_SETBUDDYINT},
								rc.right + 2, rc.top, (rc.bottom - rc.top) * 3 DIV 2, rc.bottom - rc.top,
								Dialog,
								10001,
								hInstance,
								nil );

					SendMessage( hWndUpDown, UDM_SETBUDDY, GetDlgItem(Dialog, 206), 0 );

					SendMessage( hWndUpDown, UDM_SETRANGE, 0, MAKELONG(999, 0));

					SendMessage( hWndUpDown, UDM_SETPOS, 0, MAKELONG(tQuestion.DureeReponse, 0));
				end else begin
					SetDlgItemInt(Dialog, 206, tQuestion.DureeReponse, FALSE);
				end;

				if tQuestion.ReponseSon then CheckDlgButton(Dialog, 207, 1);
				if tQuestion.ReponseTexte then CheckDlgButton(Dialog, 208, 1);

				{ if "Apply to all" was checked reload current options and send OK ... }
				if nPrevItem > 0 then begin
					GetQuestionRec(nItem, tQuestion);
					CheckDlgButton(Dialog, 1001, 1);
					PostMessage(Dialog, WM_COMMAND, IDOK, 0);
				end else begin
					PostMessage(Dialog, WM_MMPAINT, 0, 0);
				end;

			end;

			WM_MMPAINT :
				begin
					ShowWindow(Dialog, SW_SHOW);
				end;

		wm_Command:
			begin
			case LoWord(wParam) of

				IDOK:
					begin
					hOption := 0;

						if bWin95 then begin
							tQuestion.DureeReponse := SendMessage( hWndUpDown, UDM_GETPOS, 0, MAKELONG( 0, 0));
						end else begin
							tQuestion.DureeReponse := GetDlgItemInt(Dialog, 206, bSign, FALSE);
						end;

						tQuestion.ReponseSon := IsDlgButtonChecked(Dialog, 207) = 1;
						tQuestion.ReponseTexte := IsDlgButtonChecked(Dialog, 208) = 1;

						{ sauve tQuestion à jours }
						SetQuestionRec(nItem, tQuestion);

						QuestionPropProc := TRUE;
						if IsDlgButtonChecked(Dialog, 1001) > 0 then begin
							EndDialog(Dialog, nItem);
						end else begin
							EndDialog(Dialog, -1);
						end;

					end;

				IDCANCEL:
					begin
						hOption := 0;
						QuestionPropProc := FALSE;
						EndDialog(Dialog, 0);
					end;

				206 :
					begin
						//Case HiWord(LPARAM) of
       						Case HiWord(wParam) of
							EN_CHANGE:
								begin
									CheckRadioButton(Dialog, 100, 106, 106);
								end;
						end;
					end;

				end;
			end;
	else
		QuestionPropProc := FALSE;
	end;
end;
{*************************************************************}

{*************************************************************}
{                  fonction ImagePropProc                       }
{ SE:                                                         }
{ SI:                                                         }
{*************************************************************}
function ImagePropProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var rWin,
		rc,
		Rect : TRECT;
		gOptions,
		tOptions : byte;
		hWin : HWND;
		bSign : BOOL;
		szCaption : Array[0..255] of char;

const
		nPrevItem : integer = 0;
		nItem : integer = 0;
		hWndUpDown : HWND = 0;


begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+26, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	ImagePropProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of

		wm_InitDialog:
			begin
				GetWindowRect(GetDlgItem(Dialog, 116), rc);
				MapWindowPoints(HWND_DESKTOP, Dialog, rc, 2);
				InflateRect(rc, 1, 1);

				if (IsDlgButtonChecked(hListBar,1201) = 1) then begin
					ShowWindow(GetDlgItem(Dialog, 117), SW_HIDE);
					ShowWindow(GetDlgItem(Dialog, 118), SW_HIDE);
				end else begin
					SetWindowText(Dialog, 'Propriétés de la vidéo')
				end;

				CenterDialog(Dialog);
				hOption := Dialog;

				{--lire record tQuestion--}
				FillChar(tQuestion, SizeOf(tQuestion), 0);
				nPrevItem := HIWORD(lParam);
				nItem := LOWORD(lParam);
				GetQuestionRec(nItem, tQuestion);
				GetWindowText(Dialog, szCaption, SizeOf(szCaption));
				StrCat(szCaption, ' : ');
				StrCat(szCaption, tQuestion.Nom);
				SetWindowText(Dialog, szCaption);

				{ if "Apply to all" was checked load previous options ... }
				if nPrevItem > 0 then begin
					GetQuestionRec(nPrevItem, tQuestion);
				end;

				if bWin95 then begin
					hWndUpDown := CreateWindowEx (
								0,
								UPDOWN_CLASS,
								'',
								WS_CHILD {OR WS_BORDER} OR WS_VISIBLE
								{OR UDS_AUTOBUDDY} OR UDS_SETBUDDYINT OR UDS_ARROWKEYS OR UDS_HORZ
								{OR	UDS_WRAP OR UDS_HORZ OR UDS_ARROWKEYS OR UDS_ALIGNRIGHT OR UDS_SETBUDDYINT},
								rc.right + 2, rc.top, (rc.bottom - rc.top) * 3 DIV 2, rc.bottom - rc.top,
								Dialog,
								10001,
								hInstance,
								nil );

					SendMessage( hWndUpDown, UDM_SETBUDDY, GetDlgItem(Dialog, 116), 0 );

					SendMessage( hWndUpDown, UDM_SETRANGE, 0, MAKELONG(999, 0));

					SendMessage( hWndUpDown, UDM_SETPOS, 0, MAKELONG(tQuestion.nZoom, 0));
				end else begin
					SetDlgItemInt(Dialog, 116, tQuestion.nZoom, FALSE);
				end;

				if BOOL(tQuestion.wStyle AND QS_BMPTOP) then begin
					CheckRadioButton(Dialog, 113, 115, 113);
				end else begin
					if BOOL(tQuestion.wStyle AND QS_BMPBOTTOM) then begin
						CheckRadioButton(Dialog, 113, 115, 114);
					end else begin
						CheckRadioButton(Dialog, 113, 115, 115);
					end;
				end;

				if (tQuestion.wStyle AND QS_VIDEOBAR) <> 0 then begin
					CheckDlgButton(Dialog, 118, 1);
				end;

				if (tQuestion.wStyle AND QS_STRECHED) <> 0 then begin
					bStreched := TRUE;
					CheckRadioButton(Dialog, 100, 106, 100);
					tQuestion.nZoom := 0;
				end else begin
					bStreched := FALSE;
					if tQuestion.wVer >= $0400 then begin
						case tQuestion.nZoom of
							0   : begin
											tQuestion.nZoom := 100;
											CheckRadioButton(Dialog, 100, 106, 103);
										end;
							50  : CheckRadioButton(Dialog, 100, 106, 101);
							75  : CheckRadioButton(Dialog, 100, 106, 102);
							100 : CheckRadioButton(Dialog, 100, 106, 103);
							150 : CheckRadioButton(Dialog, 100, 106, 104);
							200 : CheckRadioButton(Dialog, 100, 106, 105);
						else CheckRadioButton(Dialog, 100, 106, 106);
						end;
					end else begin
						CheckRadioButton(Dialog, 100, 106, 103);
						tQuestion.nZoom := 100;
					end;
				end;

				gOptions := tQuestion.Options AND $0F;
				case gOptions of
					$FF :
						begin
						end;
					$01 :
						begin
							CheckRadioButton(Dialog, 107, 111, 111);
						end;
					$02 :
						begin
							CheckRadioButton(Dialog, 107, 111, 107);
						end;
					$03 :
						begin
							CheckRadioButton(Dialog, 107, 111, 108);
						end;
					$04 :
						begin
							CheckRadioButton(Dialog, 107, 111, 109);
						end;
					$05 :
						begin
							CheckRadioButton(Dialog, 107, 111, 110);
						end;
					else begin
						CheckRadioButton(Dialog, 107, 111, 109);
						tQuestion.Options := (tQuestion.Options AND $F0) OR $04;
					end;
				end;

				{ if "Apply to all" was checked reload current options and send OK ... }
				if nPrevItem > 0 then begin
					GetQuestionRec(nItem, tQuestion);
					CheckDlgButton(Dialog, 1001, 1);
					PostMessage(Dialog, WM_COMMAND, IDOK, 0);
				end else begin
					PostMessage(Dialog, WM_MMPAINT, 0, 0);
				end;

			end;

			WM_MMPAINT :
				begin
					ShowWindow(Dialog, SW_SHOW);
				end;

		wm_Command:
			begin
			case LoWord(wParam) of

				IDOK:
					begin
					hOption := 0;

				if BOOL(IsDlgButtonChecked(Dialog, 118)) then begin
						tQuestion.wStyle := tQuestion.wStyle OR QS_VIDEOBAR;
				end else begin
						tQuestion.wStyle := tQuestion.wStyle AND NOT QS_VIDEOBAR;
				end;

				{--Taille adaptée--}
				if BOOL(IsDlgButtonChecked(Dialog, 100)) then begin
						bStreched := TRUE;
						tQuestion.wStyle := tQuestion.wStyle OR QS_STRECHED;
						PostMessage(hGraphiqueProc, WM_USER + 1004, 0, 0);
				end else begin
						bStreched := FALSE;
						tQuestion.wStyle := tQuestion.wStyle AND NOT QS_STRECHED;
						{PostMessage(hGraphiqueProc, WM_USER + 1004, ZOOM, 0);}
				end;

				{--premier plan--}
				if BOOL(IsDlgButtonChecked(Dialog, 113)) then begin
						tQuestion.wStyle := tQuestion.wStyle OR QS_BMPTOP;
				end else begin
						tQuestion.wStyle := tQuestion.wStyle AND NOT QS_BMPTOP;
				end;
				if BOOL(IsDlgButtonChecked(Dialog, 114)) then begin
						tQuestion.wStyle := tQuestion.wStyle OR QS_BMPBOTTOM;
				end else begin
						tQuestion.wStyle := tQuestion.wStyle AND NOT QS_BMPBOTTOM;
				end;

			 {--Image : Plein Ecran--}
					if BOOL(IsDlgButtonChecked(Dialog,107)) then begin
						tQuestion.Options := (tQuestion.Options AND $F0) OR $02;
						{ShowWindow(hGraphiqueProc, SW_SHOWMAXIMIZED);}
						GetWindowRect(GetParent(hGraphiqueProc), Rect);
						MapWindowPoints(0, GetParent(hGraphiqueProc), Rect, 2);
						SetWindowPos(hGraphiqueProc, HWND_TOPMOST, Rect.left, Rect.top,
																						Rect.right - Rect.left, Rect.bottom -Rect.top,
																						0);
					end;

			 {--Image : Position initiale--}
					if BOOL(IsDlgButtonChecked(Dialog,108)) then begin
						tQuestion.Options := (tQuestion.Options AND $F0) OR $03;
						PostMessage(hGraphiqueProc, WM_USER + 1005, 0, 0);
					end;

			 {--Image : Position courante--}
					if BOOL(IsDlgButtonChecked(Dialog, 109)) then	begin
						tQuestion.Options := (tQuestion.Options AND $F0) OR $04;
					end;

			 {--Image : Position définie--}
					if BOOL(IsDlgButtonChecked(Dialog,110)) then begin
						tQuestion.Options := (tQuestion.Options AND $F0) OR $05;
						GetWindowRect(hGraphiqueProc, Rect);
						MapWindowPoints(0, GetParent(hGraphiqueProc), Rect, 2);
						tQuestion.gx1 := Rect.left;
						tQuestion.gy1 := Rect.top;
						tQuestion.gx2 := Rect.right;
						tQuestion.gy2 := Rect.bottom;
					end;

			 {--Image : Caché--}
					if BOOL(IsDlgButtonChecked(Dialog, 111)) then	begin
						tQuestion.Options := (tQuestion.Options AND $F0) OR $01;
						ShowWindow(hGraphiqueProc, SW_HIDE);
					end;

			 {--Image : Zoom --}
					if BOOL(IsDlgButtonChecked(Dialog,101)) then begin
						bStreched := FALSE;
						tQuestion.nZoom := aZOOM[1];
						PostMessage(hGraphiqueProc, WM_USER + 1004, aZOOM[1], 0);
					end;
					if BOOL(IsDlgButtonChecked(Dialog,102)) then begin
						bStreched := FALSE;
						tQuestion.nZoom := aZOOM[2];
						PostMessage(hGraphiqueProc, WM_USER + 1004, aZOOM[2], 0);
					end;
					if BOOL(IsDlgButtonChecked(Dialog,103)) then begin
						bStreched := FALSE;
						tQuestion.nZoom := aZOOM[3];
						PostMessage(hGraphiqueProc, WM_USER + 1004, aZOOM[3], 0);
					end;
					if BOOL(IsDlgButtonChecked(Dialog,104)) then begin
						bStreched := FALSE;
						tQuestion.nZoom := aZOOM[4];
						PostMessage(hGraphiqueProc, WM_USER + 1004, aZOOM[4], 0);
					end;
					if BOOL(IsDlgButtonChecked(Dialog,105)) then begin
						bStreched := FALSE;
						tQuestion.nZoom := aZOOM[5];
						PostMessage(hGraphiqueProc, WM_USER + 1004, aZOOM[5], 0);
					end;
					if BOOL(IsDlgButtonChecked(Dialog,106)) then begin
						bStreched := FALSE;
						if bWin95 then begin
							tQuestion.nZoom := SendMessage( hWndUpDown, UDM_GETPOS, 0, MAKELONG( 0, 0));
						end else begin
							tQuestion.nZoom := GetDlgItemInt(Dialog, 116, bSign, FALSE);
						end;
						PostMessage(hGraphiqueProc, WM_USER + 1004, tQuestion.nZoom, 0);
					end;

						{ sauve tQuestion à jours }
						SetQuestionRec(nItem, tQuestion);

						ImagePropProc := TRUE;
						if IsDlgButtonChecked(Dialog, 1001) > 0 then begin
							EndDialog(Dialog, nItem);
						end else begin
							EndDialog(Dialog, -1);
						end;

						if NOT IsVideoFile(tQuestion.FichierGraph) then begin
							StrCopy(mciMessage, 'DISPLAY ');
							StrCat(mciMessage, tQuestion.FichierGraph);
							ProcessOptionsBitmap(tQuestion, mciMessage);
							MciDisplay(mciMessage);
						end;

					end;

				IDCANCEL:
					begin
						hOption := 0;
						ImagePropProc := FALSE;
						EndDialog(Dialog, 0);
					end;

				116 :
					begin
						//Case HiWord(LPARAM) of
						Case HiWord(wParam) of
							EN_CHANGE:
								begin
									CheckRadioButton(Dialog, 100, 106, 106);
								end;
						end;
					end;

				end;
			end;
	else
		ImagePropProc := FALSE;
	end;
end;
{*************************************************************}

{*************************************************************}
{                  fonction SoundPropProc                       }
{ SE:                                                         }
{ SI:                                                         }
{*************************************************************}
function SoundPropProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var rc,
		Rect : TRECT;
		bSign : BOOL;
		szCaption : Array[0..255] of char;

const
		rWin : TRECT = (left : 0; top : 0; right : 0; bottom : 0);
		nPrevItem : integer = 0;
		nItem : integer = 0;
		hWin : HWND = 0;

begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+27, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	SoundPropProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of

		wm_InitDialog:
			begin
				GetWindowRect(GetDlgItem(Dialog, 116), rc);
				MapWindowPoints(HWND_DESKTOP, Dialog, rc, 2);
				InflateRect(rc, 1, 1);

				CenterDialog(Dialog);
				hOption := Dialog;

				hWin := 0;

				{--lire record tQuestion--}
				FillChar(tQuestion, SizeOf(tQuestion), 0);
				nPrevItem := HIWORD(lParam);
				nItem := LOWORD(lParam);
				GetQuestionRec(nItem, tQuestion);
				GetWindowText(Dialog, szCaption, SizeOf(szCaption));
				StrCat(szCaption, ' : ');
				StrCat(szCaption, tQuestion.Nom);
				SetWindowText(Dialog, szCaption);

				{ if "Apply to all" was checked load previous options ... }
				if nPrevItem > 0 then begin
					GetQuestionRec(nPrevItem, tQuestion);
				end;

				if (tQuestion.wStyle AND QS_SOUNDBAR) <> 0 then begin
					CheckDlgButton(Dialog, 118, 1);
				end;

				if (tQuestion.wStyle AND QS_RECIN) <> 0 then begin
					CheckDlgButton(Dialog, 116, 1);
				end;

				SetDlgItemInt(Dialog, 117, tQuestion.bRecIn, FALSE);

				{ if "Apply to all" was checked reload current options and send OK ... }
				if nPrevItem > 0 then begin
					GetQuestionRec(nItem, tQuestion);
					CheckDlgButton(Dialog, 1001, 1);
					PostMessage(Dialog, WM_COMMAND, IDOK, 0);
				end else begin
					PostMessage(Dialog, WM_MMPAINT, 0, 0);
				end;
			end;

			WM_MMPAINT :
				begin
					ShowWindow(Dialog, SW_SHOW);
				end;

		wm_Command:
			begin
			case LoWord(wParam) of

				IDOK:
					begin

						if BOOL(IsDlgButtonChecked(Dialog, 118)) then begin
								tQuestion.wStyle := tQuestion.wStyle OR QS_SOUNDBAR;
						end else begin
								tQuestion.wStyle := tQuestion.wStyle AND NOT QS_SOUNDBAR;
						end;

						if BOOL(IsDlgButtonChecked(Dialog, 116)) then begin
								tQuestion.wStyle := tQuestion.wStyle OR QS_RECIN;
						end else begin
								tQuestion.wStyle := tQuestion.wStyle AND NOT QS_RECIN;
						end;

						tQuestion.bRecIn := GetDlgItemInt(Dialog, 117, bSign, FALSE);

						if hWin <> 0 then begin
							GetWindowRect(hWin, rWin);
							MapWindowPoints(HWND_DESKTOP, window, rWin, 2);
							DestroyWindow(hWin);
							hWin := 0;
						end;
						tQuestion.SndBarX := rWin.left;
						tQuestion.SndBarY := rWin.top;
						tQuestion.SndBarW := rWin.right - rWin.left;

						{ sauve tQuestion à jours }
						SetQuestionRec(nItem, tQuestion);

						if IsDlgButtonChecked(Dialog, 1001) > 0 then begin
							EndDialog(Dialog, nItem);
						end else begin
							EndDialog(Dialog, -1);
						end;
					end;

				119	:
					begin
						if hWin = 0 then begin
							hWin := MciWndCreate(Dialog,
                                                                hInstance,
                                                                WS_POPUP OR WS_OVERLAPPED OR
								WS_CAPTION OR WS_THICKFRAME OR
								MCIWNDF_NOERRORDLG OR
								MCIWNDF_NOMENU,
                                                                '');

							GetClientRect(window, rc);
							if (tQuestion.SndBarX < 0) OR
								 (tQuestion.SndBarX > rc.right) then tQuestion.SndBarX := 0;
							if (tQuestion.SndBarY < 0) OR
								 (tQuestion.SndBarY > rc.bottom) then tQuestion.SndBarY := 0;
							if (tQuestion.SndBarW < 0) OR
								 (tQuestion.SndBarW > rc.right) then tQuestion.SndBarW := 200;

							if (tQuestion.SndBarX = 0) AND
								 (tQuestion.SndBarY = 0) AND
								 (tQuestion.SndBarW = 0) then begin
								tQuestion.SndBarX := rWin.left;
								tQuestion.SndBarY := rWin.top;
								tQuestion.SndBarW := rWin.right - rWin.left;
							end;

							MapWindowPoints(window, HWND_DESKTOP, tQuestion.SndBarX, 1);
							SetWindowPos(hWin, 0, tQuestion.SndBarX, tQuestion.SndBarY, tQuestion.SndBarW, 0, SWP_NOZORDER);

							SetwindowText(hWin, 'Son');
							FlashWindow(hWin, TRUE);
							BringWindowToTop(hWin);
							ShowWindow(hWin, SW_SHOW);
						end else begin
							GetWindowRect(hWin, rWin);
							MapWindowPoints(HWND_DESKTOP, window, rWin, 2);
							tQuestion.SndBarX := rWin.left;
							tQuestion.SndBarY := rWin.top;
							tQuestion.SndBarW := rWin.right - rWin.left;
							DestroyWindow(hWin);
							hWin := 0;
						end;

					end;

				IDCANCEL:
					begin
						hOption := 0;
						SoundPropProc := FALSE;
						EndDialog(Dialog, 0);
					end;

				end;
			end;
	else
		SoundPropProc := FALSE;
	end;
end;
{*************************************************************}

{*************************************************************}
{                  fonction TutorPropProc                       }
{ SE:                                                         }
{ SI:                                                         }
{*************************************************************}
function TutorPropProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var
		r	: TRECT;
		szCaption : Array[0..255] of char;

const
		nPrevItem : integer = 0;
		nItem : integer = 0;

begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+27, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	TutorPropProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of

		wm_InitDialog:
			begin

				CenterDialog(Dialog);

				{--lire record tQuestion--}
				FillChar(tQuestion, SizeOf(tQuestion), 0);
				nPrevItem := HIWORD(lParam);
				nItem := LOWORD(lParam);
				GetQuestionRec(nItem, tQuestion);
				GetWindowText(Dialog, szCaption, SizeOf(szCaption));
				StrCat(szCaption, ' : ');
				StrCat(szCaption, tQuestion.Nom);
				SetWindowText(Dialog, szCaption);

				if tQuestion.FichierQCM[0] <> #0 then begin
                                	{$IFDEF _TUTOR}
					StrCopy(MainQcmWin^.szFichierQ, tQuestion.FichierQCM);
					SendMessage(MainQcmWin^.HWindow, UM_LOADQCM, 0, 0);
                                	{$ENDIF}
					BringWindowToTop(hQcmProc);
					ShowWindow(hQcmProc, SW_SHOW);
				end else begin
					ShowWindow(hQcmProc, SW_HIDE);
				end;

				{ if "Apply to all" was checked load previous options ... }
				if nPrevItem > 0 then begin
					GetQuestionRec(nPrevItem, tQuestion);
				end;

				{ TODO : Check controls ... }
				CheckRadioButton(Dialog, 107, 109, 109);

				{ if "Apply to all" was checked reload current options and send OK ... }
				if nPrevItem > 0 then begin
					GetQuestionRec(nItem, tQuestion);
					CheckDlgButton(Dialog, 1001, 1);
					PostMessage(Dialog, WM_COMMAND, IDOK, 0);
				end else begin
					PostMessage(Dialog, WM_MMPAINT, 0, 0);
				end;
			end;

			WM_MMPAINT :
				begin
					ShowWindow(Dialog, SW_SHOW);
				end;

		wm_Command:
			begin
			case LoWord(wParam) of

				IDOK:
					begin

						if BOOL(IsDlgButtonChecked(Dialog,107)) then begin
							SendMessage(hQcmProc, UM_FULLPOS, 0, 0);
						end;

						if BOOL(IsDlgButtonChecked(Dialog,108)) then begin
							SendMessage(hQcmProc, UM_INITPOS, 0, 0);
						end;

						GetWindowRect(hQcmProc, r);
						MapWindowPoints(0, GetParent(hQcmProc), r, 2);
						tQuestion.qX := r.left;
						tQuestion.qY := r.top;
						tQuestion.qW := r.right - r.left;
						tQuestion.qH := r.bottom - r.top;

						{ sauve tQuestion à jours }
						SetQuestionRec(nItem, tQuestion);
						if IsDlgButtonChecked(Dialog, 1001) > 0 then begin
							EndDialog(Dialog, nItem);
						end else begin
							EndDialog(Dialog, -1);
						end;
					end;

				IDCANCEL:
					begin
						TutorPropProc := FALSE;
						EndDialog(Dialog, 0);
					end;

				end;
			end;
	else
		TutorPropProc := FALSE;
	end;
end;
{*************************************************************}

{*************************************************************}
Procedure GetFont(var LogFont : Windows.TLOGFONT; var FrColorRef : TCOLORREF);
var chfont : Windows.TCHOOSEFONT;
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+28, 0, 0, 0, nil, TRUE);
	{$ENDIF}

	with chfont do begin
		lStructSize := SizeOf(TCHOOSEFONT);
		hWndOwner := GetActiveWindow;
		iPointSize := LogFont.lfHeight;
		lpLogFont := @LogFont;
		Flags := CF_EFFECTS OR CF_BOTH OR CF_INITTOLOGFONTSTRUCT;
		rgbColors := FrColorRef;
	end;
	ChooseFont(@chfont);
	FrColorRef := chfont.rgbColors;
end;

Procedure GetColor(var BkColorRef : TCOLORREF);
var chcolor : TCHOOSECOLOR;
	 { These are the standard VGA colors, we will be stuck with until the
		 end of time! }
const		CosmicColors : Array[0..15] of DWORD = (
				 $00000000        { 0000  black           }
				,$00800000        { 0001  dark red        }
				,$00008000        { 0010  dark green      }
				,$00808000        { 0011  mustard         }
				,$00000080        { 0100  dark blue       }
				,$00800080        { 0101  purple          }
				,$00008080        { 0110  dark turquoise  }
				,$00C0C0C0        { 1000  gray            }
				,$00808080        { 0111  dark gray       }
				,$00FF0000        { 1001  red             }
				,$0000FF00        { 1010  green           }
				,$00FFFF00        { 1011  yellow          }
				,$000000FF        { 1100  blue            }
				,$00FF00FF        { 1101  pink (magenta)  }
				,$0000FFFF        { 1110  cyan            }
				,$00FFFFFF        { 1111  white           }
				);
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+29, 0, 0, 0, nil, TRUE);
	{$ENDIF}

	with chcolor do begin
		lStructSize := SizeOf(TCHOOSECOLOR);
		hWndOwner := GetActiveWindow;
		rgbResult := BkColorRef;
		lpCustColors := @CosmicColors;
		Flags	:= CC_RGBINIT;
	end;
	ChooseColor(@chcolor);
	BkColorRef := chcolor.rgbResult;
end;

procedure ChangeSequenceString(hList : HWND; id : WORD; nItem : integer; pszNewTitle : PCHAR);
var
		lpSeqProp : PSEQPROP;
begin
	lpSeqProp := nil;
	SendDlgItemMessage(hList, id, LB_GETTEXT, nItem, LongInt(@lpSeqProp));
	if (lpSeqProp <> nil) then begin
		StrDispose(lpSeqProp^.pszText);
		lpSeqProp^.pszText := StrNew(pszNewTitle);
		if lpSeqProp^.pszText = nil then lpSeqProp^.pszText := StrNew(' ');
	end;
	InvalidateRect(GetDlgItem(hList, id), nil, TRUE);
	{UpdateWindow(GetDlgItem(hList, id));}
end;

procedure ChangeSequenceProp(hList : HWND; id : WORD; nItem : integer; tQuestion: TypeQuestion);
var
		lpSeqProp : PSEQPROP;
begin
	lpSeqProp := new(PSEQPROP);
	if lpSeqProp <> nil then begin
		SendDlgItemMessage(hList, id, LB_DELETESTRING, nItem, 0);
		lpSeqProp^.pszText := StrNew(tQuestion.Nom);
		if lpSeqProp^.pszText = nil then lpSeqProp^.pszText := StrNew(' ');
		CopyLogFont16to32(lpSeqProp^.hLogFnt, tQuestion.hLogFnt);
		lpSeqProp^.FrColRef := tQuestion.FrColRef;
		lpSeqProp^.BkColRef := tQuestion.BkColRef;
		SendDlgItemMessage(hList, id, LB_INSERTSTRING, nItem, LongInt(lpSeqProp));
	end;
end;

{*************************************************************}
{                  fonction CharMapPropProc                   }
{ SE:                                                         }
{ SI:                                                         }
{*************************************************************}
function CharMapProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var
		r	: TRECT;
		pt 	 : TPOINT;
		hCtl : HWND;
		nID	 : integer;
		szCaption : array[0..2] of char;
		lg					  : longint;
		action,
		state,
		item			: WORD;
		OldBrush	: HBRUSH;
		hOldFont	: HFONT;

const
		lpSeqProp : PSEQPROP = nil;
		hFnt : HFONT = 0;

begin

	CharMapProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of

		wm_InitDialog:
			begin
				CenterDialog(Dialog);
				lpSeqProp := PSEQPROP(lParam);
				nID := lpSeqProp^.hLogFnt.lfHeight;
				lpSeqProp^.hLogFnt.lfHeight := -13;
				hFnt := CreateFontIndirect(lpSeqProp^.hLogFnt);
				lpSeqProp^.hLogFnt.lfHeight := nID;
				nID := 32;
				szCaption[1] := #0;
				hCtl := GetWindow(Dialog, GW_CHILD);
				while IsWindow(hCtl) do begin
					SetWindowWord(hCtl, GWL_ID, nID);
					szCaption[0] := Char(nID);
					SetWindowText(hCtl, szCaption);
					inc(nID);
					hCtl := GetWindow(hCtl, GW_HWNDNEXT);
				end;
			end;

		wm_Destroy:
			begin
				Setfocus(lpSeqProp^.hWin);
				deleteObject(hFnt);
			end;

		WM_MEASUREITEM :
			begin
				item := PMeasureItemStruct(lParam)^.CtlID;
				GetClientRect(GetDlgItem(Dialog, item), r);
				PMeasureItemStruct(lParam)^.itemWidth := r.right;
				PMeasureItemStruct(lParam)^.itemHeight := r.bottom;
			end;

		WM_DRAWITEM :
			begin
				dc := PDrawItemStruct(lParam)^.hDC;
				r := PDrawItemStruct(lParam)^.rcItem;
				item := PDrawItemStruct(lParam)^.CtlID;
				action := PDrawItemStruct(lParam)^.itemAction;
				state := PDrawItemStruct(lParam)^.itemState;
				if Boolean(action AND ODA_SELECT) OR
					 Boolean(action AND ODA_DRAWENTIRE) then begin
					if Boolean(state AND ODS_SELECTED) then begin
						{OldBrush := SelectObject(dc, CreateSolidBrush(NOT lpSeqProp^.BkColRef));}
						OldBrush := SelectObject(dc, CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)));
						if (item - 31) Mod 32 = 0 then begin
							if item >= 32 * 7 then begin
								Rectangle(dc, r.left, r.top, r.right, r.bottom);
							end else begin
								Rectangle(dc, r.left, r.top, r.right + 1, r.bottom);
							end;
						end else begin
							if item >= 32 * 7 then begin
								Rectangle(dc, r.left, r.top, r.right, r.bottom + 1);
							end else begin
								Rectangle(dc, r.left, r.top, r.right + 1, r.bottom + 1);
							end;
						end;
						SetBkColor(DC, GetSysColor(COLOR_HIGHLIGHT));
						SetTextColor(DC, GetSysColor(COLOR_HIGHLIGHTTEXT));
					end else begin
						OldBrush := SelectObject(dc, CreateSolidBrush(lpSeqProp^.BkColRef));
						if (item - 31) Mod 32 = 0 then begin
							if item = 255 then begin
								Rectangle(dc, r.left, r.top, r.right, r.bottom);
							end else begin
								Rectangle(dc, r.left, r.top, r.right, r.bottom + 1);
							end;
						end else begin
							if item < 32 * 7 then begin
								Rectangle(dc, r.left, r.top, r.right + 1, r.bottom + 1);
							end else begin
								Rectangle(dc, r.left, r.top, r.right + 1, r.bottom);
							end;
						end;
						SetBkColor(DC, lpSeqProp^.BkColRef);
						SetTextColor(DC, lpSeqProp^.FrColRef);
					end;
					DeleteObject(SelectObject(dc, OldBrush));
					szCaption[0] := Char(item);
					lg := 1;
					if lg > 0 then begin
						hOldFont :=SelectObject(dc, hFnt);
						SetTextAlign(dc, TA_CENTER OR TA_BOTTOM);
						ExtTextOut(dc, (r.right - r.left) DIV 2, r.bottom - 2, ETO_CLIPPED, @r, szCaption, lg, nil);
						SetTextAlign(dc, TA_LEFT);
						SelectObject(dc, hOldFont);
					end;
				end;
			end;

		wm_Command:
			begin
				case LoWord(wParam) of

					32..255 :
						//if HIWORD(lParam) = BN_CLICKED then	begin
						if HiWord(wParam) = BN_CLICKED then	begin
							Setfocus(lpSeqProp^.hWin);
							SendMessage(lpSeqProp^.hWin, WM_CHAR, wParam, 0);
						end;

				IDOK, IDCANCEL:
					begin
						EndDialog(Dialog, 0);
					end;
				end;
			end;

	end;

	CharMapProc := FALSE;

end;

{*************************************************************}
{                  fonction SeqPropProc                       }
{ SE:                                                         }
{ SI:                                                         }
{*************************************************************}
function SeqPropProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var
		r	: TRECT;
		szCaption : Array[0..255] of char;
		bSign			: BOOL;

const
		nPrevItem 	: integer = 0;
		nItem 			: integer = 0;
		bKeepTitle	: BOOL = FALSE;
		bKeepFnt		: BOOL = FALSE;
		bKeepBkCol	: BOOL = FALSE;
		bKeepFrCol	: BOOL = FALSE;
		hLogFnt   	: Windows.TLogFont = ();
		FrColRef  	: Windows.TColorRef = 0;
		BkColRef  	: Windows.TColorRef = 0;
		hWin				: HWND = 0;
		hFnt				: HFONT = 0;
		hBr					: HBRUSH = 0;
		tQuestion   : TypeQuestion = ();

begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+27, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	SeqPropProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of

		wm_InitDialog:
			begin

				CenterDialog(Dialog);

				{--lire record tQuestion--}
				FillChar(tQuestion, SizeOf(tQuestion), 0);
				nPrevItem := HIWORD(lParam);
				nItem := LOWORD(lParam);
				GetQuestionRec(nItem, tQuestion);
				GetWindowText(Dialog, szCaption, SizeOf(szCaption));
				StrCat(szCaption, ' : ');
				StrCat(szCaption, tQuestion.Nom);
				SetWindowText(Dialog, szCaption);

				{ if "Apply to all" was checked load previous options ... }
				if nPrevItem > 0 then begin
					GetQuestionRec(nPrevItem, tQuestion);
				end else begin
					bKeepTitle := FALSE;
				end;

				{ TODO : Check controls ... }
				if bKeepTitle then CheckDlgButton(Dialog, 104, 1);
				if bKeepFnt then CheckDlgButton(Dialog, 105, 1);
				if bKeepFrCol then CheckDlgButton(Dialog, 106, 1);
				if bKeepBkCol then CheckDlgButton(Dialog, 107, 1);
				SetDlgItemText(Dialog, 101, tQuestion.Nom);
				CopyLogFont16to32(hLogFnt, tQuestion.hLogFnt);
				FrColRef := tQuestion.FrColRef;
				BkColRef := tQuestion.BkColRef;
				NormalizeSeqProp(PSEQPROP(@hLogFnt));
				if hLogFnt.lfFaceName[0] <> #0 then begin
					if hLogFnt.lfHeight > 1000 then begin
						CheckDlgButton(Dialog, 108, 1);
						hLogFnt.lfHeight := hLogFnt.lfHeight - 2000;
						hFnt := CreateFontIndirect(hLogFnt);
					end else begin
						hFnt := CreateFontIndirect(hLogFnt);
					end;
					SendDlgItemMessage(Dialog, 101, WM_SETFONT, hFnt, 0);
				end;
				hBr	:= CreateSolidBrush(BkColRef);
				CheckRadioButton(Dialog, 201, 206, 201 + LOBYTE(hLogFnt.lfOrientation));
				SetDlgItemInt(Dialog, 301, HIBYTE(hLogFnt.lfOrientation), FALSE);

				{ if "Apply to all" was checked reload current options and send OK ... }
				if nPrevItem > 0 then begin
					GetQuestionRec(nItem, tQuestion);
					CheckDlgButton(Dialog, 1001, 1);
					PostMessage(Dialog, WM_COMMAND, IDOK, 0);
				end else begin
					PostMessage(Dialog, WM_MMPAINT, 0, 0);
				end;
			end;

			WM_MMPAINT :
				begin
					ShowWindow(Dialog, SW_SHOW);
				end;

                { TODO :  WM_CTLCOLOR is for 16-bits, use :
                  WM_CTLCOLORBTN
                  WM_CTLCOLOREDIT
                  WM_CTLCOLORDLG
                  WM_CTLCOLORLISTBOX
                  WM_CTLCOLORSCROLLBAR
                  WM_CTLCOLORSTATIC
                }
		WM_CTLCOLOR:
			begin
				if (integer(HIWORD(lParam)) = CTLCOLOR_EDIT) AND
					 NOT ((BkColRef = 0) AND (FrColRef = 0)) then begin
					SetTextColor(HDC(wParam), FrColRef);
					SetBkColor(HDC(wParam), BkColRef);
					SeqPropProc := BOOL(hBr);
					exit;
				end;
			end;

		wm_Command:
			begin
			case LoWord(wParam) of

				102:
					begin
						GetFont(hLogFnt, FrColRef);
						if hLogFnt.lfFaceName[0] <> #0 then begin
							DeleteObject(hFnt);
							hFnt := CreateFontIndirect(hLogFnt);
							SendDlgItemMessage(Dialog, 101, WM_SETFONT, hFnt, MAKELONG(WORD(TRUE), 0));
						end;
					end;

				108:
					begin
						if hLogFnt.lfFaceName[0] <> #0 then begin
							DeleteObject(hFnt);
							if (IsDlgButtonChecked(Dialog, 108) = 1) then begin
								hFnt := CreateFontIndirect(hLogFnt);
							end else begin
								hFnt := CreateFontIndirect(hLogFnt);
							end;
							SendDlgItemMessage(Dialog, 101, WM_SETFONT, hFnt, MAKELONG(WORD(TRUE), 0));
						end;
					end;

				103:
					begin
						GetColor(BkColRef);
						DeleteObject(hBr);
						hBr	:= CreateSolidBrush(BkColRef);
						InvalidateRect(GetDlgItem(Dialog, 101), nil, TRUE);
					end;

				1001:
					begin
						CheckDlgButton(Dialog, 104, IsDlgButtonChecked(Dialog, 1001));
					end;

				401:
					begin
						hWin := GetDlgItem(Dialog, 101);
						DialogBoxParam(hInstRes, 'CharMap', Dialog, DLGPROC(@CharMapProc), DWORD(@hLogFnt));
					end;

				IDOK:
					begin

						GetQuestionRec(nItem, tQuestion);

						bKeepTitle := IsDlgButtonChecked(Dialog, 104) = 1;
						if NOT bKeepTitle then begin
							GetDlgItemText(Dialog, 101, tQuestion.Nom, SizeOf(tQuestion.Nom));
						end;
						bKeepFnt := IsDlgButtonChecked(Dialog, 105) = 1;
						if NOT bKeepFnt then begin
							CopyLogFont32to16(tQuestion.hLogFnt, hLogFnt);
						end;
						bKeepFrCol := IsDlgButtonChecked(Dialog, 106) = 1;
						if NOT bKeepFrCol then begin
							tQuestion.FrColRef := FrColRef;
						end;
						bKeepBkCol := IsDlgButtonChecked(Dialog, 107) = 1;
						if NOT bKeepBkCol then begin
							tQuestion.BkColRef := BkColRef;
						end;

						if (IsDlgButtonChecked(Dialog, 108) = 1) then begin
							if (tQuestion.hLogFnt.lfFaceName[0] = #0) then StrCopy(hLogFnt.lfFaceName, 'Arial');
							tQuestion.hLogFnt.lfHeight := hLogFnt.lfHeight + 2000;
						end else begin
							if tQuestion.hLogFnt.lfHeight = 0 then tQuestion.hLogFnt.lfHeight := -11;
						end;

						if (IsDlgButtonChecked(Dialog, 201) = 1) then begin
							tQuestion.hLogFnt.lfOrientation := 0;
						end;
						if (IsDlgButtonChecked(Dialog, 202) = 1) then begin
							tQuestion.hLogFnt.lfOrientation := 1;
						end;
						if (IsDlgButtonChecked(Dialog, 203) = 1) then begin
							tQuestion.hLogFnt.lfOrientation := 2;
						end;
						if (IsDlgButtonChecked(Dialog, 204) = 1) then begin
							tQuestion.hLogFnt.lfOrientation := 3;
						end;
						if (IsDlgButtonChecked(Dialog, 205) = 1) then begin
							tQuestion.hLogFnt.lfOrientation := 4;
						end;
						if (IsDlgButtonChecked(Dialog, 206) = 1) then begin
							tQuestion.hLogFnt.lfOrientation := 5;
						end;
						tQuestion.hLogFnt.lfOrientation := (tQuestion.hLogFnt.lfOrientation AND $FF) OR
					                                           (GetDlgItemInt(Dialog, 301, bSign, FALSE) shl 8);

						{ sauve tQuestion à jours }
						SetQuestionRec(nItem, tQuestion);
						ChangeSequenceProp(hLeconProc, idl_ListeQ, nItem - 1, tQuestion);
						ChangeSequenceProp(hListBar, idl_ListeQ, nItem - 1, tQuestion);
						DeleteObject(hBr);
						hBr := 0;
						DeleteObject(hFnt);
						hFnt := 0;
						if IsDlgButtonChecked(Dialog, 1001) > 0 then begin
							EndDialog(Dialog, nItem);
						end else begin
							EndDialog(Dialog, -1);
						end;
					end;

				IDCANCEL:
					begin
						SeqPropProc := FALSE;
						DeleteObject(hBr);
						hBr := 0;
						DeleteObject(hFnt);
						hFnt := 0;
						EndDialog(Dialog, 0);
					end;

				end;
			end;
	else
		SeqPropProc := FALSE;
	end;
end;

{*************************************************************}
{                  fonction TextPropProc  			              }
{ SE:                                                         }
{ SI:                                                         }
{*************************************************************}
function TextPropProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var rWin,
		Rect : TRECT;
		gOptions,
		tOptions : byte;
		hWin : HWND;
		lpRepTexteProc: TFarProc;
		hLogFnt		: Windows.TLOGFONT;
		frColRef,
		bkColRef : Windows.TCOLORREF;
		MinPos,
		MaxPos,
		ScrollPos,
		ScrollValue : Integer;
		MSG					: TMSG;
		szCaption : Array[0..255] of char;
		szText : Array[0..255] of char;
		bSign 		: BOOL;

const
		stReqText : TReqText = ();
		nPrevItem : integer = 0;
		nItem : integer = 0;

begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+30, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	TextPropProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of

		wm_InitDialog:
			begin
				CenterDialog(Dialog);
				hOption := Dialog;

				{--lire record tQuestion--}
				FillChar(tQuestion, SizeOf(tQuestion), 0);
				nPrevItem := HIWORD(lParam);
				nItem := LOWORD(lParam);
				GetQuestionRec(nItem, tQuestion);
				GetWindowText(Dialog, szCaption, SizeOf(szCaption));
				StrCat(szCaption, ' : ');
				StrCat(szCaption, tQuestion.Nom);
				SetWindowText(Dialog, szCaption);

				{ if "Apply to all" was checked load previous options ... }
				if nPrevItem > 0 then begin
					GetQuestionRec(nPrevItem, tQuestion);
				end;

				CopyLogFont16to32(hLogFnt, tQuestion.hLogFnt);
				frColRef := tQuestion.frColRef;
				bkColRef := tQuestion.bkColRef;

				if BOOL(tQuestion.wStyle AND QS_TXTTOP) then begin
					CheckRadioButton(Dialog, 113, 115, 113);
				end else begin
					if BOOL(tQuestion.wStyle AND QS_TXTBOTTOM) then begin
						CheckRadioButton(Dialog, 113, 115, 114);
					end else begin
						CheckRadioButton(Dialog, 113, 115, 115);
					end;
				end;

				tOptions := tQuestion.Options AND $F0;
				case tOptions of
					$10 :
						begin
							CheckRadioButton(Dialog, 107, 111, 111);
						end;
					$20 :
						begin
							CheckRadioButton(Dialog, 107, 111, 107);
						end;
					$30 :
						begin
							CheckRadioButton(Dialog, 107, 111, 108);
						end;
					$40 :
						begin
							CheckRadioButton(Dialog, 107, 111, 109);
						end;
					$50 :
						begin
							CheckRadioButton(Dialog, 107, 111, 110);
							{####MoveWindow(hTexteProc, tQuestion.tx1,
																		 tQuestion.ty1,
																		 tQuestion.tx2 - tQuestion.tx1,
																		 tQuestion.ty2 - tQuestion.ty1,
																		 TRUE);}
						end;
					else begin
						CheckRadioButton(Dialog, 107, 111, 109);
						tQuestion.Options := (tQuestion.Options AND $0F) OR $40;
					end;
				end;
				{--Positionne Reprise texte--}
				CheckDlgButton(Dialog, id_cb_Append, tQuestion.Mode AND QM_TXTAPPEND);
				CheckDlgButton(Dialog, id_cb_Append - 1, tQuestion.Mode AND QM_TXTADDIN);
				SetDlgItemInt(Dialog, 119, tQuestion.bAddIn, FALSE);
				CheckDlgButton(Dialog, 120, abs(integer(tQuestion.ReponseTexte)));
				CheckDlgButton(Dialog, 121, tQuestion.Mode AND QM_TXTATRECT);
				if BOOLEAN(tQuestion.Mode AND QM_TXTADDREL) then begin
					CheckRadioButton(Dialog, 128, 129, 129);
				end else begin
					CheckRadioButton(Dialog, 128, 129, 128);
				end;
				if BOOLEAN(tQuestion.Mode AND QM_TXTADDAFT) then begin
					CheckRadioButton(Dialog, 131, 132, 132);
				end else begin
					CheckRadioButton(Dialog, 131, 132, 131);
				end;

				{ Aligne sur fenêtre élève }
				GetWindowRect(Window, rWin);
				stReqText.Rect.left := rWin.left;
				stReqText.Rect.top := rWin.top;
				stReqText.Rect.right := 0;
				stReqText.Rect.bottom := 0;
				if BOOL(tQuestion.Mode AND QM_TXTATRECT) then begin
					stReqText.Rect.left := tQuestion.rtx1 + rWin.left;
					stReqText.Rect.top := tQuestion.rty1 + rWin.top;
					stReqText.Rect.right := tQuestion.rtx2;
					stReqText.Rect.bottom := tQuestion.rty2;
					SetDlgItemInt(Dialog, 122, tQuestion.rtx1, TRUE);
					SetDlgItemInt(Dialog, 123, tQuestion.rty1, TRUE);
					SetDlgItemInt(Dialog, 124, tQuestion.rtx2, TRUE);
					SetDlgItemInt(Dialog, 125, tQuestion.rty2, TRUE);
				end;

				{--Positionne la Pause--}
				SetTrackRange(GetDlgItem(Dialog, id_tk_Pause), 0, 30, FALSE);
				SetTrackPos(GetDlgItem(Dialog, id_tk_Pause), 0, FALSE);
				if tQuestion.Mode AND QM_PAUSE <> 0 then begin
					if tQuestion.wPause = WORD(-1) then begin
						CheckDlgButton(Dialog, id_cb_Pause, 1);
					end else begin
						SetTrackPos(GetDlgItem(Dialog, id_tk_Pause), tQuestion.wPause DIV 1000, FALSE);
						SetDlgItemInt(Dialog, id_ed_Pause , tQuestion.wPause DIV 1000, False);
					end;
				end;

				{ if "Apply to all" was checked reload current options and send OK ... }
				if nPrevItem > 0 then begin
					GetQuestionRec(nItem, tQuestion);
					{WriteLn(tQuestion.rtx1, ' ', tQuestion.rty1, ' ', tQuestion.rtx2, ' ', tQuestion.rty2);}
					CheckDlgButton(Dialog, 1001, 1);
					PostMessage(Dialog, WM_COMMAND, IDOK, 0);
				end else begin
					PostMessage(Dialog, WM_MMPAINT, 0, 0);
				end;
			end;

			WM_MMPAINT :
				begin
					ShowWindow(Dialog, SW_SHOW);
				end;

		WM_HSCROLL:
			begin
				ScrollPos := GetTrackPos(hiWord(LParam));
				GetTrackRange(hiWord(LParam), MinPos, MaxPos);
				Case wParam of
					SB_LINEUP        : ScrollValue := -1;
					SB_LINEDOWN      : ScrollValue := +1;
					SB_PAGEUP        : ScrollValue := -5;
					SB_PAGEDOWN      : ScrollValue := +5;
					SB_THUMBPOSITION,
					SB_THUMBTRACK 	 : ScrollValue := LoWord(lParam) - ScrollPos;
				else
					ScrollValue := 0;
				end;
				ScrollValue := max(-SCrollPos, min(ScrollValue,MaxPos-ScrollPos));
				ScrollPos := ScrollPos + ScrollValue;
				SetTrackPos(hiWord(lParam), ScrollPos, TRUE);
				SetDlgItemInt(Dialog, id_ed_Pause , ScrollPos, False);
			end;

		wm_Command:
			begin
			case LoWord(wParam) of

				400 :
					begin
						GetFont(hLogFnt, frColRef);
					end;

				401 :
					begin
						GetColor(bkColRef);
					end;

				{ Sauver position }
				126 :
					if BOOL(tQuestion.Mode AND QM_TXTATRECT) then begin
						wvsprintf(szText, '%d', @tQuestion.rtx1);
						WritePrivateProfileString('TEXT', 'REPX1', szText, gszIni);
						wvsprintf(szText, '%d', @tQuestion.rty1);
						WritePrivateProfileString('TEXT', 'REPY1', szText, gszIni);
						wvsprintf(szText, '%d', @tQuestion.rtx2);
						WritePrivateProfileString('TEXT', 'REPX2', szText, gszIni);
						wvsprintf(szText, '%d', @tQuestion.rty2);
						WritePrivateProfileString('TEXT', 'REPY2', szText, gszIni);
					end;

				{ Charger position }
				127 :
					if BOOL(tQuestion.Mode AND QM_TXTATRECT) then begin
						tQuestion.rtx1 := GetPrivateProfileInt('TEXT', 'REPX1', 0, gszIni);
						tQuestion.rty1 := GetPrivateProfileInt('TEXT', 'REPY1', 0, gszIni);
						tQuestion.rtx2 := GetPrivateProfileInt('TEXT', 'REPX2', 100, gszIni);
						tQuestion.rty2 := GetPrivateProfileInt('TEXT', 'REPY2', 100, gszIni);
						GetWindowRect(Window, rWin);
						stReqText.Rect.left := tQuestion.rtx1 + rWin.left;
						stReqText.Rect.top := tQuestion.rty1 + rWin.top;
						stReqText.Rect.right := tQuestion.rtx2;
						stReqText.Rect.bottom := tQuestion.rty2;
						SetDlgItemInt(Dialog, 122, tQuestion.rtx1, TRUE);
						SetDlgItemInt(Dialog, 123, tQuestion.rty1, TRUE);
						SetDlgItemInt(Dialog, 124, tQuestion.rtx2, TRUE);
						SetDlgItemInt(Dialog, 125, tQuestion.rty2, TRUE);
					end;

				id_bn_Position :
					begin
						{ prépare paramètres debut }
						FillChar(stReqText, SizeOf(stReqText), 0);
						tQuestion.bAddIn := GetDlgItemInt(Dialog, 119, bSign, FALSE);
						if BOOL(IsDlgButtonChecked(Dialog, id_cb_Append - 1)) then begin
							tQuestion.Mode := tQuestion.Mode OR QM_TXTADDIN;
						end else begin
							tQuestion.Mode := tQuestion.Mode AND NOT QM_TXTADDIN;
						end;
						if BOOL(IsDlgButtonChecked(Dialog, id_cb_Append)) then begin
							tQuestion.Mode := tQuestion.Mode OR QM_TXTAPPEND;
						end else begin
							tQuestion.Mode := tQuestion.Mode AND NOT QM_TXTAPPEND;
						end;
						stReqText.Mode := tQuestion.Mode;
					 { Aligne sur fenêtre élève }
						GetWindowRect(Window, rWin);
						if BOOL(tQuestion.Mode AND QM_TXTATRECT) then begin
							stReqText.Rect.left := tQuestion.rtx1 + rWin.left;
							stReqText.Rect.top := tQuestion.rty1 + rWin.top;
							stReqText.Rect.right := tQuestion.rtx2;
							stReqText.Rect.bottom := tQuestion.rty2;
						end;

						if BOOL(tQuestion.Mode AND QM_TXTAPPEND) then begin
							if (StrPos(StrUpper(tQuestion.FichierTexte), 'RTF') <> nil) then begin
								ReponseRtfFileName(stReqText.Path, NoElev, 0);
							end else begin
								ReponseTxtFileName(stReqText.Path, NoElev, 0);
							end;
							if BOOL(tQuestion.Mode AND QM_TXTADDIN) AND
								 NOT FileExist(stReqText.Path) then begin
								CopyFile(tQuestion.FichierTexte, stReqText.Path);
							end;
						end;

						{ actions utilisateur, paramètres MAJ }
						//lpRepTexteProc := MakeProcInstance(@RepTexteProc, HInstance);
						lpRepTexteProc := @RepTexteProc;
						if bWin95 then begin
							DialogBoxParam(hInstRes, 'RepTextPos', Dialog, DLGPROC(lpRepTexteProc), LongInt(@stReqText));
						end else begin
							if bWinNT then begin
								DialogBoxParam(hInstRes, 'ReponseTexte_ELPRNT', Dialog, DLGPROC(lpRepTexteProc), LongInt(@stReqText));
							end else begin
								DialogBoxParam(hInstRes, 'ReponseTexte_ELPR31', Dialog, DLGPROC(lpRepTexteProc), LongInt(@stReqText));
							end;
						end;

						//FreeProcInstance(lpRepTexteProc);

						{ recup paramètres fin }
						tQuestion.Mode := tQuestion.Mode OR QM_TXTATRECT;
						tQuestion.rtx1 := stReqText.Rect.left - rWin.left;
						tQuestion.rty1 := stReqText.Rect.top - rWin.top;
						tQuestion.rtx2 := stReqText.Rect.right;
						tQuestion.rty2 := stReqText.Rect.bottom;

						CheckDlgButton(Dialog, 121, tQuestion.Mode AND QM_TXTATRECT);
						SetDlgItemInt(Dialog, 122, tQuestion.rtx1, TRUE);
						SetDlgItemInt(Dialog, 123, tQuestion.rty1, TRUE);
						SetDlgItemInt(Dialog, 124, tQuestion.rtx2, TRUE);
						SetDlgItemInt(Dialog, 125, tQuestion.rty2, TRUE);

					end;

				IDOK:
					begin
					hOption := 0;

		 {--Texte : Premier plan --}
				if BOOL(IsDlgButtonChecked(Dialog, 113)) then begin
						tQuestion.wStyle := tQuestion.wStyle OR QS_TXTTOP;
				end else begin
						tQuestion.wStyle := tQuestion.wStyle AND NOT QS_TXTTOP;
				end;
				if BOOL(IsDlgButtonChecked(Dialog, 114)) then begin
						tQuestion.wStyle := tQuestion.wStyle OR QS_TXTBOTTOM;
				end else begin
						tQuestion.wStyle := tQuestion.wStyle AND NOT QS_TXTBOTTOM;
				end;

			 {--Texte : Caché--}
					if BOOL(IsDlgButtonChecked(Dialog,111)) then begin
						tQuestion.Options := (tQuestion.Options AND $0F) OR $10;
					end;

				{--Texte : Plein Ecran--}
					if BOOL(IsDlgButtonChecked(Dialog,107)) then begin
						tQuestion.Options := (tQuestion.Options AND $0F) OR $20;
					end;

				 {--Texte : Position initiale--}
					if BOOL(IsDlgButtonChecked(Dialog,108)) then begin
						tQuestion.Options := (tQuestion.Options AND $0F) OR $30;
					end;

				 {--Texte : Position courante--}
					if BOOL(IsDlgButtonChecked(Dialog,109)) then begin
						tQuestion.Options := (tQuestion.Options AND $0F) OR $40;
					end;

				 {--Texte : Position définie--}
					if BOOL(IsDlgButtonChecked(Dialog,110)) then begin
						tQuestion.Options := (tQuestion.Options AND $0F) OR $50;
						GetWindowRect(hTexteProc, Rect);
						MapWindowPoints(0, GetParent(hTexteProc), Rect, 2);
						tQuestion.tx1 := Rect.left;
						tQuestion.ty1 := Rect.top;
						tQuestion.tx2 := Rect.right;
						tQuestion.ty2 := Rect.bottom;
					end;
				 {--Texte : Reponse Texte--}
					tQuestion.ReponseTexte := IsDlgButtonChecked(Dialog, 120) = 1;

						{tQuestion.hLogFnt := hLogFnt;
						if hFnt <> 0 then begin
							deleteObject(hFnt);
							hFnt := CreateFontIndirect(tQuestion.hLogFnt);
							SendDlgItemMessage(hTexteProc, 101, WM_SETFONT, hFnt, MAKELONG(WORD(TRUE), 0));
						end;
						if tQuestion.frColRef <> frColRef then begin
							tQuestion.frColRef := frColRef;
						end;
						if tQuestion.bkColRef <> bkColRef then begin
							tQuestion.bkColRef := bkColRef;
							if hBkBrush <> 0 then begin
								deleteObject(hBkBrush);
								hBkBrush := CreateSolidBrush(tQuestion.BkColRef);
								InvalidateRect(GetDlgItem(hTexteProc, 101), 0, 0, 0, nil, TRUE);
							end;
						end;}

						{--Reprise Question--}
						tQuestion.bAddIn := GetDlgItemInt(Dialog, 119, bSign, FALSE);
						if BOOL(IsDlgButtonChecked(Dialog, id_cb_Append-1)) then begin
							tQuestion.Mode := tQuestion.Mode OR QM_TXTADDIN;
						end else begin
							tQuestion.Mode := tQuestion.Mode AND NOT QM_TXTADDIN;
						end;
						if BOOL(IsDlgButtonChecked(Dialog, id_cb_Append)) then begin
							tQuestion.Mode := tQuestion.Mode OR QM_TXTAPPEND;
						end else begin
							tQuestion.Mode := tQuestion.Mode AND NOT QM_TXTAPPEND;
						end;
						if BOOL(IsDlgButtonChecked(Dialog, 121)) then begin
							GetWindowRect(Window, rWin);
							tQuestion.Mode := tQuestion.Mode OR QM_TXTATRECT;
							tQuestion.rtx1 := stReqText.Rect.left - rWin.left;
							tQuestion.rty1 := stReqText.Rect.top - rWin.top;
							tQuestion.rtx2 := stReqText.Rect.right;
							tQuestion.rty2 := stReqText.Rect.bottom;
						end else begin
							tQuestion.Mode := tQuestion.Mode AND NOT QM_TXTATRECT;
							tQuestion.rtx1 := 0;
							tQuestion.rty1 := 0;
							tQuestion.rtx2 := 0;
							tQuestion.rty2 := 0;
						end;
						if BOOL(IsDlgButtonChecked(Dialog, 129)) then begin
							tQuestion.Mode := tQuestion.Mode OR QM_TXTADDREL;
						end else begin
							tQuestion.Mode := tQuestion.Mode AND NOT QM_TXTADDREL;
						end;
						if BOOL(IsDlgButtonChecked(Dialog, 132)) then begin
							tQuestion.Mode := tQuestion.Mode OR QM_TXTADDAFT;
						end else begin
							tQuestion.Mode := tQuestion.Mode AND NOT QM_TXTADDAFT;
						end;

						{--Pause--}
						tQuestion.wPause := GetTrackPos(GetDlgItem(Dialog, id_tk_Pause)) * 1000;
						if BOOL(IsDlgButtonChecked(Dialog, id_cb_Pause)) then begin
							tQuestion.wPause := WORD(-1);
						end;
						if tQuestion.wPause <> 0 then begin
							tQuestion.Mode := tQuestion.Mode OR QM_PAUSE;
						end else begin
							tQuestion.Mode := tQuestion.Mode AND NOT QM_PAUSE;
						end;

						{ sauve tQuestion à jours }
						SetQuestionRec(nItem, tQuestion);

						TextPropProc := TRUE;
						if IsDlgButtonChecked(Dialog, 1001) > 0 then begin
							EndDialog(Dialog, nItem);
						end else begin
							EndDialog(Dialog, -1);
						end;

						StrCopy(mciMessage, 'DISPLAY ');
						StrCat(mciMessage,tQuestion.FichierTexte);
						ProcessOptionsText(tQuestion, mciMessage);
						MciDisplay(mciMessage);

					end;

				IDCANCEL:
					begin
						hOption := 0;
						TextPropProc := FALSE;
						EndDialog(Dialog, 0);
					end;
				end;

			end;

	else
		TextPropProc := FALSE;
	end;

end;
{*************************************************************}

function ArabicToRoman(nArabic : integer; pszRoman : PCHAR; nSize : integer) : PCHAR;
var nDiv, i, j : integer;
const pszNum : array[1..13] of PCHAR = ( 'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I');
const nNum : array[1..13] of integer = (1000,  900, 500,  400, 100,   90,  50,   40,  10,    9,   5,    4,   1);
begin
	pszRoman[0] := #0;
	for i := 1 to 13 do begin
		nDiv := nArabic DIV nNum[i];
		nArabic := nArabic MOD nNum[i];
		for j := 1 to nDiv do begin
			StrCat(pszRoman, pszNum[i]);
		end
	end;
	ArabicToRoman := pszRoman;
end;

{*************************************************************}
{                  fonction RenumProc                       }
{ SE:                                                         }
{ SI:                                                         }
{*************************************************************}
function RenumProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

var
		r	: TRECT;
		pt 	 : TPOINT;
		nSel,
		nbSel,
		nNum,
		nInc,
		i		 : integer;
		bSign	: BOOL;
		p	: PCHAR;
		szNum : array[0..255] of char;
		szText : array[0..255] of char;

const pListSel : PINTARRAY = nil;

begin

	RenumProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of

		wm_InitDialog:
			begin
				CenterDialog(Dialog);
				CheckRadioButton(Dialog, 101, 102, 101);
				CheckRadioButton(Dialog, 201, 204, 201);
				pListSel := LBGetMultiSelList(hListBar, idl_ListeQ);
				nSel := LBGetListFirstSel(pListSel);
				if nSel < 0 then nSel := 0;
				SetDlgItemInt(Dialog, 301, nSel + 1, FALSE);
				SetDlgItemInt(Dialog, 302, 1, FALSE);
				while LBGetListNextSel(pListSel) <> -1 do;
			end;

		wm_Destroy:
			begin
				LBFreeMultiSelList(pListSel);
			end;

		wm_Command:
			begin
				case LoWord(wParam) of

				IDOK:
					begin
						nNum := GetDlgItemInt(Dialog, 301, bSign, FALSE);
						nInc := GetDlgItemInt(Dialog, 302, bSign, FALSE);
						if IsDlgButtonChecked(Dialog, 101) = 1 then begin
							nSel := LBGetListFirstSel(pListSel);
						end else begin
							nSel := 0;
							nbSel := SendDlgItemMessage(hListBar, idl_ListeQ, LB_GETCOUNT, 0, 0);
						end;
						while nSel <> -1 do begin
							GetQuestionRec(nSel + 1, tQuestion);
							p := StrPos(tQuestion.Nom, '-');
							if p <> nil then begin
								p := @p[1];
								while p[0] = ' ' do p := @p[1];
							end else begin
								p := @tQuestion.Nom;
							end;
							GetDlgItemText(Dialog, 303, szText, SizeOf(szText));
							if IsDlgButtonChecked(Dialog, 201) = 1 then begin
								Str(nNum, szNum);
							end;
							if IsDlgButtonChecked(Dialog, 202) = 1 then begin
								ArabicToRoman(nNum, szNum, SizeOf(szText));
							end;
							if IsDlgButtonChecked(Dialog, 203) = 1 then begin
								szNum[0] := char((nNum-1) MOD 26 + byte('A'));
								szNum[1] := #0;
							end;
							if IsDlgButtonChecked(Dialog, 204) = 1 then begin
								szNum[0] := char((nNum-1) MOD 26 + byte('a'));
								szNum[1] := #0;
							end;
							StrCat(szText, szNum);
							StrCat(szText, ' - ');
							StrCat(szText, p);
							StrCopy(tQuestion.Nom, szText);
							SetQuestionRec(nSel + 1, tQuestion);
							ChangeSequenceString(hListBar, idl_ListeQ, nSel, tQuestion.nom);
							ChangeSequenceString(hLeconProc, idl_ListeQ, nSel, tQuestion.nom);
							{LBSetSel(hListBar, idl_ListeQ, TRUE, nSel);}
							nNum := nNum + nInc;
							if IsDlgButtonChecked(Dialog, 101) = 1 then begin
								nSel := LBGetListNextSel(pListSel);
							end else begin
								Inc(nSel);
								if nSel >= nbSel then nSel := -1;
							end;
						end;
						{PostMessage(hListBar,WM_COMMAND,WORD(idl_ListeQ),MakeLong(0,LBN_SELCHANGE));}
						EndDialog(Dialog, 0);
					end;

				IDCANCEL:
					begin
						EndDialog(Dialog, 0);
					end;
				end;
			end;

	end;

	RenumProc := FALSE;

end;

{*************************************************************}
{                  fonction ToolBarProc                       }
{ SE: fonction de gestion des boutons situés en haut de l'écran}
{ SI: en fonction des boutons cliqués                         }
{*************************************************************}
function ToolBarProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

{*************************************************************}
var lpEnregistreProc	: TFarProc;
		lpOptionsProc			:	TFarProc;
		lpOpenLessonProc	: TFarProc;
		wReturn								 : WORD;
		dwRet									 : DWORD;
		noQuestion, nbQuestion : Integer;
		OldNom : szLongName;
		POldNom : PChar;
		Path: array[0..fsPathName] of Char;
		Dir1: array[0..fsDirectory] of Char;
		Dir2: array[0..fsDirectory] of Char;
		Name: array[0..fsFileName] of Char;
		Ext: array[0..fsExtension] of Char;
		szRessource : szLongName;
		dwReturn : DWORD;
		szLibel : szLongName;
		MciCommandStr		: TMCISTR;
		pTok						: PCHAR;
		hwin		: HWND;
		pt			: TPOINT;
		rc			: TRECT;
		DlgBoxInfo : TDLGBOXINFO;
		SeqProp		 : TSEQPROP;
		lpSeqProp	 : PSEQPROP;
const
		{wRet			: array[0..5] of WORD = (0, 0, 0, 0, 0, 0);}
		wTimer		: WORD = 0;
		lTimer		: longint = 0;
		hCurBut 	: HWND = 0;
		hTip		 	: HWND = 0;
		nTabStop	: integer = 0;
		pt1				: TPOINT = ();
		hBrTip		: HBRUSH = 0;

begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+31, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	ToolBarProc := TRUE;

	GetCursorPos(pt);
	MapWindowPoints(GetDesktopWindow, Dialog, pt, 1);
	hWin := ChildWindowFromPoint(Dialog, pt);
	if hWin = 0 then lTimer := 0;
	if (hWin <> 0) AND
		 (hWin <> Dialog) then begin
		 if (hWin <> hCurBut) then begin
			 hCurBut := hWin;
			 GetWindowText(hCurBut, MciCommandStr, SizeOf(MciCommandStr));
			 SetDlgItemText(hStatusBar, 101, MciCommandStr);
			 if (bWin95 OR bWinNT) then begin
				 if wTimer <> 0 then begin
					 KillTimer(Dialog, wTimer);
					 wTimer := 0;
				 end;
				 if hTip <> 0 then begin
					 DestroyWindow(hTip);
					 DeleteObject(hBrTip);
					 hTip := 0;
					 lTimer := 15;
				 end;
			 end;
		 end;
		 if (bWin95 OR bWinNT) then begin
			 if (wTimer = 0) then begin
				 SetTimer(Dialog, hCurBut, 10, nil);
				 wTimer := hCurBut;
			 end;
		 end;
	end;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of

		WM_CTLCOLOR :
			begin
				if LOWORD(lParam) = hTip then begin
					SetBkMode(HDC(wParam), TRANSPARENT);
					ToolBarProc := BOOL(hBrTip);
					exit;
				end;
			end;

		WM_TIMER :
			begin
				{####
				Exit;
				####}
				GetCursorPos(pt);
				MapWindowPoints(GetDesktopWindow, Dialog, pt, 1);
				hWin := ChildWindowFromPoint(Dialog, pt);
				GetClientRect(Dialog, rc);
				if hWin = wParam then begin
					if lTimer > 15 then begin
						inc(pt.x, 16);
						if hTip = 0 then begin
							MciCommandStr[0] := ' ';
							GetWindowText(hWin, PCHAR(@MciCommandStr[1]), SizeOf(MciCommandStr) - 1);
							pTok := StrPos(MciCommandStr, ':');
							if pTok <> nil then pTok[0] := #0;
							hBrTip := CreateSolidBrush(RGB(255, 255, 128));
							hTip := CreateWindow('STATIC', MciCommandStr,
																	WS_CHILD OR SS_LEFT OR WS_BORDER,
																	0, 0, 0, 0,
																	Dialog,
																	hCurBut,
																	hInstance,
																	nil);
							{SetClassWord(hTip, GCW_STYLE, GetClassWord(hTip, GCW_STYLE) OR CS_SAVEBITS);}
							SendMessage(hTip, WM_SETFONT, hFnt2, 0);
							dc := GetDC(hTip);
							SelectObject(dc, hFnt2);

                                                        //longint(pt1) := GetTabbedTextExtent(dc, MciCommandStr, StrLen(MciCommandStr), 0, nTabStop);
							dwRet := GetTabbedTextExtent(dc, MciCommandStr, StrLen(MciCommandStr), 0, nTabStop);
                                                        pt1.x := LOWORD(dwRet);
                                                        pt1.y := HIWORD(dwRet);

							LPtoDP(dc, pt1, 1);
							inc(pt1.x, 2);
							inc(pt1.y, 2);
							ReleaseDC(hTip, dc);
							if pt.x + pt1.x > rc.right then dec(pt.x, pt1.x + 20);
							if pt.y + pt1.y > rc.bottom then pt.y := rc.bottom - pt1.y;
							SetWindowPos(hTip, 0, pt.x, pt.y, pt1.x, pt1.y, SWP_NOZORDER OR SWP_NOACTIVATE);
							ShowWindow(hTip, SW_SHOWNOACTIVATE);
							{for i := 0 to 5 do begin
								wRet[i] := GetWindowWord(hWin, i);
							end;
							wvsprintf(MciCommandStr, '0=$%.4x 1=$%.4x 2=$%.4x 3=$%.4x 4=$%.4x 5=$%.4x', wRet);
							WriteLn(MciCommandStr);}
						end else begin
							if pt.x + pt1.x > rc.right then dec(pt.x, pt1.x + 20);
							if pt.y + pt1.y > rc.bottom then pt.y := rc.bottom - pt1.y;
							SetWindowPos(hTip, 0, pt.x, pt.y, 0, 0, SWP_NOSIZE OR SWP_NOZORDER OR SWP_NOACTIVATE);
							if (GetWindowWord(hWin, 1) AND $0300) = $0300 then begin
								DestroyWindow(hTip);
								DeleteObject(hBrTip);
								hTip := 0;
								KillTimer(Dialog, wTimer);
								wTimer := 0;
								lTimer := 0;
							end;
							{InvalidateRect(hTip, nil, FALSE);}
						end;
					end else begin
						if (GetWindowWord(hWin, 1) AND $0300) <> $0300 then begin
							inc(lTimer);
						end;
					end;
				end else begin
					DestroyWindow(hTip);
					DeleteObject(hBrTip);
					hTip := 0;
					KillTimer(Dialog, wTimer);
					wTimer := 0;
				end;
			end;

		WM_MOUSEACTIVATE:
			begin
				BringWindowToTop(Dialog);
			end;

		WM_COMMAND:
		begin
			if hTip <> 0 then begin
				DestroyWindow(hTip);
				DeleteObject(hBrTip);
				hTip := 0;
				lTimer := 0;
			end;
			case LoWord(WParam) of

				idb_Nouveau:
					begin
					end;

				idb_Copier:
					begin
						GetDlgItemText(hListBar, idl_Lecon, PropositionName, SizeOf(PropositionName));
						if StrLen(PropositionName) > 0 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@DisposeList), 0, longint(pClipList));
							pClipList := New(PQuestionList);
							FillChar(pClipList^, SizeOf(TQuestionList), 0);
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CopyList), 0, longint(pClipList));
							tClipLecon := tLecon;
							Clip := TRUE;
						end;
					end;

				idb_Couper:
					begin
						GetDlgItemText(hListBar,idl_Lecon,PropositionName,SizeOf(PropositionName));
						if StrLen(PropositionName) > 0 then begin

							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@DisposeList), 0, longint(pClipList));
							pClipList := New(PQuestionList);
							FillChar(pClipList^, SizeOf(TQuestionList), 0);
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CutList), hLeconProc, longint(pClipList));
							tClipLecon := tLecon;
							Clip := TRUE;

						end;
					end;

				idb_Coller:
					if Clip then begin
						GetDlgItemText(hListBar, idl_Lecon, PropositionName, SizeOf(PropositionName));
						if StrLen(PropositionName) > 0 then begin

							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@PasteList), hLeconProc, longint(pClipList));
							tClipLecon := tLecon;
							Clip := TRUE;

						end;
					end;

				idb_Supprimer:
					begin
						GetDlgItemText(hListBar,idl_Lecon,PropositionName,SizeOf(PropositionName));
						if StrLen(PropositionName) > 0 then begin

							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@DisposeList), 0, longint(pUndoList));
							pUndoList := New(PQuestionList);
							FillChar(pUndoList^, SizeOf(TQuestionList), 0);
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CutList), hLeconProc, longint(pUndoList));
							tClipLecon := tLecon;
							Clip := TRUE;

						end;
					end;

				idb_Restaurer :
					begin
						GetDlgItemText(hListBar,idl_Lecon,PropositionName,SizeOf(PropositionName));
						if StrLen(PropositionName) > 0 then begin

							UndoList(hListBar, idl_ListeQ, 0, LongInt(hLeconProc), longint(pUndoList));
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@DisposeList), 0, longint(pUndoList));
							pUndoList := nil;

						end;
					end;

				idb_Numeroter:
					begin
						GetDlgItemText(hListBar,idl_Lecon,PropositionName,SizeOf(PropositionName));
						if StrLen(PropositionName) > 0 then begin
							DialogBox(hInstRes, 'RenumProp', Dialog, DLGPROC(@RenumProc));
						end;
					end;

				6035 :
					begin
						dwRet := SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_GETCOUNT, 0, 0);
						if (dwRet <> LB_ERR) AND (dwRet > 0) then begin;
       						 //lpEnregistreProc := MakeProcInstance(@WavEditProc, HInstance);
						 lpEnregistreProc := @WavEditProc;
						 DialogBox(hInstRes, 'WavEdit', Dialog, DLGPROC(lpEnregistreProc));
						 //FreeProcInstance(lpEnregistreProc);
						end else begin
							MessageBeep(WORD(-1));
						end;
					end;

				idb_Enregistre:
					begin
       					 //lpEnregistreProc := MakeProcInstance(@EnregistreProc, HInstance);
					 lpEnregistreProc := @EnregistreProc;
					 DialogBox(hInstRes, 'enregistre_PRMK', Dialog, DLGPROC(lpEnregistreProc));
					 //FreeProcInstance(lpEnregistreProc);
					 {met à jours la lecon }
					 SendMessage(hListBar, WM_COMMAND, idl_Lecon,
											 MakeLong(GetDlgItem(hListBar, idl_Lecon), CBN_SELCHANGE));
					 SendMessage(hLeconProc, WM_COMMAND, idl_Lecon,
											 MakeLong(GetDlgItem(hLeconProc, idl_Lecon), CBN_SELCHANGE));
					end;

				{ Créer ... }
				6016 :
					begin

						{ Créer : Leçon }
						if IsDlgButtonChecked(hListBar,1200) = 1 then begin
							StrCopy(szLibel, '');
							//lpEnregistreProc := MakeProcInstance(@LibelProc, HInstance);
							lpEnregistreProc := @LibelProc;
							DialogBoxParam(hInstance, 'Libel', Dialog, DLGPROC(lpEnregistreProc), Longint(@szLibel));
							//FreeProcInstance(lpEnregistreProc);
							if szLibel[0] <> #0 then begin
								SetDlgItemText(hListBar, idl_Lecon, szLibel);
								ResetLecon(hListBar);
								NewLesson := TRUE;
								if NewLesson then begin
									OpenLesson(hListBar, tLecon, PropositionNo);
									StrCopy(tLecon.createur, szNomEleve);
									tLecon.bAssist := 0;
									SetLessonRec(PropositionNo, tLecon);
									NewLesson := FALSE;
									PostMessage(hListBar, WM_COMMAND, WORD(idl_Lecon), MakeLong(GetDlgItem(hListBar, idl_Lecon), CBN_SELCHANGE));
									LessonInDlgCombo(hLeconproc, idl_lecon, TRUE);
								end;
							end;
						end;

						{ Créer : Séquence }
						if IsDlgButtonChecked(hListBar, 1206) = 1 then begin
							GetDlgItemText(hListBar, idl_Lecon, PropositionName, SizeOf(PropositionName));
							if StrLen(PropositionName) > 0 then begin
								nbQuestion := LBGetLastSel(hListBar, idl_ListeQ) + 1;
								FillChar(tQuestion, SizeOf(tQuestion), 0);
								GetQuestionRec(nbQuestion, tQuestion);
								CopyLogFont16to32(SeqProp.hLogFnt, tQuestion.hLogFnt);
								SeqProp.BkColRef := tQuestion.BkColRef;
								SeqProp.FrColRef := tQuestion.FrColRef;
								FillChar(tQuestion, SizeOf(tQuestion), 0);
								CopyLogFont32to16(tQuestion.hLogFnt, SeqProp.hLogFnt);
								tQuestion.BkColRef := SeqProp.BkColRef;
								tQuestion.FrColRef := SeqProp.FrColRef;
								GetWindowRect(hGraphiqueProc, rc);
								MapWindowPoints(0, GetParent(hGraphiqueProc), rc, 2);
								tQuestion.gx1 := rc.left;
								tQuestion.gy1 := rc.top;
								tQuestion.gx2 := rc.right;
								tQuestion.gy2 := rc.bottom;
								GetWindowRect(hTexteProc, rc);
								MapWindowPoints(0, GetParent(hTexteProc), rc, 2);
								tQuestion.tx1 := rc.left;
								tQuestion.ty1 := rc.top;
								tQuestion.tx2 := rc.right;
								tQuestion.ty2 := rc.bottom;
								tQuestion.Options := $55;
								tQuestion.wStyle := QS_BMPTOP OR QS_TXTTOP;
								tQuestion.nZoom := 100;
								if nbQuestion + 1 < 10 then
									StrPCopy(tQuestion.Nom, '  '+IntToStr(nbQuestion+1)+' - ')
								else
								StrPCopy(tQuestion.Nom,IntToStr(nbQuestion+1)+' - ');
								StrCopy(szLibel, '');
								//lpEnregistreProc := MakeProcInstance(@LibelProc, HInstance);
								lpEnregistreProc := @LibelProc;
								DialogBoxParam(hInstance, 'Libel', Dialog, DLGPROC(lpEnregistreProc), Longint(@szLibel));
								//FreeProcInstance(lpEnregistreProc);
								StrLCat(tQuestion.Nom, szLibel, SizeOf(tQuestion.Nom) - 7);
								tQuestion.ReponseSon := TRUE;
								PasteQuestionRec(nbQuestion + 1, tQuestion);
								lpSeqProp := new(PSEQPROP);
								if lpSeqProp <> nil then begin
									lpSeqProp^.pszText := StrNew(tQuestion.Nom);
									if lpSeqProp^.pszText = nil then lpSeqProp^.pszText := StrNew(' ');
									CopyLogFont16to32(lpSeqProp^.hLogFnt, tQuestion.hLogFnt);
									lpSeqProp^.FrColRef := tQuestion.FrColRef;
									lpSeqProp^.BkColRef := tQuestion.BkColRef;
									NormalizeSeqProp(lpSeqProp);
									SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_INSERTSTRING, nbQuestion, LongInt(lpSeqProp));
								end;
								lpSeqProp := new(PSEQPROP);
								if lpSeqProp <> nil then begin
									lpSeqProp^.pszText := StrNew(tQuestion.Nom);
									if lpSeqProp^.pszText = nil then lpSeqProp^.pszText := StrNew(' ');
									CopyLogFont16to32(lpSeqProp^.hLogFnt, tQuestion.hLogFnt);
									lpSeqProp^.FrColRef := tQuestion.FrColRef;
									lpSeqProp^.BkColRef := tQuestion.BkColRef;
									NormalizeSeqProp(lpSeqProp);
									SendDlgItemMessage(hListBar, idl_ListeQ, LB_INSERTSTRING, nbQuestion, LongInt(lpSeqProp));
								end;
								LBSetSel(hListBar, idl_ListeQ, FALSE, -1);
								LBSetSel(hListBar, idl_ListeQ, TRUE, nbQuestion);
								PostMessage(hListBar, WM_COMMAND, WORD(idl_ListeQ), MakeLong(0, LBN_SELCHANGE));
							end;
						end;

						{ Créer : Image }
						if IsDlgButtonChecked(hListBar,1201) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CreateImage), hGraphiqueProc, 0);
						end;

						{ Créer : Vidéo }
						if IsDlgButtonChecked(hListBar,1205) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CreateVideo), hGraphiqueProc, 0);
						end;

						{ Créer : Texte }
						if IsDlgButtonChecked(hListBar,1202) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CreateText), hTexteProc, 0);
						end;

						{ Créer : Son }
						if IsDlgButtonChecked(hListBar,1203) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CreateSound), hSonProc, 0);
						end;

						{ Créer : Tuteur }
						If IsDlgButtonChecked(hListBar, 1204) = 1 Then Begin
							{ Création d'un qcm avec génération du nom de fichier (TRUE) }
                                                        {$IFDEF _TUTOR}
							MainQcmWin^.bCreateMode := TRUE;
							PostMessage(window, UM_NEXTQCMCREATE, WORD(MainQcmWin^.bCreateMode), 0);
                                                        {$ENDIF}
						end;
					end;

				{ Prendre ... }
				6017 :
					begin
						{ Prendre : Leçon }
						if IsDlgButtonChecked(hListBar,1200) = 1 then begin
					        	//lpOpenLessonProc := MakeProcInstance(@OpenLessonProc, hInstance);
                                                        lpOpenLessonProc := @OpenLessonProc;
							wReturn := DialogBoxParam(hInstRes, 'OpenLesson', Window, DLGPROC(@lpOpenLessonProc),
								SendDlgItemMessage(hListBar, idl_Lecon, CB_GETCURSEL, 0, 0));
							//FreeProcInstance(lpOpenLessonProc);
							if wReturn <> WORD(-1) then begin
								SendDlgItemMessage(hListBar, idl_Lecon, CB_SETCURSEL, wReturn, 0);
								SendMessage(hListBar, WM_COMMAND, idl_Lecon,
													 MakeLong(GetDlgItem(hListBar, idl_Lecon), CBN_SELCHANGE));
							end else begin
								MessageBox(GetActiveWindow, 'Aucune leçon chargée', 'Attention', MB_OK OR MB_ICONEXCLAMATION);
							end;
						end;

						{ Prendre : Image }
						if IsDlgButtonChecked(hListBar,1201) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@GetImage), hGraphiqueProc, 0);
						end;

						{ Prendre : Video }
						if IsDlgButtonChecked(hListBar,1205) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@GetVideo), hGraphiqueProc, 0);
						end;

						{ Prendre : Texte }
						if IsDlgButtonChecked(hListBar,1202) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@GetText), hTexteProc, 0);
						end;

						{ Prendre : Son }
						if IsDlgButtonChecked(hListBar,1203) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@GetSound), hSonProc, 0);
						end;

						{ Prendre : Tuteur }
						If IsDlgButtonChecked(hListBar, 1204) = 1 Then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@GetTutor), hQCMProc, 0);
						End;
					end;

				{ Modifier ... }
				6018 :
					begin
						if IsDlgButtonChecked(hListBar,1201) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@EditImage), hGraphiqueProc, 0);
						end;

						if IsDlgButtonChecked(hListBar,1205) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@EditVideo), hGraphiqueProc, 0);
						end;

						if IsDlgButtonChecked(hListBar,1202) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@EditText), hTexteProc, 0);
						end;

						if IsDlgButtonChecked(hListBar,1203) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@EditSound), hSonProc, 0);
						end;

						If IsDlgButtonChecked(hListBar, 1204) = 1 Then Begin
							{ Modification de qcm sans génération	du nom de fichier}
                                                        {$IFDEF _TUTOR}
							MainQcmWin^.bCreateMode := FALSE;
							PostMessage(window, UM_NEXTQCMCREATE, WORD(MainQcmWin^.bCreateMode), 0);
                                                        {$ENDIF}
						End
					end;

				{ Lier ... }
				6019 :
					begin
						{ Lier : Image }
						if IsDlgButtonChecked(hListBar,1201) = 1 then begin
							{ On récupère le nom du fichier }
							GetDlgItemText(hGraphiqueProc, 102, PropositionName, SizeOf(PropositionName));
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@LinkImage), hGraphiqueProc, longint(@PropositionName));
						end;

						{ Lier : Vidéo }
						if IsDlgButtonChecked(hListBar,1205) = 1 then begin
							{ On récupère le nom du fichier }
							GetDlgItemText(hGraphiqueProc, 102, PropositionName, SizeOf(PropositionName));
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@LinkVideo), hGraphiqueProc, longint(@PropositionName));
						end;

						{ Lier : Texte }
						if IsDlgButtonChecked(hListBar,1202) = 1 then begin
							{ On récupère le nom du fichier }
							GetDlgItemText(hTexteProc, 102, PropositionName, SizeOf(PropositionName));
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@LinkText), hTexteProc, longint(@PropositionName));
						end;

						{ Lier : Son }
						if IsDlgButtonChecked(hListBar,1203) = 1 then begin
							{ On récupère le nom du fichier }
							GetDlgItemText(hSonProc, 102, PropositionName, SizeOf(PropositionName));
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@LinkSound), hSonProc, longint(@PropositionName));
						end;

						{ Lier : Tuteur }
						If IsDlgButtonChecked(hListBar, 1204) = 1 Then begin
                                                        {$IFDEF _TUTOR}
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@LinkTutor), hQCMProc, longint(@MainQcmWin^.szFichierQ));
                                                        {$ENDIF}

						end;
				end;

				{ Délier ... }
				6020 :
					begin
						{ Délier : Image }
						if IsDlgButtonChecked(hListBar,1201) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@UnlinkImage), hGraphiqueProc, 0);
						end;

						{ Délier : Vidéo }
						if IsDlgButtonChecked(hListBar,1205) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@UnlinkVideo), hGraphiqueProc, 0);
						end;

						{ Délier : Texte }
						if IsDlgButtonChecked(hListBar,1202) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@UnlinkText), hTexteProc, 0);
						end;

						{ Délier : Son }
						if IsDlgButtonChecked(hListBar,1203) = 1 then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@UnlinkSound), hSonProc, 0);
						end;

						{ Délier : Tuteur }
						If IsDlgButtonChecked(hListBar, 1204) = 1 Then begin
							LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@UnlinkTutor), hQCMProc, 0);
						End;
					end;

				119 :
					begin
						//lpOptionsProc := MakeProcInstance(@OptionsProc, HInstance);
						lpOptionsProc := @OptionsProc;
						DlgBoxInfo.hInst := hInstRes;
						StrCopy(DlgBoxInfo.pszName, 'Options_MK');
						DlgBoxInfo.hParent := Window;
						DlgBoxInfo.lpProc := DLGPROC(lpOptionsProc);
						LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CallDialogBoxParam), 0, longint(@DlgBoxInfo));
						//FreeProcInstance(lpOptionsProc);
					end;

				114:
					begin
					 if (IsDlgButtonChecked(hListBar,1201) = 1) OR
							(IsDlgButtonChecked(hListBar,1205) = 1) then begin
       						 //lpOptionsProc := MakeProcInstance(@ImagePropProc, HInstance);
						 lpOptionsProc := @ImagePropProc;
						 DlgBoxInfo.hInst := hInstRes;
						 StrCopy(DlgBoxInfo.pszName, 'ImgProp');
						 DlgBoxInfo.hParent := Window;
						 DlgBoxInfo.lpProc := DLGPROC(lpOptionsProc);
 						LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CallDialogBoxParam), 0, longint(@DlgBoxInfo));
						 //FreeProcInstance(lpOptionsProc);
					 end;

					 if IsDlgButtonChecked(hListBar,1202) = 1 then begin
					         //lpOptionsProc := MakeProcInstance(@TextPropProc, HInstance);
						 lpOptionsProc := @TextPropProc;
						 DlgBoxInfo.hInst := hInstRes;
						 StrCopy(DlgBoxInfo.pszName, 'TxtProp');
						 DlgBoxInfo.hParent := Window;
						 DlgBoxInfo.lpProc := DLGPROC(lpOptionsProc);
 						LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CallDialogBoxParam), 0, longint(@DlgBoxInfo));
						 //FreeProcInstance(lpOptionsProc);
					 end;

					 if IsDlgButtonChecked(hListBar,1203) = 1 then begin
						 //lpOptionsProc := MakeProcInstance(@SoundPropProc, HInstance);
						 lpOptionsProc := @SoundPropProc;
						 DlgBoxInfo.hInst := hInstRes;
						 StrCopy(DlgBoxInfo.pszName, 'SndProp');
						 DlgBoxInfo.hParent := Window;
						 DlgBoxInfo.lpProc := DLGPROC(lpOptionsProc);
 						LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CallDialogBoxParam), 0, longint(@DlgBoxInfo));
						 //FreeProcInstance(lpOptionsProc);
					 end;

					 if IsDlgButtonChecked(hListBar,1204) = 1 then begin
						 //lpOptionsProc := MakeProcInstance(@TutorPropProc, HInstance);
						 lpOptionsProc := @TutorPropProc;
						 DlgBoxInfo.hInst := hInstRes;
						 StrCopy(DlgBoxInfo.pszName, 'TutProp');
						 DlgBoxInfo.hParent := Window;
						 DlgBoxInfo.lpProc := DLGPROC(lpOptionsProc);
 						LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CallDialogBoxParam), 0, longint(@DlgBoxInfo));
						 //FreeProcInstance(lpOptionsProc);
					 end;

					 if IsDlgButtonChecked(hListBar,1206) = 1 then begin
						 //lpOptionsProc := MakeProcInstance(@SeqPropProc, HInstance);
						 lpOptionsProc := @SeqPropProc;
						 DlgBoxInfo.hInst := hInstRes;
						 StrCopy(DlgBoxInfo.pszName, 'SeqProp');
						 DlgBoxInfo.hParent := Window;
						 DlgBoxInfo.lpProc := DLGPROC(lpOptionsProc);
 						LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CallDialogBoxParam), 0, longint(@DlgBoxInfo));
						 //FreeProcInstance(lpOptionsProc);
					 end;

					 if IsDlgButtonChecked(hListBar, 1207) = 1 then begin
						 //lpOptionsProc := MakeProcInstance(@QuestionPropProc, HInstance);
						 lpOptionsProc := @QuestionPropProc;
						 DlgBoxInfo.hInst := hInstRes;
						 StrCopy(DlgBoxInfo.pszName, 'QuestionProp');
						 DlgBoxInfo.hParent := Window;
						 DlgBoxInfo.lpProc := DLGPROC(lpOptionsProc);
 						LBEnumMultiSel(hListBar, idl_ListeQ, TEnumMultiSelProc(@CallDialogBoxParam), 0, longint(@DlgBoxInfo));
						 //FreeProcInstance(lpOptionsProc);
					 end;
					end;

				 6000 { QUIT }:
					 begin
						 PostMessage(Window,WM_CLOSE,0,0);
					 end;

					6034 :
						begin
							WinHelp(window, 'DOCLAVAC.HLP', HELP_CONTENTS, 0);
						end;
			end;
		end;
	end;
	ToolBarProc := FALSE;
end;
{*************************************************************}

{*************************************************************}
function StatusBarProc(Dialog: HWnd; Message, WParam: DWord; LParam: Longint): Bool; stdcall;
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+32, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	StatusBarProc := TRUE;
	case Message of

		WM_INITDIALOG :
			begin
			end;

		WM_DESTROY :
			begin
			end;

	end;
	StatusBarProc := FALSE;
end;

{*************************************************************}
{                  fonction ListBarProc                       }
{ SE: fonction de gestion des leçons (sélections,création,...)}
{ SI: en fonction des messages envoyés aux ressources         }
{*************************************************************}
function ListBarProc(Dialog: HWnd; Message, WParam: DWord;
	LParam: Longint): Bool; stdcall;

{*************************************************************}
var	PathFichierBack : szLongName;
		MciCommandStr		: TMCISTR;
		lpLibelProc : TFarProc;
		szLibel : szLongName;
		pt	: TPOINT;
		r,
		rct : TRECT;
		lOldIndex,
		lIndex : longint;
		nCurSel : integer;
		lg					  : longint;
		action,
		state,
		item					: WORD;
		OldPen				: HPEN;
		OldBrush			: HBRUSH;
		dwReturn			: LONGINT;

const	rCombo : TRECT = ();
			rDlg   : TRECT = ();
			bRDown : boolean = FALSE;
			hWndUpDown	: HWND = 0;
			szText : array[0..255] of char = #0;
			szFormated : array[0..255] of char = #0;
			TabStopPos : array[0..1] of integer = (0, 0);
			hBkBrush	 : HBRUSH = 0;

var lpSeqProp : PSEQPROP;
		hOldFont	: HFONT;
		p					: PCHAR;
		p2				: PCHAR;
		p3				: PCHAR;
		nRet			: integer;
		hIcn			: HICON;
                dwMyRet                 : DWORD;

{*************************************************************}
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+33, Message, wParam, lParam, 'WM_', TRUE);
	{$ENDIF}

	ListBarProc := TRUE;

//        if Message = WM_COMMAND then WmCommand16to32(wParam, lParam);

	case Message of
		wm_InitDialog:
			begin
				Tout := FALSE;
				NewLesson := FALSE;
				CreateurChange := FALSE;
				LibelleChange := FALSE;
				ImageChange := FALSE;
				TexteChange := FALSE;
				SonChange := FALSE;
				RepTexteChange := FALSE;
				RepSonChange := FALSE;

				{sauve position fenêtre}
				GetWindowRect(GetDlgItem(Dialog, 101), rCombo);
				MapWindowPoints(0, Dialog, rCombo, 2);
				Dec(rCombo.right, rCombo.left);
				Dec(rCombo.bottom, rCombo.top);
				if bWin95 then begin
					SendMessage(GetDlgItem(Dialog, idl_Lecon), CB_GETDROPPEDCONTROLRECT, 0 , LongInt(@rCombo));
					MapWindowPoints(HWND_DESKTOP, Dialog, rCombo, 2);
					GetWindowRect(GetDlgItem(Dialog, 206), rct);
					MapWindowPoints(HWND_DESKTOP, Dialog, rct, 2);
					InflateRect(rct, 1, 1);
					hWndUpDown := CreateWindowEx (
									0,
									UPDOWN_CLASS,
									'',
									WS_CHILD {OR WS_BORDER} OR WS_VISIBLE
									{OR UDS_AUTOBUDDY} OR UDS_SETBUDDYINT OR UDS_ARROWKEYS OR UDS_HORZ
									{OR	UDS_WRAP OR UDS_HORZ OR UDS_ARROWKEYS OR UDS_ALIGNRIGHT OR UDS_SETBUDDYINT},
									rct.right + 2, rct.top, (rct.bottom - rct.top) * 3 DIV 2, rct.bottom - rct.top,
									Dialog,
									10001,
									hInstance,
									nil );

					SendMessage( hWndUpDown, UDM_SETBUDDY, GetDlgItem(Dialog, 206), 0 );

					SendMessage( hWndUpDown, UDM_SETRANGE, 0, MAKELONG(999, 0));

					SendMessage( hWndUpDown, UDM_SETPOS, 0, MAKELONG( 0, 0));
				end;

				StrCopy(PathFichier,PathLecons);
				StrCopy(PathFichierBack,PathFichier);{*** et pas l'inverse !!! *** }
				StrCat(PathFichier, 'LECONS.LST');
				StrCat(PathFichierBack, 'LECONS.OLD');
				CopyFile(PathFichier, PathFichierBack);

				LessonInDlgCombo(Dialog, idl_Lecon, FALSE);
			end;

		WM_DESTROY :
			begin
				GetWindowRect(hListBar, r);
				dec(r.right, r.left);
				wvsprintf(szText, '%d', @r.right);
				WritePrivateProfileString('Creator', 'Width', szText, gszIni);
			end;

		WM_SIZE :
			begin
				GetWindowRect(GetDlgItem(hListBar, 102), r);
				MapWindowPoints(0, hListBar, r, 2);
				SetWindowPos(GetDlgItem(hListBar, 102), 0, 0, 0,
										 LOWORD(lParam) - r.left - GetSystemMetrics(SM_CXDLGFRAME) - 2,
										 HIWORD(lParam) - r.top - GetSystemMetrics(SM_CYDLGFRAME) - 2,
										 SWP_NOZORDER OR SWP_NOMOVE);

				GetWindowRect(GetDlgItem(hListBar, 202), r);
				MapWindowPoints(0, hListBar, r, 2);
				SetWindowPos(GetDlgItem(hListBar, 202), 0, 0, 0,
										 LOWORD(lParam) - r.left - GetSystemMetrics(SM_CXDLGFRAME) - 2,
										 r.bottom - r.top,
										 SWP_NOZORDER OR SWP_NOMOVE);
			end;

		WM_CTLCOLOR :
			begin
				if HWND(LOWORD(lParam)) = GetDlgItem(Dialog, 102) then begin
					item := SendDlgItemMessage(Dialog, 102, LB_GETTOPINDEX, 0, 0);
					if integer(item) > integer(LB_ERR) then begin
						lpSeqProp := nil;
						item := SendDlgItemMessage(Dialog, 102,
															LB_GETTEXT,
															item,
															DWORD(@lpSeqProp));
						if integer(item) = integer(LB_ERR) then exit;
						if (lpSeqProp <> nil) AND
							 (lpSeqProp^.hLogFnt.lfFaceName[0] <> #0) then begin
							SetTextColor(HDC(wParam), lpSeqProp^.FrColRef);
							SetBkColor(HDC(wParam), lpSeqProp^.BkColRef);
							DeleteObject(hBkBrush);
							hBkBrush := CreateSolidBrush(lpSeqProp^.BkColRef);
							ListBarProc := BOOL(hBkBrush);
							exit;
						end;
					end;
				end;
			end;

{ TLOGFONT }
{	TMeasureItemStruct = record
		CtlType: Word;
		CtlID: Word;
		itemID: Word;
		itemWidth: Word;
		itemHeight: Word;
		itemData: Longint;
	end;}

		WM_MEASUREITEM :
			begin
				item := PMeasureItemStruct(lParam)^.itemID;
				GetClientRect(GetDlgItem(Dialog, 102), r);
				PMeasureItemStruct(lParam)^.itemWidth := r.right;
				PMeasureItemStruct(lParam)^.itemHeight := 14;
				lpSeqProp := PSEQPROP(PMeasureItemStruct(lParam)^.itemData);
				if (lpSeqProp <> nil) AND
					 (lpSeqProp^.hLogFnt.lfFaceName[0] <> #0) then begin
					if lpSeqProp^.hLogFnt.lfHeight >= 0 then begin
						PMeasureItemStruct(lParam)^.itemHeight := lpSeqProp^.hLogFnt.lfHeight;
					end;
					if lpSeqProp^.hLogFnt.lfHeight > 1000 then begin
						if lpSeqProp^.hLogFnt.lfHeight - 2000 < 0 then begin
							PMeasureItemStruct(lParam)^.itemHeight := 2000 - lpSeqProp^.hLogFnt.lfHeight;
						end else begin
							PMeasureItemStruct(lParam)^.itemHeight := lpSeqProp^.hLogFnt.lfHeight - 2000;
						end;
					end;
					if lpSeqProp^.hLogFnt.lfHeight < 0 then begin
							PMeasureItemStruct(lParam)^.itemHeight := -lpSeqProp^.hLogFnt.lfHeight;
					end;
					dc := GetDC(GetDlgItem(Dialog, 102));
					LPtoDP(dc, PMeasureItemStruct(lParam)^.itemHeight, 1);
					ReleaseDC(GetDlgItem(Dialog, 102), dc);
					PMeasureItemStruct(lParam)^.itemHeight := PMeasureItemStruct(lParam)^.itemHeight * 3 DIV 2;
				end;
		end;

	{TDeleteItemStruct = record
		CtlType: Word;
		CtlID: Word;
		itemID: Word;
		hwndItem: HWnd;
		itemData: Longint;
	end;}
		WM_DELETEITEM :
			begin
				lpSeqProp := PSEQPROP(PDeleteItemStruct(lParam)^.itemData);
				if lpSeqProp <> nil then begin
					StrDispose(lpSeqProp^.pszText);
					Dispose(lpSeqProp);
				end;
			end;

	{TDrawItemStruct = record
		CtlType: Word;
		CtlID: Word;
		itemID: Word;
		itemAction: Word;
		itemState: Word;
		hwndItem: HWnd;
		hDC: HDC;
		rcItem: TRect;
		itemData: Longint;
	end;}

		WM_DRAWITEM :
			begin
				dc := PDrawItemStruct(lParam)^.hDC;
				r := PDrawItemStruct(lParam)^.rcItem;
				item := PDrawItemStruct(lParam)^.itemID;
				action := PDrawItemStruct(lParam)^.itemAction;
				state := PDrawItemStruct(lParam)^.itemState;
				lpSeqProp := PSEQPROP(PDrawItemStruct(lParam)^.itemData);
				if Boolean(action AND ODA_SELECT) OR
					 Boolean(action AND ODA_DRAWENTIRE) then begin
					if Boolean(state AND ODS_SELECTED) then begin
						if (lpSeqProp <> nil) AND
							 (lpSeqProp^.hLogFnt.lfFaceName[0] <> #0) then begin
							OldPen := SelectObject(dc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_HIGHLIGHT)));
							OldBrush := SelectObject(dc, CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)));
							{OldPen := SelectObject(dc, CreatePen(PS_SOLID, 1, NOT lpSeqProp^.BkColRef));
							OldBrush := SelectObject(dc, CreateSolidBrush(NOT lpSeqProp^.BkColRef));}
							Rectangle(dc, r.left, r.top, r.right, r.bottom);
							{SetBkColor(DC, NOT lpSeqProp^.BkColRef);}
							SetBkColor(DC, GetSysColor(COLOR_HIGHLIGHT));
							SetTextColor(DC, NOT lpSeqProp^.FrColRef);
						end else begin
							OldPen := SelectObject(dc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_HIGHLIGHT)));
							OldBrush := SelectObject(dc, CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)));
							Rectangle(dc, r.left, r.top, r.right, r.bottom);
							SetBkColor(DC, GetSysColor(COLOR_HIGHLIGHT));
							SetTextColor(DC, GetSysColor(COLOR_HIGHLIGHTTEXT));
						end;
					end else begin
						if (lpSeqProp <> nil) AND
							 (lpSeqProp^.hLogFnt.lfFaceName[0] <> #0)then begin
							OldPen := SelectObject(dc, CreatePen(PS_SOLID, 1, lpSeqProp^.BkColRef));
							OldBrush := SelectObject(dc, CreateSolidBrush(lpSeqProp^.BkColRef));
							Rectangle(dc, r.left, r.top, r.right, r.bottom);
							SetBkColor(DC, lpSeqProp^.BkColRef);
							SetTextColor(DC, lpSeqProp^.FrColRef);
						end else begin
							OldPen := SelectObject(dc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOW)));
							OldBrush := SelectObject(dc, CreateSolidBrush(GetSysColor(COLOR_WINDOW)));
							Rectangle(dc, r.left, r.top, r.right, r.bottom);
							SetBkColor(DC, GetSysColor(COLOR_WINDOW));
							SetTextColor(DC, GetSysColor(COLOR_MENUTEXT));
						end;
					end;
					DeleteObject(SelectObject(dc, OldBrush));
					DeleteObject(SelectObject(dc, OldPen));
					if (lpSeqProp <> nil) AND (lpSeqProp^.pszText <> nil) then begin
						lg := StrLen(StrCopy(szText, lpSeqProp^.pszText));
					end else begin
						lg := StrLen(StrCopy(szText, ''));
					end;
					if (lpSeqProp <> nil) AND
						 (lpSeqProp^.hLogFnt.lfFaceName[0] <> #0) then begin
							if (lpSeqProp^.hLogFnt.lfHeight > 1000) then begin
								lpSeqProp^.hLogFnt.lfHeight := lpSeqProp^.hLogFnt.lfHeight - 2000;
								hOldFont :=SelectObject(dc, CreateFontIndirect(lpSeqProp^.hLogFnt));
								lpSeqProp^.hLogFnt.lfHeight := lpSeqProp^.hLogFnt.lfHeight + 2000;
							end else begin
								hOldFont :=SelectObject(dc, CreateFontIndirect(lpSeqProp^.hLogFnt));
							end;
							p := StrPos(szText, '#');
							while p <> nil do begin
								p[0] := #9;
								p := StrPos(szText, '#');
							end;
							if HIBYTE(lpSeqProp^.hLogFnt.lfOrientation) = 0 then begin
                                                       	        //longint(pt) := GetTabbedTextExtent(dc, '000 - ', 6, 0, TabStopPos);
							        dwMyRet := GetTabbedTextExtent(dc, '000 - ', 6, 0, TabStopPos);
                                                                pt.x := LOWORD(dwMyRet);
                                                                pt.y := HIWORD(dwMyRet);
								LPtoDP(dc, pt, 1);
								TabStopPos[0] := pt.x + 1;
							end else begin
								TabStopPos[0] := HIBYTE(lpSeqProp^.hLogFnt.lfOrientation);
							end;
							if lg > 0 then begin
								p := StrPos(szText, '-');
								if (LOBYTE(lpSeqProp^.hLogFnt.lfOrientation) > 2) AND
									 (p = nil) then begin
										StrCopy(szFormated, '? - ');
										StrCat(szFormated, szText);
										StrCopy(szText, szFormated);
										p := StrPos(szText, '-');
										lpSeqProp^.hLogFnt.lfOrientation := 0;
								end else begin
									if (p <> nil) then begin
										p[0] := #0;
										if StrLen(szText) > 6 then begin
											p[0] := '-';
											StrCopy(szFormated, '? - ');
											StrCat(szFormated, szText);
											StrCopy(szText, szFormated);
											p := StrPos(szText, '-');
											lpSeqProp^.hLogFnt.lfOrientation := 0;
										end else begin
											p[0] := '-';
											StrCopy(szFormated, szText);
										end;
									end else begin
										StrCopy(szFormated, szText);
									end;
								end;
								if p <> nil then begin
									case LOBYTE(lpSeqProp^.hLogFnt.lfOrientation) of
										0..2 :
											begin
												StrCopy(szFormated, @p[2]);
											end;

										3 :
											begin
												p[0] := #0;
												Val(szText, item, nRet);
												Str(item, szFormated);
												p2 := @szText[0];
												while p2[0] = ' ' do begin
													p2 := @p2[1];
												end;
												p3 := StrPos(p2, ' ');
												if p3 <> nil then p3[0] := #0;
												StrCopy(szFormated, p2);
												StrCat(szFormated, ' -'+#9);
												StrCat(szFormated, @p[2]);
											end;

										4 :
											begin
												StrCopy(szFormated, ''+#9);
												StrCat(szFormated, @p[2]);
											end;

										5 :
											begin
												Str(item + 1, szFormated);
												StrCat(szFormated, ' -'+#9);
												StrCat(szFormated, @p[2]);
											end;

									end;
								end;
								lg := StrLen(szFormated);
								case LOBYTE(lpSeqProp^.hLogFnt.lfOrientation) of
									0 :
										begin
											TabbedTextOut(dc, r.left + 2, r.top, szFormated, lg, 1, TabStopPos, 0);
										end;

									1 :
										begin
											SetTextAlign(dc, TA_CENTER);
											ExtTextOut(dc, (r.right - r.left) DIV 2, r.top, ETO_CLIPPED, @r, szFormated, lg, nil);
											SetTextAlign(dc, TA_LEFT);
										end;

									2 :
										begin
											SetTextAlign(dc, TA_RIGHT);
											ExtTextOut(dc, r.right - TabStopPos[0], r.top, ETO_CLIPPED, @r, szFormated, lg, nil);
											SetTextAlign(dc, TA_LEFT);
										end;

									3..5 :
										begin
											p := StrPos(szFormated, #9);
											if p <> nil then begin
												p[0] := #0;
                                                                                                //
												dwMyRet := GetTabbedTextExtent(dc, szFormated, StrLen(szFormated), 0, TabStopPos);
                                                                                                pt.x := LOWORD(dwMyRet);
                                                                                                pt.y := HIWORD(dwMyRet);

                                                                                                LPtoDP(dc, pt, 1);
												nRet := pt.x;
                                                                                                //
												dwMyRet := GetTabbedTextExtent(dc, ' ', 1, 0, TabStopPos);
                                                                                                pt.x := LOWORD(dwMyRet);
                                                                                                pt.y := HIWORD(dwMyRet);

												LPtoDP(dc, pt, 1);
												inc(nRet, pt.x);
												p[0] := #9;
											end;
											TabbedTextOut(dc, r.left + (TabStopPos[0] - nRet), r.top, szFormated, lg, 1, TabStopPos, 0);
										end;

								end;
								DeleteObject(SelectObject(dc, hOldFont));
								if (lpSeqProp^.hLogFnt.lfHeight > 1000) then begin
									hIcn := LoadIcon(hInstRes, 'ZHidden');
									DrawIcon(dc, r.right-32+7, r.top + ((r.bottom - r.top) DIV 2) - 17, hIcn);
									DestroyIcon(hIcn);
								end;
						end;
					end else begin
						if lg > 0 then begin
							TextOut(dc, r.left + 2, r.top, szText, lg);
						end;
					end;
				end;
			end;

		wm_MouseActivate:
			begin
				BringWindowToTop(Dialog);
			end;

		wm_hScroll:
			begin
				if hiWord(LParam) = GetDlgItem(Dialog, 10000) then Begin
					Case WParam of
						SB_LINEUP:
							Begin
								tQuestion.DureeReponse := tQuestion.DureeReponse - 1;
								if tQuestion.DureeReponse < 0 then tQuestion.DureeReponse := 0;
								SetDlgItemInt(Dialog,1000,tQuestion.DureeReponse,False);
								SetDlgItemInt(Dialog,206,tQuestion.DureeReponse,False);
							end;

						SB_LINEDOWN:
							Begin
								tQuestion.DureeReponse := tQuestion.DureeReponse + 1;
								SetDlgItemInt(Dialog,1000,tQuestion.DureeReponse,False);
								SetDlgItemInt(Dialog,206,tQuestion.DureeReponse,False);
							end;
					end;
				end;
			end;

		{ Seq properties ... }
		WM_USER + 1000 :
			begin
				lIndex := lParam;
				SendDlgItemMessage(Dialog, idl_ListeQ, LB_SETSEL, WORD(TRUE), MAKELONG(lIndex, 0));
				SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_SETSEL, WORD(TRUE), MAKELONG(lIndex, 0));
				DialogBoxParam(hInstRes, 'SeqProp', Dialog, DLGPROC(@SeqPropProc), MAKELONG(WORD(lIndex + 1), 0));
				SendDlgItemMessage(Dialog, idl_ListeQ, LB_SETSEL, WORD(TRUE), MAKELONG(lIndex, 0));
				SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_SETSEL, WORD(TRUE), MAKELONG(lIndex, 0));
			end;

		WM_PARENTNOTIFY :
			begin
                                MessageBox(Dialog, 'WM_PARENTNOTIFY', 'WM_PARENTNOTIFY', MB_OK OR MB_ICONEXCLAMATION);
				case wParam of
					WM_RBUTTONDOWN :
						if NOT bRDown then begin
							bRDown := TRUE;
							//pt := TPOINT(lParam);
                                                        pt.x := LOWORD(lParam);
                                                        pt.y := HIWORD(lParam);
							lIndex := SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETTOPINDEX, 0, 0);
							dwReturn := 0;
							while dwReturn <> LB_ERR do begin
								dwReturn := SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETITEMRECT, lIndex, longint(@rct));
								MapWindowPoints(GetDlgItem(Dialog, idl_ListeQ), Dialog, rct, 2);
								if (pt.x >= rct.left) AND (pt.x <= rct.right) AND
									 (pt.y >= rct.top) AND (pt.y <= rct.bottom) then begin

									PostMessage(Dialog, WM_USER + 1000, 0, lIndex);

									{lOldIndex := SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETCURSEL, 0, 0);
									dwReturn := lIndex + 1;
									GetQuestionRec(dwReturn, tQuestion);
									StrCopy(szLibel, tQuestion.nom);
									lpLibelProc := MakeProcInstance(@LibelProc, HInstance);
									DialogBoxParam(hInstance, 'Libel', Dialog, lpLibelProc, LongInt(@szLibel));
									FreeProcInstance(lpLibelProc);
									StrLCopy(tQuestion.nom, szLibel, SizeOf(tQuestion.nom) - 1);
									SendDlgItemMessage(Dialog,idl_ListeQ,LB_DELETESTRING,WORD(dwReturn-1),DWORD(0));
									SendDlgItemMessage(Dialog,idl_ListeQ,LB_INSERTSTRING,WORD(dwReturn-1),DWORD(@tQuestion.Nom));
									SetQuestionRec(dwReturn,tQuestion);
									ChangeSequenceString(hLeconProc, idl_ListeQ, WORD(dwReturn-1), tQuestion.nom);
									if lOldIndex < 0 then begin
										lOldIndex := dwReturn-1;
									end;
									GetQuestionRec(lOldIndex + 1, tQuestion);
									LBSetSel(Dialog, idl_ListeQ, TRUE, lOldIndex);
									SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_SETSEL, WORD(TRUE), MAKELONG(lOldIndex, 0));}

								end;
								inc(lIndex);
							end;
							bRDown := FALSE;
						end;
				end;
			end;

		wm_Command:
			case LoWord(wParam) of
				1201,
				1205 : PostMessage(hGraphiqueProc, WM_USER, 0, 0);
				1202 : PostMessage(hTexteProc, WM_USER, 0, 0);
				1203 : PostMessage(hSonProc, WM_USER, 0, 0);
				1204 : PostMessage(hQCMProc, WM_USER, 0, 0);

				idl_Lecon:
					begin
						//Case HiWord(LPARAM) of
       						Case HiWord(wParam) of

							{ On déroule la combobox pour choisir une leçon }
							CBN_CLOSEUP:
								begin
									ProcessCloseUp(Dialog, LOWORD(lParam), rDlg, rCombo);

								end;

							CBN_DROPDOWN:
								begin
								{sauve position fenêtre}
								GetWindowRect(Dialog, rDlg);
								MapWindowPoints(0, GetParent(Dialog), rDlg, 2);
								Dec(rDlg.right, rDlg.left);
								Dec(rDlg.bottom, rDlg.top);

								ProcessDropDown(Dialog, LOWORD(lParam), rDlg, rCombo);
									LessonInDlgCombo(Dialog, idl_Lecon, TRUE);
									{ met à jour l'élève aussi }
									LessonInDlgCombo(hLeconProc, idl_Lecon, TRUE);
								end;

							CBN_EDITCHANGE:
								begin
								end;

							CBN_KILLFOCUS:
								begin
								end;

							{ Changement de leçon }
							CBN_SELCHANGE:
								begin

									{WriteLn('CBN_SELCHANGE':15, 'LISTBAR':10, wParam:6, LOWORD(lParam):6, HIWORD(lParam):6);}

									ResetLecon(hListBar);
									UpdateWindow(hListBar);

									PropositionNo := GetCurItemData(hListBar, idl_Lecon) + 1;
									GetLessonRec(PropositionNo, tLecon);

									StrCopy(PathFichier,tLecon.PathLecon);
									StrCat(PathFichier, '\QUESTION.LST');
									FileMode := OF_SHARE_DENY_NONE OR  0;
									Assign(fQuestion, PChar(PathFichier));
									{$i-}
									reset(fQuestion);
									{$i+}

									while (IOResult = 0) AND NOT EOF(fQuestion) do begin
										{$i-}
										Read(fQuestion, tQuestion);
										{$i+}
										if (InOutRes = 0) then begin

											lpSeqProp := new(PSEQPROP);
											if lpSeqProp <> nil then begin
												lpSeqProp^.pszText := StrNew(tQuestion.Nom);
												if lpSeqProp^.pszText = nil then lpSeqProp^.pszText := StrNew(' ');
												CopyLogFont16to32(lpSeqProp^.hLogFnt, tQuestion.hLogFnt);
												lpSeqProp^.FrColRef := tQuestion.FrColRef;
												lpSeqProp^.BkColRef := tQuestion.BkColRef;
												NormalizeSeqProp(lpSeqProp);
											end else begin
												MessageBeep(WORD(-1));
											end;

											SendDlgItemMessage(Dialog,idl_ListeQ,LB_ADDSTRING,0,LongInt(lpSeqProp));
										end;
									end;

									{$i-}
									close(fQuestion);
									{$i+}
									InOutRes := 0;
									FileMode := OF_SHARE_DENY_NONE OR  2;

									SetDlgItemText(hListBar, 104, tLecon.createur);

									{ test si changement lors d'un branchemet }
									if LOWORD(lParam) <> 0 then begin
										{####}
										if LBSetSel(hListBar, idl_ListeQ, TRUE, 0) > LB_ERR then begin
										{####}
											PostMessage(hListBar, WM_COMMAND, WORD(idl_ListeQ), MakeLong(0, LBN_SELCHANGE));
										end;
										{ Change élève aussi }
										dwReturn := SendDlgItemMessage(hListBar, idl_Lecon, CB_GETCURSEL, 0,0);
										SendDlgItemMessage(hLeconProc, idl_Lecon, CB_SETCURSEL, dwReturn,0);
										SendMessage(hLeconProc, WM_COMMAND, WORD(idl_Lecon), MakeLong(0, CBN_SELCHANGE));
									end;
								end;
						end;
					end;

				{ On change de chapitre de la leçon en cours }
				idl_ListeQ:
					begin
						// Case HiWord(LPARAM) of
       						Case HiWord(wParam) of

							LBN_SELCHANGE:
								begin
									{CheckRadioButton(hListBar, 1200, 1207, 1206);}
									{WriteLn('LBN_SELCHANGE':15, 'LISTBAR':10, wParam:6, LOWORD(lParam):6, HIWORD(lParam):6);}

									SetDlgItemText(hStatusBar, 101, '...');
									SetCursor(LoadCursor(0,IDC_WAIT));

									{ Change élève aussi }
									dwReturn :=  SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETCURSEL, 0, LongInt(0)) + 1;
									wReturn := SendDlgItemMessage(Dialog,idl_ListeQ, LB_GETCOUNT, 0, LongInt(0));
									if (LOWORD(lParam) <> WORD(-1)) AND
										 (wReturn > 0) then begin
										SendDlgItemMessage(hLeconProc,idl_ListeQ, LB_SELITEMRANGE,WORD(FALSE),MakeLong(0, wReturn - 1));
									end;
									SendDlgItemMessage(hLeconProc,idl_ListeQ, LB_SETSEL, WORD(TRUE), MakeLong(dwReturn - 1,0));

									{QCM}
									If Not GetQuestionRec(dwReturn, tQuestion) Then begin
										 FillChar (tQuestion, SizeOf (TypeQuestion), 0);
									end;

									{ Rempli les champs avec les noms de fichier correspondant }
									SetDlgItemText(Dialog,202,tQuestion.Nom);
									SetDlgItemText(Dialog,203,tQuestion.FichierGraph);
									SetDlgItemText(Dialog,204,tQuestion.FichierTexte);
									SetDlgItemText(Dialog,205,tQuestion.FichierQuestion);

									if tQuestion.ReponseSon then
										CheckDlgButton(Dialog,207,1)
									else
										CheckDlgButton(Dialog,207,0);

									if tQuestion.ReponseTexte then
										CheckDlgButton(Dialog,208,1)
									else
										CheckDlgButton(Dialog,208,0);

									SetDlgItemInt(Dialog,206,tQuestion.DureeReponse,FALSE);
									SetDlgItemInt(Dialog,1000,tQuestion.DureeReponse,FALSE);

									{On récupère le nom du fichier et on
									le met dans le champ 102 }
									if StrComp(tQuestion.FichierGraph, '')<>0 then begin
										{Traitement vidéo}
										SetDlgItemText(HGraphiqueProc,102,tQuestion.FichierGraph);
										{modifie le caption de la fenêtre bitmap}
										if IsVideoFile(tQuestion.FichierGraph) then begin
											SetWindowText(GetDlgItem(hListBar, 1201), mmLoadString(hInstRes, STR_UNLINKBMP));
											SetWindowText(GetDlgItem(hListBar, 1205), mmLoadString(hInstRes, STR_LINKAVI));
										end else begin
											SetWindowText(GetDlgItem(hListBar, 1205), mmLoadString(hInstRes, STR_UNLINKAVI));
											SetWindowText(GetDlgItem(hListBar, 1201), mmLoadString(hInstRes, STR_LINKBMP));
										end;
									end else begin
										{ Pas d'images, modifie les captions des fenêtres bitmap et vidéo}
										SetWindowText(GetDlgItem(hListBar, 1201), mmLoadString(hInstRes, STR_UNLINKBMP));
										SetWindowText(GetDlgItem(hListBar, 1205), mmLoadString(hInstRes, STR_UNLINKAVI));
									end;

									{ Texte }
									if StrComp(tQuestion.FichierTexte, '') <> 0 then begin
										SetDlgItemText(hTexteProc,102,tQuestion.FichierTexte);
										SetWindowText(GetDlgItem(hListBar, 1202), mmLoadString(hInstRes, STR_LINKTXT));
									end else begin
										SetWindowText(GetDlgItem(hListBar, 1202), mmLoadString(hInstRes, STR_UNLINKTXT));
									end;

									{ Son }
									if StrComp(tQuestion.FichierQuestion, '') <> 0 then begin
										SetDlgItemText(HSonProc,102,tQuestion.FichierQuestion);
										SetWindowText(GetDlgItem(hListBar, 1203), mmLoadString(hInstRes, STR_LINKWAV));
									end else begin
										SetWindowText(GetDlgItem(hListBar, 1203), mmLoadString(hInstRes, STR_UNLINKWAV));
									end;

									{ Un changement de séquence déclenche le chargement du qcm
											s'il y a une liaison}
									If FileExist(tQuestion.FichierQcm) Then Begin
											{WriteLn(tQuestion.FichierQcm);}
											SetWindowText(GetDlgItem(hListBar, 1204), mmLoadString(hInstRes, STR_LINKQCM));
									End Else Begin
											SetWindowText(GetDlgItem(hListBar, 1204), mmLoadString(hInstRes, STR_UNLINKQCM));
									End;

									if LOWORD(lParam) = WORD(-1) then exit;

									{ Jouer cette séquence ... }
									if Pause then SendMessage(hBoutonsProc, WM_COMMAND, idb_Pause, 0);
									if PlayingQ OR
										 PlayingR OR
										 RecordingR then SendMessage(hBoutonsProc, WM_COMMAND, idb_PlayQ, 0);

								 {	CreateScriptBlock(hBoutonsProc, idb_PlayQ, hLeconProc, idl_ListeQ, 1, -1);
									StrCopy(mciMessage, 'END');
									AddMciQueueString(mciMessage);
									StartScript;
									PlayingQ := TRUE;}
									{$IFNDEF _E0}
									{$ENDIF NDEF _E0}
                                                                        // TODO : check wPAram lParam
									PostMessage(hBoutonsProc, WM_COMMAND, idb_PlayQ, MakeLong(GetDlgItem(hBoutonsProc, idb_PlayQ), WORD(-1)));
								End;
						end;
					end;

				{ Champ créateur }
				104:
					begin
						//Case HiWord(LPARAM) of
						Case HiWord(wParam) of
							EN_CHANGE:
								begin
									{####CreateurChange := TRUE;}
								end;

							EN_KILLFOCUS:
								if CreateurChange then begin
									{####dwReturn :=  GetCurItemData(Dialog, idl_Lecon) + 1;
									GetDlgItemText(Dialog,wParam,tLecon.Createur,SizeOf(tLecon.Createur));
									SetLessonRec(dwReturn,tLecon);
									CreateurChange := FALSE;}
								end;
						end;
					end;

				{ Champ Libellé }
				202:
					begin
						//Case HiWord(LPARAM) of
       						Case HiWord(lParam) of
							EN_CHANGE:
								begin
									LibelleChange := TRUE;
								end;
							EN_KILLFOCUS:
								if LibelleChange then begin
									nCurSel :=  SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETCURSEL, 0, LongInt(0)) + 1;
									if GetQuestionRec(nCurSel, tQuestion) then begin
										GetDlgItemText(Dialog, wParam, tQuestion.Nom, SizeOf(tQuestion.Nom));
										ChangeSequenceString(Dialog, idl_ListeQ, WORD(nCurSel-1), tQuestion.nom);
										ChangeSequenceString(hLeconProc, idl_ListeQ, WORD(nCurSel-1), tQuestion.nom);
										LBSetSel(Dialog, idl_ListeQ, TRUE, nCurSel - 1);
										SetQuestionRec(nCurSel, tQuestion);
									end;
									LibelleChange := FALSE;
								end;
						end;
					end;

				{ Champ Image }
				203:
					begin
						//Case HiWord(LPARAM) of
       						Case HiWord(wParam) of

							EN_CHANGE:
								begin
									ImageChange := TRUE;
								end;

							EN_KILLFOCUS:
								if ImageChange then begin
									nCurSel :=  SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETCURSEL, 0, LongInt(0)) + 1;
									if GetQuestionRec(nCurSel, tQuestion) then begin
										GetDlgItemText(Dialog,wParam,tQuestion.FichierGraph,SizeOf(tQuestion.FichierGraph));
										SetQuestionRec(nCurSel,tQuestion);
									end;
									ImageChange := FALSE;
								end;

							EN_SETFOCUS:
								begin
									CheckDlgButton(hListBar, 1201,1);
									CheckDlgButton(hListBar, 1205,0);
									CheckDlgButton(hListBar, 1202,0);
									CheckDlgButton(hListBar, 1203,0);
			 {QCM}      CheckDlgButton(hListBar, 1204,0);
									ShowWindow (hQcmProc, SW_HIDE);
								end;
						end;
					end;

				{ Champ Texte }
				204:
					begin
						//Case HiWord(LPARAM) of
						Case HiWord(wParam) of
							EN_CHANGE:
								begin
									TexteChange := TRUE;
								end;
							EN_KILLFOCUS:
								if TexteChange then begin
									nCurSel :=  SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETCURSEL, 0, LongInt(0)) + 1;
									if GetQuestionRec(nCurSel, tQuestion) then begin
										GetDlgItemText(Dialog,wParam,tQuestion.FichierTexte,SizeOf(tQuestion.FichierTexte));
										SetQuestionRec(nCurSel,tQuestion);
									end;
									TexteChange := FALSE;
								end;
							EN_SETFOCUS:
								begin
									CheckDlgButton(hListBar, 1201,0);
									CheckDlgButton(hListBar, 1202,1);
									CheckDlgButton(hListBar, 1203,0);
			 {QCM}      CheckDlgButton(hListBar, 1204,0);
									ShowWindow (hQcmProc, SW_HIDE);
								end;
						end;
					end;

				{ Champ Son }
				205:
					begin
						//Case HiWord(LPARAM) of
						Case HiWord(wParam) of
							EN_CHANGE:
								begin
									SonChange := TRUE;
								end;

							EN_KILLFOCUS:
								if SonChange then begin
									nCurSel :=  SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETCURSEL, 0, LongInt(0)) + 1;
									if GetQuestionRec(nCurSel, tQuestion) then begin
										GetDlgItemText(Dialog, wParam, tQuestion.FichierQuestion, SizeOf(tQuestion.FichierQuestion));
										SetQuestionRec(nCurSel,tQuestion);
									end;
									SonChange := FALSE;
								end;

							EN_SETFOCUS:
								begin
									CheckDlgButton(hListBar, 1201, 0);
									CheckDlgButton(hListBar, 1202, 0);
									CheckDlgButton(hListBar, 1203, 1);
			 {QCM}      CheckDlgButton(hListBar, 1204, 0);
									ShowWindow (hQcmProc, SW_HIDE);
								end;
						end;
					end;

				{ Champ Durée réponse son }
				206:
					begin
						//Case HiWord(LPARAM) of
						Case HiWord(wParam) of
							EN_CHANGE:
								begin
									nCurSel :=  SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETCOUNT, 0, LongInt(0));
									if nCurSel > 0 then begin
										nCurSel :=  SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETCURSEL, 0, LongInt(0)) + 1;
										if GetQuestionRec(nCurSel, tQuestion) then begin
											GetDlgItemText(Dialog, wParam, szMessage, SizeOf(szMessage));
											Val(szMessage, dwReturn, wReturn);
											tQuestion.DureeReponse := dwReturn;
											SetQuestionRec(nCurSel, tQuestion);
										end;
										RepTexteChange := FALSE;
									end;
								end;
						end;
					end;

				{ Champ Réponse son }
				207:
					begin
						//Case HiWord(LPARAM) of
						Case HiWord(wParam) of
							BN_CLICKED:
								begin
									nCurSel :=  SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETCURSEL, 0, LongInt(0)) + 1;
									GetQuestionRec(nCurSel, tQuestion);
									tQuestion.ReponseSon := Bool(IsDlgButtonChecked(Dialog,wParam));
									SetQuestionRec(nCurSel, tQuestion);
								end;
						end;
					end;

				{ Champ Réponse texte }
				208:
					begin
						//Case HiWord(LPARAM) of
						Case HiWord(wParam) of
							BN_CLICKED:
								begin
									nCurSel :=  SendDlgItemMessage(Dialog, idl_ListeQ, LB_GETCURSEL, 0, LongInt(0)) + 1;
									GetQuestionRec(nCurSel, tQuestion);
									tQuestion.ReponseTexte := Bool(IsDlgButtonChecked(Dialog,wParam));
									SetQuestionRec(nCurSel, tQuestion);
								end;
						end;
					end;
			end;
	end;
	ListBarProc := FALSE;
end;

procedure WriteHexWord(w: Word);
const
  hexChars: array [0..$F] of Char =
    '0123456789ABCDEF';
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+34, 0, 0, 0, nil, TRUE);
	{$ENDIF}

  Write(hexChars[Hi(w) shr 4],
        hexChars[Hi(w) and $F],
        hexChars[Lo(w) shr 4],
				hexChars[Lo(w) and $F]);
end;

{*************************************************************}
{**                    Procédure WinMain                    **}
{** SE: Procédure principale                                **}
{**     Déclaration des classes de fenêtres                 **}
{**                  - fenêtre principale (sans cadre)      **}
{*************************************************************}
procedure WinMain;

{--------------------------------------------------------------------------------------}
var  Message: TMsg;
		 f : file;
		 hLogFnt : Windows.TLOGFONT;
		 nRet		 : integer;
		 szLicence : array[0..255] of char;

                 szXmlUrl : array[0..1024] of char;

{--------------------------------------------------------------------------------------}
const
	{-- Classe de la fenêtre principale --}
	AppClass: TWndClass = (
		style : 0;
		lpfnWndProc: WNDPROC(@WindowProc);
		cbClsExtra: 0;
		cbWndExtra: DLGWINDOWEXTRA;
		hInstance: 0;
		hIcon: 0;
		hCursor: 0;
		hbrBackground: 0;
		lpszMenuName: AppName;
		lpszClassName: 'LAVAC_CR');

	WindowClass: TWndClass = (
		style : 0;
		lpfnWndProc: WNDPROC(@WindowProc);
		cbClsExtra: 0;
		cbWndExtra: DLGWINDOWEXTRA;
		hInstance: 0;
		hIcon: 0;
		hCursor: 0;
		hbrBackground: 0;
		lpszMenuName: nil;
		lpszClassName: AppName);

	AppWin : HWND = 0;

{var
		task 						: TTaskEntry;
		hTask						: THANDLE;
		DGROUP					: DWORD;
		szDGROUP				: ARRAY[0..32] of char;
const
		p								: PCHAR = nil;}

{--------------------------------------------------------------------------------------}
begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+35, 0, 0, 0, nil, TRUE);
	{$ENDIF}


{	Write('The current code segment is $');
	WriteHexWord(CSeg); Writeln;
	Write('The global data segment is $');
	WriteHexWord(DSeg); Writeln;
	Write('The stack segment is $');

	WriteHexWord(SSeg); Writeln;
	Write('The stack pointer is at $');
	WriteHexWord(SPtr); Writeln;
	Write('PathLecons is at offset $');
	WriteHexWord(Ofs(PathLecons));
	Write(' in segment $');
	WriteHexWord(Seg(PathLecons));WriteLn;

	hTask	:= GetCurrentTask;
	Task.dwSize := SizeOf(TTaskEntry);
	TaskFindHandle(@Task, hTask);
	DGROUP := Task.hInst;
	wvsprintf(szDGROUP, '%X', DGROUP);
	WriteLn(Task.szModule, ' ', szDGROUP,' ', Task.wPSPOffset);}

{$IFDEF _E0}  { Créateur... }
	NoELEV := 0;             { Numéro d'élèves      }
	StrCopy(ELEVE, '0');     { N                    }
{$ENDIF}

	hTexteProc := 0;
	hfnt  := 0;
	hFnt2 := 0;
	hRichedLib := 0;

	{ Classes de controls externes }

{$IFNDEF _DEBUG}
	Ctl3dRegister(hInstance);
	Ctl3dAutoSubclass(hInstance);
{$ENDIF}

{$IFDEF _ASSIST}
	licSetType(ST_MMWIZARD);
	nNum := GetPrivateProfileInt('NETWORK', 'PC', 0, szAPPINI[ST_MMWIZARD]);
	if nNum = 0 then nNum := NoElev;
	licSetNum(nNum);
{$ENDIF}

	StrCopy(szLicence, PathLavac);
	StrCat(szLicence, 'LAVAC.LIC');
	{licRequest(window, szLicence);
	MessageBox(window, licGetCode(window, szLicence, 10), 'Code Site', MB_OK);}
	{if NOT licVerify(window, szLicence) then begin
		Halt(0);
	end;}

{ACK TOULOUSE}
if GetPrivateProfileInt('OPTIONS', 'LARGELIST', 0, gszIni) <> 1 then begin

{$IFNDEF _ASSIST}
	if (NoELEV > licGetNumStud(0, szLicence)) OR
		 (NoELEV < 0) then begin
		MessageBeep(0);
		MessageBox(0, 'Numéro d''étudiant trop élevé pour la licence acquise.' + #13 + #10 +
									'Valeur STATION invalide dans section [NETWORK] de Lavac.ini',
									'Protection', MB_APPLMODAL OR MB_ICONSTOP);
		Halt(0);
	end;
{$ENDIF}

end;



	if HPrevInst = 0 then
	begin
		hInstRes := hInstance;

		{--  spécifications de la classe AppClass --}
		AppClass.hInstance := HInstance;
		AppClass.hIcon := LoadIcon(HInstRes, AppName);
		AppClass.hCursor := LoadCursor(0, idc_Arrow);
		AppClass.hbrBackground := GetStockObject(DKGRAY_BRUSH); {COLOR_BACKGROUND + 1;}
		if RegisterClass(AppClass) = 0 then Halt(0);

		{--  spécifications de la classe VideoWindowClass --}
		WindowClass.hInstance := HInstance;
		WindowClass.hIcon := LoadIcon(HInstRes, AppName);
		WindowClass.hCursor := LoadCursor(0, idc_Arrow);
		WindowClass.hbrBackground := COLOR_APPWORKSPACE + 1;
		if RegisterClass(WindowClass) = 0 then Halt(0);

	end else begin
		MessageBeep(0);
{$IFDEF _E0}  { Créateur... }
		BringWindowToTop(FindWindow('LAVAC_CR', 'LAVAC Créateur'));
{$ELSE}
		BringWindowToTop(FindWindow(AppName, AppName));
{$ENDIF}
		Halt(0);
	end;

	Ctl3dUnregister(hInstance);

	SetMessageQueue(120);

	{ Classes de controls externes }
	{$IFDEF _RICHED}
	{$ENDIF} {_RICHED}

	{$IFDEF _DEBUG}
	hRichedLib := GetModuleHandle('RICHED32.DLL');
	while hRichedLib > HINSTANCE_ERROR do begin
		FreeLibrary(hRichedLib);
		hRichedLib := GetModuleHandle('RICHED32.DLL');
	end;
	{$ENDIF}

	hRichedLib := LoadLibrary('RICHED32.DLL');
	if hRichedLib < HINSTANCE_ERROR then messageBeep(word(-1));

	Ctl3dRegister(hInstance);
	Ctl3dAutoSubclass(hInstance);

	GetWindowRect(GetDesktopWindow, rcApp);
        rcApp.Left := 0; //(rcApp.Right DIV 4) * 3;
        rcApp.Top := 0; //(rcApp.Bottom DIV 4) * 3;
        rcApp.Right := (rcApp.Right DIV 3) * 2;
        rcApp.Bottom := (rcApp.Bottom DIV 3) * 2;
	//ClipCursor(@rcApp);

	hListBar := 0;

	with hLogFnt do begin
	 lfHeight:= -11;
	 lfWidth:= 0;
	 lfEscapement:= 0;
	 lfOrientation:= 0;
	 lfWeight:= FW_BOLD {FW_NORMAL};
	 lfItalic:= 0;
	 lfUnderline:= 0;
	 lfStrikeOut:= 0;
	 lfCharSet:= 0;
	 lfOutPrecision:= 3;
	 lfClipPrecision:= 2;
	 lfQuality:= 1;
	 lfPitchAndFamily:= 34;
	 StrCopy(lfFaceName, 'Arial');
	end;
	hfnt := CreateFontIndirect(hLogFnt);

	with hLogFnt do begin
	 lfHeight:= -11;
	 lfWidth:= 0;
	 lfEscapement:= 0;
	 lfOrientation:= 0;
	 lfWeight:= FW_NORMAL;
	 lfItalic:= 0;
	 lfUnderline:= 0;
	 lfStrikeOut:= 0;
	 lfCharSet:= 0;
	 lfOutPrecision:= 3;
	 lfClipPrecision:= 2;
	 lfQuality:= 1;
	 lfPitchAndFamily:= 34;
	 StrCopy(lfFaceName, 'Arial');
	end;
	hFnt2 := CreateFontIndirect(hLogFnt);

{$IFDEF _E0}  { Créateur... }
if (bWin95 OR bWinNT) then begin
	AppWin := CreateWindow(
		'LAVAC_CR',
		'LAVAC Créateur',
		WS_POPUP OR WS_CLIPCHILDREN OR WS_CAPTION OR WS_SYSMENU OR WS_MINIMIZEBOX OR WS_MAXIMIZEBOX,
		0,
		0,
		rcApp.right,
		rcApp.bottom,
		0,
		0,
		HInstance,
		nil);
end else begin
	AppWin := CreateWindow(
		'LAVAC_CR',
		'LAVAC Créateur',
		WS_OVERLAPPEDWINDOW OR WS_CLIPCHILDREN OR WS_CLIPSIBLINGS OR WS_MAXIMIZE,
		0,
		0,
		rcApp.right,
		rcApp.bottom,
		0,
		0,
		HInstance,
		nil);
end;

	lpToolBarProc := MakeProcInstance(@ToolBarProc, hInstance);
	hToolBar := CreateDialog(hInstRes, 'ToolBar', AppWin, lpToolBarProc);
	GetClientRect(AppWin, rcApp);
	GetWindowRect(hToolBar, rcToolBar);
	MapWindowPoints(0, AppWin, rcToolBar, 2);
if (bWin95 OR bWinNT) then begin
	SetWindowPos(hToolBar, 0, rcApp.left, rcApp.top,
														rcApp.right - rcApp.left + 3,  rcToolBar.bottom - rcToolBar.top,
														SWP_NOZORDER);
end else begin
	SetWindowPos(hToolBar, 0, rcApp.left, rcApp.top,
														rcApp.right - rcApp.left,  rcToolBar.bottom - rcToolBar.top,
														SWP_NOZORDER);
end;
	GetWindowRect(hToolBar, rcToolBar);
	MapWindowPoints(0, AppWin, rcToolBar, 2);

	GetClientRect(AppWin, rcApp);
	lpStatusBarProc := MakeProcInstance(@StatusBarProc, hInstance);
	hStatusBar := CreateDialog(hInstRes, 'StatusBar', AppWin, lpStatusBarProc);
	if hfnt <> 0 then SendDlgItemMessage(hStatusBar, 101, WM_SETFONT, hfnt, 0);
	GetWindowRect(hStatusBar, rcStatusBar);
	MapWindowPoints(0, AppWin, rcStatusBar, 2);
	SetWindowPos(hStatusBar, 0, rcApp.left, rcApp.bottom - rcStatusBar.bottom + rcStatusBar.top,
																 rcApp.right - rcApp.left,  rcStatusBar.bottom - rcStatusBar.top,
																 SWP_NOZORDER);
	GetWindowRect(hStatusBar, rcStatusBar);
	MapWindowPoints(0, AppWin, rcStatusBar, 2);
	hItem := GetDlgItem(hStatusBar, 102);
	GetWindowRect(hItem, rcItem);
	MapWindowPoints(0, AppWin, rcItem, 2);
	SetWindowPos(hItem, 0, 0, 0,
												 rcStatusBar.right - rcItem.left - GetSystemMetrics(SM_CXDLGFRAME) - 1,
												 rcStatusBar.bottom - rcItem.top - GetSystemMetrics(SM_CYDLGFRAME) - 1,
												 SWP_NOZORDER OR SWP_NOMOVE);

	GetClientRect(AppWin, rcApp);
	lpListBarProc := MakeProcInstance(@ListBarProc, hInstance);
	hListBar := CreateDialog(hInstRes, 'ListBar', AppWin, lpListBarProc);
	CheckRadioButton(hListBar, 1200, 1207, 1200);
	GetWindowRect(hListBar, rcListBar);
	nRet := GetPrivateProfileInt('Creator', 'Width', rcListBar.right, gszIni);
	if nRet <> rcListBar.right then begin
		rcListBar.right := rcListBar.left + nRet;
	end;
	MapWindowPoints(0, AppWin, rcListBar, 2);
	SetWindowPos(hListBar, 0, rcApp.left, rcToolBar.bottom,
																 rcListBar.right - rcListBar.left,
																 rcStatusBar.top - rcToolBar.bottom,
																 SWP_NOZORDER);
	GetWindowRect(hListBar, rcListBar);
	MapWindowPoints(0, AppWin, rcListBar, 2);
	{hItem := GetDlgItem(hListBar, 102);
	GetWindowRect(hItem, rcItem);
	MapWindowPoints(0, AppWin, rcItem, 2);
	SetWindowPos(hItem, 0, 0, 0,
												 rcListBar.right - rcItem.left - GetSystemMetrics(SM_CXDLGFRAME) - 2,
												 rcListBar.bottom - rcItem.top - GetSystemMetrics(SM_CYDLGFRAME) - 2,
												 SWP_NOZORDER OR SWP_NOMOVE);}

	{ Si la Frame ne contient pas le Module élève => Ascensseurs }
	if ((rcApp.right - rcListBar.right) < LAVACWIDTH) OR
		 ((rcStatusBar.top - rcToolBar.bottom) < LAVACHEIGHT) then begin

		FrameWin := CreateWindow(
			'LAVAC_CR',
			'Frame',
			WS_CHILD OR WS_CLIPCHILDREN OR WS_CLIPSIBLINGS OR WS_VISIBLE OR WS_HSCROLL OR WS_VSCROLL,
			rcListBar.right,
			rcToolBar.bottom,
			rcApp.right - rcListBar.right,
			rcStatusBar.top - rcToolBar.bottom,
			AppWin,
			0,
			HInstance,
			nil);

		GetClientRect(FrameWin, rcApp);
		Window := CreateWindow(
			AppName,
			AppName,
			WS_CHILD OR WS_CLIPCHILDREN OR WS_CLIPSIBLINGS OR WS_VISIBLE OR WS_BORDER,
			32,
			32,
			LAVACWIDTH + 2,
			LAVACHEIGHT + 2,
			FrameWin,
			0,
			HInstance,
			nil);

		SetScrollRange(FrameWin, SB_HORZ, 0, LAVACWIDTH - (rcApp.right - rcApp.left) + 64, TRUE);
		SetScrollRange(FrameWin, SB_VERT, 0, LAVACHEIGHT - (rcApp.bottom - rcApp.top) + 64, TRUE);
	end else begin
		{FrameWin := CreateWindow(
			'LAVAC_CR',
			'Frame',
			WS_CHILD OR WS_CLIPCHILDREN OR WS_CLIPSIBLINGS OR WS_VISIBLE,
			rcListBar.right,
			rcToolBar.bottom,
			rcApp.right - rcListBar.right,
			rcStatusBar.top - rcToolBar.bottom,
			AppWin,
			0,
			HInstance,
			nil);}

		GetClientRect(AppWin, rcApp);
		inc(rcApp.left, rcListBar.right - rcListBar.left);
		inc(rcApp.top, rcToolBar.bottom - rcToolBar.top);
		dec(rcApp.bottom, rcStatusBar.bottom - rcStatusBar.top);
		Window := CreateWindow(
			AppName,
			AppName,
			WS_CHILD OR WS_CLIPCHILDREN OR WS_CLIPSIBLINGS OR WS_VISIBLE OR WS_BORDER,
			rcApp.left + (rcApp.right - rcApp.left - LAVACWIDTH) DIV 2,
			rcApp.top + (rcApp.bottom - rcApp.top - LAVACHEIGHT) DIV 2,
			LAVACWIDTH + 2,
			LAVACHEIGHT + 2,
			{FrameWin,}
			AppWin,
			0,
			HInstance,
			nil);
	end;

		{-- Affiche la fenêtre de l'application --}
if (bWin95 OR bWinNT) then begin
		ShowWindow(AppWin, SW_SHOW);
end else begin
		ShowWindow(AppWin, SW_SHOWMAXIMIZED);
end;
		UpdateWindow(AppWin);
{$ELSE}

	Window := CreateWindow(
		AppName,
		AppName,
		WS_POPUP OR WS_CLIPCHILDREN,
                //WS_OVERLAPPEDWINDOW OR WS_CLIPCHILDREN,
		0,
		0,
		rcApp.right,
		rcApp.bottom,
		0,
		0,
		HInstance,
		nil);

		{-- Affiche la fenêtre de l'application --}
		ShowWindow(Window, SW_SHOW);
		//ShowWindow(Window, SW_SHOWMAXIMIZED);
		//UpdateWindow(Window);
		{ force la taille de fenêtre désirée }
                //SetWindowPos(Window, 0, 100, 100, rcApp.right, rcApp.bottom, SWP_NOZORDER OR SWP_NOSIZE);
{$ENDIF}


	{-- Met le curseur sablier pour l'initialisation de l'application --}
	SetCursor(LoadCursor(0,IDC_WAIT));

	PlayingMessage := FALSE;
	VideoPlaying := FALSE;
	VideoPlaying := TRUE;

	{--Creation de la dialogue dialogue--}
	{InitEtudiant (Window, 'ELEVE'); }

	{-- Création de la dialogue bouton --}
	lpBoutonsProc := TFARPROC(MakeProcInstance(LongInt(@BoutonsProc), hInstance));
	hBoutonsProc := CreateDialog(hInstRes, 'Boutons_EL',Window,DLGPROC(lpBoutonsProc));

	hDiagram := CreateSolidBrush(RGB(55, 226, 55)); //RGB(0,0,255));
	hFond := CreateSolidBrush(RGB(0,0,64));

	//hLed_J := LoadIcon(hInstRes, 'LED_J');
	//hLed_N := LoadIcon(hInstRes, 'LED_N');
	//hLed_R := LoadIcon(hInstRes, 'LED_R');
	//hLed_V := LoadIcon(hInstRes, 'LED_V');
        //hLed_J := LoadImage(0, 'C:\LAVAC\ico\Franksouza183-Fs-Status-tray-away.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
        hLed_J := LoadImage(0, 'C:\LAVAC\ico\YELLOW.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
        //hLed_N := LoadImage(0, 'C:\LAVAC\ico\Franksouza183-Fs-Status-tray-offline.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
        hLed_N := LoadImage(0, 'C:\LAVAC\ico\GREY.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
        //hLed_R := LoadImage(0, 'C:\LAVAC\ico\Franksouza183-Fs-Status-tray-busy.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
        hLed_R := LoadImage(0, 'C:\LAVAC\ico\RED.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
        //hLed_V := LoadImage(0, 'C:\LAVAC\ico\Franksouza183-Fs-Status-tray-online.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);
        hLed_V := LoadImage(0, 'C:\LAVAC\ico\GREEN.ico', IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR or LR_LOADFROMFILE);


	{-- Création de la dialogue Lecon --}
	lpLeconProc := TFARPROC(MakeProcInstance(LongInt(@LeconProc), hInstance));
	if GetPrivateProfileInt('OPTIONS', 'LARGELIST', 0, gszIni) = 1 then begin
		hLeconProc := CreateDialog(hInstRes, 'Lecon_EL2',Window,DLGPROC(lpLeconProc));
	end else begin
		hLeconProc := CreateDialog(hInstRes, 'Lecon_EL',Window,DLGPROC(lpLeconProc));
	end;
	if hfnt <> 0 then begin
		SendDlgItemMessage(hLeconProc, 101, WM_SETFONT, hfnt, 0);
		SendDlgItemMessage(hLeconProc, 102, WM_SETFONT, hfnt, 0);
	end;

	{-- Création de la dialogue Graphique --}
	lpGraphiqueProc := TFARPROC(MakeProcInstance(LongInt(@GraphiqueProc), hInstance));
	hGraphiqueProc := CreateDialog(hInstRes, 'Graphique_EL',Window,DLGPROC(lpGraphiqueProc));
	FlashWindow(hGraphiqueProc, TRUE);

	{-- Création de la dialogue Texte --}
	lpTexteProc := TFARPROC(MakeProcInstance(LongInt(@TexteProc), hInstance));
	hTexteProc := CreateDialog(hInstRes, 'Texte_EL',Window,DLGPROC(lpTexteProc));
{	hTexteProc := CreateDialog(hInstRes, 'Text',Window,lpTexteProc);}
	if hfnt <> 0 then SendDlgItemMessage(hTexteProc, 101, WM_SETFONT, hfnt, 0);
	FlashWindow(hTexteProc, TRUE);

	{ Dialogue son }
	lpSonProc := TFARPROC(MakeProcInstance(LongInt(@SonProc), hInstance));
	hSonProc := CreateDialog(hInstRes, 'Son_PRMK',Window,DLGPROC(lpSonProc));
	FlashWindow(hSonProc,TRUE);

	{QCM}
	{-- création de la fenêtre QCM --}
        {$IFDEF _TUTOR}
	QcmAppli.Init(AppName);
	InitOleAndStream;
	lpQcmProc  := TFARPROC(MakeProcInstance (LongInt(@QcmProc), hInstance));
	{ Créer la fenêtre QCM Lavac non visible au départ}
	hQcmProc := CreateDialog(hInstance, 'QCM_EL',Window, DLGPROC(lpQcmProc));
	{ Modification du menu système}
	DeleteMenu (GetSystemMenu (hQcmProc, FALSE), 5, MF_BYPOSITION);{séparateur}
	DeleteMenu (GetSystemMenu (hQcmProc, FALSE), 5, MF_BYPOSITION);{fermeture}
	DeleteMenu (GetSystemMenu (hQcmProc, FALSE), 5, MF_BYPOSITION);{séparateur}
	DeleteMenu (GetSystemMenu (hQcmProc, FALSE), 5, MF_BYPOSITION);{basculer vers}
	AppendMenu (GetSystemMenu (hQcmProc, FALSE), MF_SEPARATOR, 0, Nil);
        {$ELSE}
        hQcmProc := 0;
        {$ENDIF}
{$IFDEF _E0}  { Créateur... }
	AppendMenu (getSystemMenu (hQcmProc, FALSE), MF_STRING, 3, mmLoadString(hInstRes, STR_QCMEDIT));
	AppendMenu (GetSystemMenu (hQcmProc, FALSE), MF_STRING, 2, mmLoadString(hInstRes, STR_QCMHIDE));
	AppendMenu (getSystemMenu (hQcmProc, FALSE), MF_STRING, 4, mmLoadString(hInstRes, STR_TOLINK));
{$ELSE}
	AppendMenu (getSystemMenu (hQcmProc, FALSE), MF_STRING, 1, mmLoadString(hInstRes, STR_NEXT));
{$ENDIF}
	if hQcmProc <> 0 then FlashWindow(hQcmProc, TRUE);

        {$IFDEF _TUTOR}
	{ Création de la fenêtre MainqcmWin, fenêtre Objet}
	lpToolBarIF := nil;
	{lpToolBarIF := New (POWLIF, Init(hToolBar, 'ToolBarIF'));
	if lpToolBarIF <> nil then lpToolBarIF^.Create;}

	If lpQcmMkWin = Nil Then
	 (New (PWinMk, Init(hQcmProc, 'QcmIF')))^.Create;

	{(New (PEleveWin, Init (Nil, 'qcmwindow', hQcmProc, M_ELEV)))^.MkCreate (hQcmProc);}

        {$IFDEF _E0}  { Créateur... }
	{ On sauvegarde les déplacements des fenêtres élèves }
	MainQcmWin^.bSizable := TRUE;
        {$ENDIF}
{$ENDIF}

 {(New (PEleveWin, Init (Nil, 'qcmwindow', hQcmProc, M_ELEV)))^.MkCreate (hQcmProc);}
	{-- création de la dialogue MCIQUEUE --}
	lpMciQueueProc := TFARPROC(MakeProcInstance(LongInt(@MciQueueProc), hInstance));
	hMciQueueProc := CreateDialog(hInstRes, 'MCIQUEUE_ELPRMK',Window,DLGPROC(lpMciQueueProc));
	InitMciQueue;

        //
	//ShowWindow(hMciQueueProc, SW_SHOW);

	{-- initialisation des timers --}
	SetDlgItemText(hLeconProc,5000,SystemTime);

	SetDlgItemInt(hLeconProc,5001,NoElev,FALSE);

	{-- Gestion du son SoundBlaster --}
	UpdateSbpMixBaseAddr;
	SetSbpMixFilter(SbpMixNoFilter);
	SetSbpMixSource(SbpMixMic);

	{-- Init Diadir nBios --}
{$IFNDEF _E0}  { Pas Créateur... }
	StrPCopy(szMessage, IntToStr(NoElev));
	{StrCat(szMessage, 'LAVAC');}
	//lpAttenteProc := TFARPROC(MakeProcInstance(LongInt(@AttenteProc), HInstance));
	//hAttenteProc := CreateDialog(hInstRes, 'ATTENTE_EL', Window, DLGPROC(lpAttenteProc));
	//if bNetBios then InitEtudiant(Window, szMessage);
	//DestroyWindow(hAttenteProc);
	//FreeProcInstance(lpAttenteProc);
{$ENDIF}  { Pas Créateur... }

	if bFTP then SetDlgItemText(hBoutonsProc, 606, 'Envoyer');

	{-- Affichage de la dialogue de début de session --}
	lpMessagesProc := TFARPROC(MakeProcInstance(LongInt(@MessagesProc), HInstance));
	DialogBox(hInstRes, 'ABOUTSTART_EL', Window, DLGPROC(lpMessagesProc));
	//FreeProcInstance(lpMessagesProc);

	BringWindowToTop(hGraphiqueProc);
	BringWindowToTop(hTexteProc);

	{$IFNDEF _E0}
	{StrCopy(tLecon.Nom, 'Menu');}
	StrCopy(tLecon.Nom, szStartLesson);
	dwReturn := SendDlgItemMessage(hLeconproc, idl_Lecon, CB_FINDSTRINGEXACT, 0, DWORD(@tLecon.Nom));
	if dwReturn <> LB_ERR then begin
		SendDlgItemMessage(hLeconproc, idl_Lecon, CB_SETCURSEL, WORD(dwReturn), 0);
		SendMessage(hLeconProc, WM_COMMAND, idl_Lecon,
								MakeLong(GetDlgItem(hLeconProc, idl_Lecon), CBN_SELCHANGE));
	end;
	{$ENDIF}  { Pas Créateur... }

        //SetWindowPos(Window, 0, 100, 200, rcApp.right-100, rcApp.bottom-200, SWP_NOZORDER);
        //GetClientRect(Window, rcApp);

        GetPrivateProfileString('LAVAC64', 'WRITER_PATH', 'C:\Program Files (x86)\OpenOffice 4\program\swriter.exe', szWriterApp, SizeOf(szWriterApp), gszIni);
        GetPrivateProfileString('LAVAC64', 'NOTES_TEMPLATE', 'C:\LAVAC\Textes\notes.rtf', szNotesTemplateRtf, SizeOf(szNotesTemplateRtf), gszIni);
        GetPrivateProfileString('LAVAC64', 'LESSON_DESC_URL', 'http://oai.iutenligne.net/ori-oai/OAIHandler?verb=ListRecords&metadataPrefix=lom&set=domaine:26568', szXmlUrl, SizeOf(szXmlUrl), gszIni);
        GetPrivateProfileString('LAVAC64', 'LESSON_DESC_PATH', 'C:\LAVAC\xml\lessons.xml', szXmlFile, SizeOf(szXmlFile), gszIni);
        if Not FileExist(szXmlFile) then begin
           //MessageBox(Window, 'bip', 'xml', MB_OK OR MB_APPLMODAL OR MB_ICONSTOP);
           GetUrlContent(szXmlUrl, szXmlFile);
        end;

        hDescWin :=  CreateWindow(
		'STATIC',
		'',
		WS_CHILD OR WS_POPUP OR WS_BORDER OR WS_THICKFRAME, // OR WS_VISIBLE,
		rcApp.right div 2,
		0,
		(rcApp.right * 2) div 3,
		rcApp.bottom div 3,
		hLeconProc, //Window,
		0,
		HInstance,
		nil);
        SendMessage(hDescWin, WM_SETFONT, hfnt, 0);

        //sXml := LoadXml(szXmlFile);
        //MessageBox(Window, PChar(sXml), 'xml', MB_OK OR MB_APPLMODAL OR MB_ICONSTOP);

	{-- Boucle principale --}
	while GetMessage(Message, 0, 0, 0) do begin

	{$IFDEF _E0}  { Créateur... }
		{ On ne change pas de leçon avec l'élève... }
		if IsWindowEnabled(GetDlgItem(hLeconProc, idl_Lecon)) then begin
			EnableWindow(GetDlgItem(hLeconProc, idl_Lecon), FALSE);
		end;
	{$ENDIF}

		if NOT((hBoutonsProc <> 0) AND IsDialogMessage(hBoutonsProc,Message)) AND
			 NOT((hGraphiqueProc <> 0) AND IsDialogMessage(hGraphiqueProc,Message)) AND
			 NOT((hTexteProc <> 0) AND IsDialogMessage(hTexteProc,Message)) AND
			 NOT((hRepTexte <> 0) AND IsDialogMessage(hRepTexte,Message)) AND
			 NOT((hLeconProc <> 0) AND IsDialogMessage(hLeconProc,Message)) then begin
			TranslateMessage(Message);
			DispatchMessage(Message);
		end;
	end;

	if hfnt <> 0 then DeleteObject(hfnt);
	hfnt := 0;

	if hFnt2 <> 0 then DeleteObject(hFnt2);
	hfnt2 := 0;

	Ctl3dUnregister(hInstance);
	if hRichedLib <> 0 then FreeLibrary(hRichedLib);
	hRichedLib := 0;

	Halt(Message.wParam);
end;

{$R-}

procedure MyExitProc; far;
const
	szError : array[0..255] of char = '';
	psz			: PCHAR = nil;
	ErrCode : integer = 0;
	ErrSeg  : WORD = 0;
	ErrOfs  : WORD = 0;

begin

	{$IFDEF _DEBUG}
	AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR+36, 0, 0, 0, nil, TRUE);
	{$ENDIF}

	ExitProc := OldExitProc;

	if hTexteProc <> 0 then DestroyWindow(hTexteProc);
	if hfnt <> 0 then DeleteObject(hfnt);
	if hFnt2 <> 0 then DeleteObject(hFnt2);
	Ctl3dUnregister(hInstance);
	if hRichedLib <> 0 then FreeLibrary(hRichedLib);

	if ExitCode <> 0 then begin

		psz := MMLoadString(hInstRes, 2000 + ExitCode);
		ErrCode := ExitCode;
		ErrSeg := Seg(ErrorAddr);
		ErrOfs := Ofs(ErrorAddr);
		wvsprintf(szError, MMLoadString(hInstRes, 2000), psz);
		MessageBox(GetActiveWindow, szError, nil, MB_ICONSTOP OR MB_OK);
		ExitCode := 0;
		ErrorAddr := nil;
		AppExit;
	end;

end;

begin
       if NOT SystemCanSupportPerMonitorDpi(True) then
          SystemCanSupportOldDpiAwareness(True);

	{$IFDEF _ASSIST}
		ReadIniFile(szAPPINI[ST_MMWIZARD]);
	{$ELSE}
		ReadIniFile('LAVAC.INI');
	{$ENDIF _ASSIST}

	{$IFDEF _DEBUG}
	UpdateDebugInfo;
	AddDebugText(DBG_SYSTEM, 'Starting LAVAC', nil, TRUE);
	{$ENDIF _DEBUG}

	OldExitProc := ExitProc;
	ExitProc := @MyExitProc;
	WinMain;

	{$IFDEF _DEBUG}
	AddDebugText(DBG_SYSTEM, 'Ending LAVAC', nil, TRUE);
	{$ENDIF _DEBUG}
end.
{**             Fin de la Procédure WinMain                 **}
{*************************************************************}

{*************************************************************}
{**                                                         **}
{**             Fin du Programme LAVAC_EL                   **}
{**                                                         **}
{*************************************************************}
