{************************************************}

{   Unité MMLAVAC                                }

{   Projet LAVAC                                 }

{  (c) 1992-94 C Puissance 3 Informatique        }
{              MORGAN MULTIMEDIA                 }

{  par Guillaume de Bailliencourt                }

{  02/02/1994                                    }

{************************************************}

unit MMLAVAC;

interface

{************************************************}
uses Windows, Dos, SysUtils, WinInet,
  CommDlg,
  Dlgs,
  mmsystem, Strings, {toolhelp, }
  LZExpand,
  VFW,
  {BWCC,} MMDIB, MMSTRING,
  Ctl3d,
  mciwnd,
  mmLic,
  RichEdit,
  MultiSel,
  ShellAPi
     {$IFDEF _DEBUG}
  , MMDEBUG
     {$ENDIF};

// App Window
var
  hApp: HWnd;
  rcApp: TRECT;

{************************************************}
const
  FTPFILENAME: integer = 39;

const
  FTPSIZE: integer = 24;

const
  FTPHOUR: integer = 10;

const
  FTPMIN: integer = 13;

const
  UPDOWN_CLASS = 'msctls_updown';
  bWin95: BOOL = False;
  bWinNT: BOOL = False;
  bFTP: BOOL = False;
  hInstRes: THANDLE = 0;
  hRestore: THANDLE = 0;

type
  PMailTo = ^TMailTo;

  TMailTo = record
    szServer: array[0..255] of char;
    nPort: integer;
    szFrom: array[0..255] of char;
    szTo: array[0..4096] of char;
    szCc,
    szCci,
    szSubject: array[0..255] of char;
    szText: array[0..4096] of char;
    szAttach: array[0..255] of char;
  end;

type
  PMCISTR = ^TMCISTR;
  TMCISTR = array[0..511] of char;

type
  PSearchRec = ^TSearchRec;

type
  PUDACCEL = ^TUDACCEL;

  TUDACCEL = record
    nSec,
    nInc: integer;
  end;

const
  UDS_WRAP = $0001;

const
  UDS_SETBUDDYINT = $0002;

const
  UDS_ALIGNRIGHT = $0004;

const
  UDS_ALIGNLEFT = $0008;

const
  UDS_AUTOBUDDY = $0010;

const
  UDS_ARROWKEYS = $0020;

const
  UDS_HORZ = $0040;

const
  UDS_NOTHOUSANDS = $0080;


const
  UDM_SETRANGE = (WM_USER + 101);

const
  UDM_GETRANGE = (WM_USER + 102);

const
  UDM_SETPOS = (WM_USER + 103);

const
  UDM_GETPOS = (WM_USER + 104);

const
  UDM_SETBUDDY = (WM_USER + 105);

const
  UDM_GETBUDDY = (WM_USER + 106);

const
  UDM_SETACCEL = (WM_USER + 107);

const
  UDM_GETACCEL = (WM_USER + 108);

const
  UDM_SETBASE = (WM_USER + 109);

const
  UDM_GETBASE = (WM_USER + 110);

const
  bRecDefault: boolean = False;
  LAVACWIDTH = 640;
  LAVACHEIGHT = 480;
  MAXELEVEFRAME = 24;
  MAXELEVE = 48;
  nMaxLargCombo = 400;

  QS_STRECHED = $0001;
  QS_BMPTOP = $0002;
  QS_TXTTOP = $0004;
  QS_TXTBOTTOM = $0008;
  QS_BMPBOTTOM = $0010;
  QS_VIDEOBAR = $0020;
  QS_SOUNDBAR = $0040;
  QS_RECIN = $0080;

  QM_TXTAPPEND = $0001;
  QM_TXTATRECT = $0002;
  QM_PAUSE = $0004;
  QM_TXTADDIN = $0008;
  QM_TXTADDREL = $0010;
  QM_TXTADDAFT = $0020;

  { Define WRITE }
  IDW_ENREG = 4099;

  {  MENUITEM "&Nouveau", 4097
    MENUITEM "&Ouvrir...", 4098
    MENUITEM "&Enregistrer", 4099
    MENUITEM "En&registrer sous...", 4100
    MENUITEM SEPARATOR
    MENUITEM "&Imprimer...", 4101
    MENUITEM "&Configuration de l'impression...", 4102
    MENUITEM "Rep&aginer...", 4103
    MENUITEM SEPARATOR
    MENUITEM "&Quitter", 4104}

  szTextExt: array[0..63] of char = '.TXT' + #0;
  szTextDefExt: array[0..63] of char = 'TXT' + #0;
  szTextEditor: array[0..63] of char = 'NOTEPAD.EXE' + #0;
  szTextTemplate: array[0..63] of char = 'NONE' + #0;
  szImageExt: array[0..63] of char = '.BMP' + #0;
  szImageDefExt: array[0..63] of char = 'BMP' + #0;
  szImageEditor: array[0..63] of char = 'PBRUSH.EXE' + #0;
  szImageTemplate: array[0..63] of char = 'NONE' + #0;
  szSoundExt: array[0..63] of char = '.WAV' + #0;
  szSoundDefExt: array[0..63] of char = 'WAV' + #0;
  szSoundEditor: array[0..63] of char = 'SOUNDREC.EXE' + #0;
  szVideoExt: array[0..63] of char = '.AVI' + #0;
  szVideoDefExt: array[0..63] of char = 'AVI' + #0;
  szVideoEditor: array[0..63] of char = 'VIDCAP.EXE' + #0;
  szMixer: array[0..63] of char = 'SBPMIXER.EXE' + #0;

  bVideoNotChild: boolean = False;
  bVideoNotNotify: boolean = False;
  bVideoWave: boolean = False;
  nVideoWaveDelay: integer = 2;
  szVideoWave: array[0..511] of char = '';
  pVideoWave: PChar = nil;

  LAVAC_DIB = 1110;

  {Et un message, un !!!}
  UM_SETSTATUSTEXT = WM_USER;
  UM_SUITE = WM_USER + 408;
  //WM_MMPAINT     = WM_USER + 1000;
  WM_MMPAINT = WM_USER + 4321;
  UM_ATTENTE = WM_USER + 1001;
  UM_PLAYQCM = WM_USER + 1002;
  UM_APPEL = WM_USER + 1003;
  UM_RETOUR = WM_USER + 1004;
  UM_REFRESHPAL = WM_USER + 1005;
  UM_ADDSEL = WM_USER + 1006;
  UM_RESETSEL = WM_USER + 1007;
  UM_INITPOS = WM_USER + 1008;
  UM_FULLPOS = WM_USER + 1009;
  UM_NEXTQCMCREATE = WM_USER + 1010;

  {Lecon}
  idl_Lecon1 = 102;
  idl_Lecon2 = 202;
  idl_Lecon = 101;
  idl_ListeQ = 102;
  idl_BtnTout = 103;

  {Lecons fichier à executer}
  id_tf_FichierExe = 107;
  id_bn_Parcourir = 110;
  id_cb_Append = 117;
  id_bn_Position = 118;
  id_em_CommandeMCI = 115;
  id_tk_Pause = 300;
  id_ed_Pause = 301;
  id_cb_Pause = 302;

  {Lecon}
  timer_Heure = 101;
  timer_Etudiant = 102;
  timer_Messages = 103;
  timer_Scroll = 104;
  Duree_timer_Heure = 1000;
  Duree_timer_Etudiant = 5000;
  Duree_timer_Messages = 5000;
  Duree_timer_Scroll = 333;

  {Boutons}
  idb_PlayQ = 6001;
  idb_PlayR = 6002;
  idb_PlayQR = 6003;
  idb_RecordR = 6004;
  idb_Enregistre = 6007;
  idb_Pause = 6005;
  idb_AppelProf = 6006;
  idb_Quit = 6008;
  idb_PosteEleve = 6009;
  idb_Nouveau = 6010;
  idb_Couper = 6011;
  idb_Copier = 6012;
  idb_Coller = 6013;
  idb_Fusionner = 6014;
  idb_Supprimer = 6015;
  idb_Numeroter = 6022;
  idb_Retour = 6023;
  idb_Reprendre = 6026;
  idb_Restaurer = 6038;
  //
  idb_PriseNotes = 6100;
  idb_LectureNotes = 6101;



  {Enregistre}
  idr_Demare = 101;
  idr_Pause = 102;
  idr_FormeOnde = 103;
  idr_ValLBlanc = 104;
  idr_ValSBlanc = 105;
  idr_LongBlanc = 106;
  idr_SeuilBlanc = 107;
  idr_Verouille = 108;
  {idr_Lecon     = 109;}
  idr_EtatEnreg = 110;
  idr_EtatBlanc = 120;
  idr_Quit = 6008;

  { Common Dialog #define lst1 0x460 }
  id_ComDlg_LB_File = $460; {dlgs.lst1;}

{************************************************}
const
  hfnt: HFONT = 0;
  hFnt2: HFONT = 0;
  BMScrollH: boolean = False;
  BMScrollV: boolean = False;
  bProcessSize: boolean = True;
  hAscPlaying: word = 0;
  dwLavacTag: DWord = $4C415643; {'LAVC'}
  wLavacVer: word = $0402;
  GetCurCharset: byte = 255;

  fsPathName = 79;
  fsDirectory = 67;
  fsFileName = 8;
  fsExtension = 4;


{************************************************}

type
  TDIALOGHANDLE = record
    rcArea: TRECT;
    dwNCHITVALUE: DWORD;
  end;

var
  cTrackBar: TWndClass;
  DialogHandles: array[0..7] of TDIALOGHANDLE;
  gbSmartResult: BOOL;
  gnNoElev: integer;

type
  DWORD = longint;
  HWAVEHDR = THANDLE;
  szPName = array[0..255] of char;
  szLongName = array[0..63] of char;

  PDIBINFO = ^TDIBINFO;

  TDIBINFO = record
    hwin: HWND;
    hpar: HWND;
    havi: HWND;
    len: DWORD;
    hdd: HANDLE;
    hdib: HANDLE;
    lpbi: PBITMAPINFOHEADER;
    bi: TBITMAPINFOHEADER;
    rcDraw,
    rcSource: TRECT;
    iZoom: integer;
    fCanDecompress,
    fCanCompress: BOOL;
    achFileName: array[0..127] of char;
  end;

  PtrRec = record
    Lo, Hi: word
  end;

        {$A1}
  TypeLecon = record
    Nom: szLongName;
    Createur: szLongName;
    PathLecon: szLongName;
    Langue: smallint;
    Syquest: wordbool;
    Serveur: wordbool;
    AVideo: bytebool;
    dwTag: DWORD;
    wVer: word;
    bAssist: byte;
    CorrecDe: szLongName;
    Reserved: array[0..247 - SizeOf(szLongName)] of byte;
  end;

  FileOfLecon = file of TypeLecon;

  LOGFONT16 = record
    lfHeight: smallint;
    lfWidth: smallint;
    lfEscapement: smallint;
    lfOrientation: smallint;
    lfWeight: smallint;
    lfItalic: byte;
    lfUnderline: byte;
    lfStrikeOut: byte;
    lfCharSet: byte;
    lfOutPrecision: byte;
    lfClipPrecision: byte;
    lfQuality: byte;
    lfPitchAndFamily: byte;
    lfFaceName: array[0..(LF_FACESIZE) - 1] of TCHAR;
  end;

  PQuestion = ^TypeQuestion;

  TypeQuestion = record
    Nom: szLongName; // 64
    FichierQuestion: szLongName; // 64
    FichierGraph: szLongName; // 64
    FichierTexte: szLongName; // 64  = 256
    DureeReponse: longint;   // 4
    ReponseSon: wordbool;  //  2
    ReponseTexte: wordbool;  //  2
    Options: byte;       //  1
    gx1, gy1,                      //  4
    gx2, gy2: smallint;   //  4 = 17
    dwTag: DWORD;
    wVer: word;
    hLogFnt: LOGFONT16;
    FrColRef: DWORD; //Windows.TColorRef;
    BkColRef: DWORD; //Windows.TColorRef;
    tx1, ty1,
    tx2, ty2: smallint;
    wStyle: word;
    bAddIn,
    bRecIn: byte;
    FichierQCM: szLongName;
    qX,
    qY,
    qW,
    qH: smallint;
    FichierExecutable: szLongName;
    FichierMCI: array[0..fsFileName] of char;
    //Dummy           : ARRAY[0..23] of char;
    //Dummy           : ARRAY[0..31] of char;
    rtx1, rty1,
    rtx2, rty2: smallint;
    Mode: word;
    wPause: word;
    nZoom: smallint;
    SndBarX,
    SndBarY,
    SndBarW,
    nSclImgX,
    nSclImgY,
    nSclTxtY: smallint;
  end;


  PSEQPROP = ^TSEQPROP;

  TSEQPROP = record
    hLogFnt: Windows.TLogFont;
    FrColRef: Windows.TColorRef;
    BkColRef: Windows.TColorRef;
    hWin: HWND;
    pszText: PChar;
  end;

  PQuestionList = ^TQuestionList;

  TQuestionList = record
    n: integer;
    nItem: integer;
    tQuestion: TypeQuestion;
    pNext: PQuestionList;
  end;


  FileOfQuestion = file of TypeQuestion;

  TypeEtudiant = record
    Nom: szLongName;
    Position: longint;
    Appel: boolean;
    LessonName: szLongName;
    LeconEnCours: shortint;
    QuestionEnCours: shortint;
    ReponseEnCours: shortint;
    Score: shortint;
    MaxPoints: shortint;
    MinPoints: shortint;
  end;

  FileOfEtudiant = file of TypeEtudiant;

  PReqText = ^TReqText;

  TReqText = record
    Path: szLongName;
    Mode: word;
    Rect: TRECT;
  end;

  PReqQcm = ^TReqQcm;

  TReqQcm = record
    Path: szLongName;
    Mode: word;
    Rect: TRect;
    nElev: word;
    bNotify: boolean;
  end;

{************************************************}
const
  {####}
  NoELEV: longint = 1;             { Numéro d'élèves      }
  ELEVE: szLongName = ' 1' + #0;   { N                    }

  hBkBrush: HBRUSH = HANDLE(-1);

  CopyError: longint = -1;
  szStartLesson: szLongName = 'Menu';

  { Sound Blaster Pro Mixer Port}
  SbpBaseAddr: word = $220;
  SbpMixAddrPort: word = $04;
  SbpMixDataPort: word = $05;
  SbpMixInSetReg: word = $0C;
  SbpMixSourceMask: byte = byte(not $06);
  SbpMixFilterMask: byte = byte(not $28);
  SbpMixMic: byte = $00;
  SbpMixCD: byte = $02;
  SbpMixLineIn: byte = $06;
  SbpMixLowFilter: byte = $00;
  SbpMixHighFilter: byte = $08;
  SbpMixNoFilter: byte = $20;

  {Novell NetWare}
  faShare: word = $0080;

  dwFmtSize: DWORD = SizeOf(TPCMWAVEFORMAT);
  wNbBits: word = 8;
  FrequEch: DWORD = 11025;
  dwIniBlockSize: DWORD = 22050;
  dwBlockSize: DWORD = 22050;
  Seuil: integer = 5;
  SeuilHaut: integer = 148;
  SeuilBas: integer = 108;
  ExtraBlancDeb: longint = 3000;
  ExtraBlancFin: longint = 3000;
  NextQName: szLongName = #0;
  NewQName: szLongName = #0;
  OldQName: szLongName = #0;

  Clip: Bool = False;
  JoueVideo: boolean = False;

  {pointeur sur zone texte...}
  hLineBuffer: THANDLE = 0;
  lpszLineBuffer: PChar = nil;
  MAXTEXTBUFFER = 32767;
  hWrite: HWND = 0;
  lpWriteSubClassProc: TFarProc = nil;
  lpWriteWndProc: TFarProc = nil;

type
  PPalEntry = ^TPalEntry;
  TPalEntry = array[0..255] of TPALETTEENTRY;

{************************************************}
var
  szParam: szLongName;
  ErrPos: integer;

var {Globales...}
  Window: HWnd;
  hLed_J: THandle;
  hLed_N: THandle;
  hLed_R: THandle;
  hLed_V: THandle;
  hLedC_J: THandle;
  hLedC_N: THandle;
  hLedC_R: THandle;
  hLedC_V: THandle;
  hAboutBoxProc: HWnd;
  lpAboutBoxProc: TFarProc;
  hLeconProc: HWnd;
  lpLeconProc: TFarProc;
  hSonProc: HWnd;
  lpSonProc: TFarProc;
  hTexteProc: HWnd;
  lpTexteProc: TFarProc;
  hGraphiqueProc: HWnd;
  lpGraphiqueProc: TFarProc;
  hBoutonsProc: HWnd;
  lpBoutonsProc: TFarProc;
  hMessagesProc: HWnd;
  lpMessagesProc: TFarProc;
  hQcmProc: HWnd;
  lpAttenteProc: TFarProc;      {-- Pour la dialogue d'attente --}
  hAttenteProc: Hwnd;

  hToolBar: HWnd;
  rcToolBar: TRECT;
  lpToolBarProc: TFarProc;

  hListBar: HWnd;
  rcListBar: TRECT;
  lpListBarProc: TFarProc;

  hStatusBar: HWnd;
  rcStatusBar: TRECT;
  lpStatusBarProc: TFarProc;

  tLecon: TypeLecon;
  fLecon: FileOfLecon;
  tQuestion: TypeQuestion;
  tClipLecon: TypeLecon;
  {tClipQuestion : TQuestionList;
  tPasteQuestion : TypeQuestion;}
  pClipList: PQuestionList;
  pUndoList: PQuestionList;
  fQuestion: FileOfQuestion;
  tEtudiant: TypeEtudiant;
  fEtudiant: FileOfEtudiant;

  hInstSBPMixer: THandle;
  hWndSBPMixer: THandle;
  hMenuSBPMixer: THandle;

  hInstSoundRec: THandle;
  hWndSoundRec: THandle;
  hMenuSoundRec: THandle;

  {Pour l'appel au Bloc Note}
  hInstNotePad: THandle;
  hWndNotePad: THandle;
  hMenuNotePad: THandle;

  {Pour l'appel à paintBrush}
  hInstPBrush: THandle;
  hWndPBrush: THandle;
  hMenuPBrush: THandle;

  {Pour l'appel à VidCap: Ces variables sont initialisées par la fonction EXEC}
  hInstVidCap: THandle;     {Handle de l'instance de VidCap}
  hWndVidCap: THandle;      {Handle de la fenêtre de VidCap}
  hMenuVidCap: THandle;     {Handle du menu de VidCap : inutilisé}

  {Pour les menus système des fenêtres}
  bStreched: boolean;
  {hGraphSysMenu : Word;
  hTexteSysMenu : Word;
  hSonSysMenu : Word;
  hMessageSysMenu : Word;
  hVideoSysMenu : Word;}

  ItWasBitmap: boolean;
  ItWasTexte: boolean;
  ItWasSon: boolean;
  ItWasVideo: boolean;     { Pour le partage des applications }
  bItsACall: boolean; {Version internationale oblige!}
  bItsARet: boolean;

  ClosePosted: Bool;
  PlayingMessage: Bool;

  {Globales...}
  hBlockBlanc: THANDLE;
  lpBlockBlanc: Pointer;
  hDataRec: array [0..2] of THANDLE;
  lpDataRec: array [0..2] of Pointer;
  hWavHdrRec: array [0..2] of HWAVEHDR;
  lpWavHdrRec: array [0..2] of PWAVEHDR;

  szNomEleve: szLongName;          { Nom de l'élève       }

  PathFichier: array[0..1024] of char; //szLongName;
  szMessage: szPName;

  wReturn: word;
  dwReturn: DWORD;
  nbQuestion,
  {ne pas changer l'ordre ...}
  NoLecon, noSel, nbSel: longint;
  {...}
  PlayingQ: boolean;
  PlayingR: boolean;
  RecordingR: boolean;
  //
  PriseNotes: boolean;

  listeSelectInt: array [1..500] of integer;
  listeEtudiantInt: array [1..100] of integer;
  QDebut, Qfin, nMode: integer;

  {Globale pour vitesse dans Enregistre Proc...}
  hmio: HMMIO;
  hFormat: THANDLE;
  pFormat: PPCMWAVEFORMAT;
  hWavIn: HWAVEIN;
  NoBlock: integer;
  NbBlocks: integer;
  PropositionName: szLongName;
  nNextWavNo: longint;
  PropositionNo: longint;
  BlancRestant: longint;
  FileOpen: boolean;

  BlancDeb: longint;
  IncDeb: byte;
  BlancFin: longint;
  IncFin: byte;
  i: longint;
  DC: hDC;
  PS: TPaintStruct;
  Rect: TRect;
  Point: TPoint;
  DureeProp, DureeBlanc: longint;
  nSecDureeBlanc: longint;
  EnRoute: boolean;
  Pause: boolean;

  Tout: boolean;

  NewLesson: boolean;
  CreateurChange: boolean;
  LibelleChange: boolean;
  ImageChange: boolean;
  TexteChange: boolean;
  SonChange: boolean;
  RepTexteChange: boolean;
  hRepTexte: HWND;
  RepSonChange: boolean;

  heure: szPName;

  MessageName: szLongName;

  StrError: array[0..255] of char;

  hOldLed: THandle;

  lpPaintListeProc: TFarProc;
  lpSafe1Proc: TFarProc;
  lpSubClsTxtProc: TFarProc;
  lpSubClsBmpProc: TFarProc;
  lpSafe2Proc: TFarProc;

{************************************************}
const
  hOldHandled: HWnd = 0;
  mmckinfoparent: TMMCKINFO = (ckid: 0);
  mmckinfoSubchunk: TMMCKINFO = (ckid: 0);
  VideoPlaying: Bool = False;
  StartVideoLoc: Bool = False;
  VideoLoc: Bool = False;
  bNetBios: Bool = True;
  TailleLoc: longint = 2097152; { en octets}

  QuestionsFaite: integer = 0;
  QuestionsPrevues: integer = 0;

  DilateDuree: integer = 100;
  szExecTitle: szLongName = #0;
  szExecPath: szLongName = #0;
  PathServeur: szLongName = 'F:\' + #0;
  PathFloppy: szLongName = 'A:\' + #0;
  PathLavac: szLongName = 'LAVAC\' + #0;
  PathImages: szLongName = 'IMAGES\' + #0;
  PathTextes: szLongName = 'TEXTES\' + #0;
  PathSons: szLongName = 'SONS\' + #0;
  PathVideo: szLongName = 'VIDEO\' + #0;
  PathLecons: szLongName = 'LECONS\' + #0;
  PathQuestions: szLongName = 'L0000001\' + #0;
  PathProf: szLongName = 'PROF\' + #0;
  PathEleves: szLongName = 'ELEVES\' + #0;
  OldPathEleves: szLongName = 'ELEVES\' + #0;
  bDynaPath: boolean = False;
  L000000: szLongName = 'L000000' + #0;
  B000000: szLongName = 'B000000' + #0;
  T000000: szLongName = 'T000000' + #0;
  W000000: szLongName = 'W000000' + #0;
  Q000000: szLongName = 'Q000000' + #0;
  V000000: szLongName = 'V000000' + #0;
  R000000: szLongName = 'R000000' + #0;
  M000000: szLongName = 'M000000' + #0;
  QCM0000: szLongName = 'QCM0000' + #0;
  ELEV: szLongName = 'ELEVE' + #0;

  PathVideoLoc: szLongName = 'C:\LAVAC\VIDEO\' + #0;

  szCOMPRESS: szLongName = '-Archivée-' + #0;

  hDiagram: hBrush = 0;
  hFond: hBrush = 0;


{************************************************}
const
  gszIni: array[0..255] of char = 'LAVAC.INI';

{
function GetKeyboardLayoutName(pwszKLID : PCHAR) : BOOL;
function LoadKeyboardLayout(pwszKLID : PCHAR; uFlags : WORD) : DWORD;
function ActivateKeyboardLayout(hkl : DWORD;  Flags : WORD) : DWORD;
function GetKeyboardLayoutList(nBuff :integer; lpList : PLONGINT) : WORD;
}

procedure MMLavacDone;
function PixelsToTwips(nPixels, nDirection: integer): integer;
function TwipsToPixels(nTwips, nDirection: integer): integer;
function RtfGetPageInfo(szFileName: PChar; var nPaperw: integer;
  var nPaperh: integer; var nMargl: integer; var nMargr: integer;
  var nMargt: integer; var nMargb: integer): integer;
function RtfSetPageInfo(szFileName: PChar; nPaperw: integer;
  nPaperh: integer; nMargl: integer; nMargr: integer; nMargt: integer;
  nMargb: integer): integer;

// ToolHelp
procedure MemoryRead(lpFar: PChar; ofs: DWORD; lpNear: PChar; len: DWORD);
procedure MemoryWrite(lpFar: PChar; ofs: DWORD; lpNear: PChar; len: DWORD);

// FileSplit
procedure FileSplit(szPath, szDir, szName, szExt: PChar);

// MoveTo
function MoveTo(_para1: HDC; _para2: longint; _para3: longint): DWORD;

function IsSoundFile(pFile: PChar): BOOL;
function IsVideoFile(pFile: PChar): BOOL;
function IsImageFile(pFile: PChar): BOOL;
function IsTextFile(pFile: PChar): BOOL;
procedure AdjustToRect(Dialog: HWND; rDsk: TRECT; nWidth, nHeight: integer);
procedure AdjustRectToDesktop(var rWin: TRECT);
procedure AdjustToDesktop(Dialog: HWND);
procedure CenterDialog(Dialog: HWND);
procedure SetWindowTextFromFile(hWin: HWND; szFileName: PSTR);
procedure GetWindowTextToFile(hWin: HWND; szFileName: PSTR);
function sndPlaySoundResource(lpszRes: PChar): BOOL;
function UpdateSbpMixBaseAddr: Bool;
procedure SetSbpMixSource(Source: byte);
procedure SetSbpMixFilter(Filter: byte);

function LeadingZero(w: word): string;
function SystemTime: PChar;
function IntToStr(I: longint): string;
function AZTtoSTRING(AZT: PChar): string;
function FileExist(FileName: PChar): boolean;
function max(Val1, Val2: longint): longint;
function min(Val1, Val2: longint): longint;
function DeleteFile(FileName: PChar): Bool;
procedure CopyErrorMessage(szMessage: PChar);
function FastCopyFile(Source, Dest: PChar): Bool;
function CopyFile(Source, Dest: PChar): Bool;
function IsInCurLesson(pszFileName: PChar): Bool;
function CopyInCurLesson(pszFileName, pszTemplateName: PChar; nItem: integer): Bool;

function GetFileName(Libelle, DefExt: PChar): PChar;

function GetItemRect(hDlg: hWnd; ID: word; var IDRect: TRect): Bool;
function RectIntersect(R1, R2: TRect): Bool;

procedure ReadTextFile(szFileName: PSTR);
function HookBmpFunc(Dialog: HWnd; Message, WParam: DWord;
  LParam: longint): DWord; stdcall;
function HookWavFunc(Dialog: HWnd; Message, WParam: DWord;
  LParam: longint): DWord; stdcall;
function HookTxtFunc(Dialog: HWnd; Message, WParam: DWord; LParam: longint): DWord;stdcall;
function WriteSubClassProc(hWin: HWnd; Msg, wParam: DWord; lParam: longint): DWord;stdcall;
procedure AfficheBitmapIn(hWind: hWnd; InX, InY: longint; var hInDIB: THandle;
  var pInDIB: PBitmapInfo;
  var pInBits: POINTER; InPalette: hPalette; Erase, Stretch: Bool);
procedure AfficheBitmapNow;
procedure AfficheBitmap;
procedure BitmapFileName(var PropositionName: szLongName; PropositionNo: longint);
procedure VideoFileName(var PropositionName: szLongName; PropositionNo: longint);
function AfficheLed(hLed: THandle): THandle;

function CreateNewLessonRep(NoLecon: longint; var tLecon: TypeLecon): boolean;
function CreateNewLesson(Dialog: HWND; var tLecon: TypeLecon;
  var QuestionNo: longint): boolean;
function OpenLesson(Dialog: HWND; var tLecon: TypeLecon;
  var NoLecon: longint): boolean;
procedure FreeAllGlobal;
function OpenNewWaveFile(Window: HWnd; FileName: szLongName): boolean;
function CloseWaveFile: boolean;
function NextBlockRec(NoBlock: integer): boolean;
function SendToBeRec(Window: HWnd): boolean;
function StartLessonRec(Window: HWnd): boolean;
function EnregistreProc(Dialog: HWnd; Message, WParam: DWord; LParam: longint): Bool; stdcall;

procedure ResetLecon(hList: HWND);
procedure CreerLecon;
procedure CreerQuestion;
procedure RestoreReponsesInit(NoElev: longint; var tEtudiant: TypeEtudiant);
procedure RestoreReponsesDone(NoElev: longint; var tEtudiant: TypeEtudiant);
procedure BackupReponses(NoElev: longint; tEtudiant: TypeEtudiant; bErase: BOOL);
procedure DelAllReponseFile(NoElev: longint);
procedure ReponseTxtFileName(var PropositionName: szLongName;
  NoELEV, PropositionNo: longint);
procedure ReponseRtfFileName(var PropositionName: szLongName;
  NoELEV, PropositionNo: longint);
procedure SauveReponseTexte(PropositionPName: PChar);
procedure InitEtudiantLst;
procedure CreerRep(Path: PChar);
procedure TexteFileName(var PropositionName: szLongName; PropositionNo: longint);
procedure MyLoadRTFFile(hRTFWnd: HWND; szFileName: PChar; wStreamFormat: word);
procedure MySaveRTFFile(hRTFWnd: HWND; szFileName: PChar; wStreamFormat: word);
procedure QcmBmpFileName(var PropositionName: szLongName; PropositionNo: longint);
procedure QcmWavFileName(var PropositionName: szLongName; PropositionNo: longint);
procedure FileName(pszName, pszTemplateName, pszExt: PChar; No: longint);
procedure QuestionFileName(var PropositionName: szLongName; PropositionNo: longint);
procedure EleveRoot(var PathFichier: szLongName; NoELEV: longint);
procedure EleveRep(var PathFichier: szLongName; NoELEV: longint);
procedure ReponseFileName(var PropositionName: szLongName;
  NoELEV, PropositionNo: longint);
procedure ReponseEtudiant(NoELEV: longint; PropositionNo: longint;
  var PropositionName: szLongName);
function NewFile(pszName, pszTemplateName, pszExt: PChar; No: longint): boolean;
function NewQcmBmpFile(var Name: szLongName; No: longint): boolean;
function NewQcmWavFile(var Name: szLongName; No: longint): boolean;
function NewQuestionFile(var Name: szLongName; No: longint): boolean;
function NewMCIFile(var Name: szLongName; No: longint): boolean;
function NewQcmFile(var Name: szLongName; No: longint): boolean;
function NewBitmapFile(var Name: szLongName; No: longint): boolean;
function NewVideoFile(var Name: szLongName; No: longint): boolean;
function NewTexteFile(var Name: szLongName; No: longint): boolean;
function GetLessonRec(No: longint; var tLecon: TypeLecon): boolean;
function GetLessonCount: longint;
function SetLessonRec(No: longint; var tLecon: TypeLecon): boolean;
function CopyLessonRec(No: longint; var tLecon: TypeLecon): boolean;
function CutLessonRec(No: longint; var tLecon: TypeLecon): boolean;
function CutQuestionRec(No: longint; var tQuestion: TypeQuestion): boolean;
function PasteQuestionRec(No: longint; var tNewQuestion: TypeQuestion): boolean;
function PasteFromSequenceFiles(tlFrom: TypeLecon;
  var tqFrom: TypeQuestion; var tqTo: TypeQuestion;
  nItem: integer): boolean;
function GetQuestionRec(No: longint; var tQuestion: TypeQuestion): boolean;
function SetQuestionRec(No: longint; var tQuestion: TypeQuestion): boolean;
function GetEtudiantRec(No: longint; var tEtudiant: TypeEtudiant): boolean;
function SetEtudiantRec(No: longint; var tEtudiant: TypeEtudiant): boolean;
function GetDilateDuree(var DilateDuree: integer): boolean;
function SetDilateDuree(DilateDuree: integer): boolean;
procedure MessageSelFileName(var PropositionName: szLongName; NoELEV: longint);
procedure MessageBmpFileName(var PropositionName: szLongName; NoELEV: longint);
procedure MessageTxtFileName(var PropositionName: szLongName; NoELEV: longint);
procedure MessageRtfFileName(var PropositionName: szLongName; NoELEV: longint);
procedure MessageWavFileName(var PropositionName: szLongName; NoELEV: longint);

function Exec(var hInst, hWnd, hMenu: THandle; AppCmd, AppName, AppDir: PChar): BOOL;
procedure ExecSBPMixer;
procedure CreerImage(Dialog, hList: HWnd; var szRet: szLongName);
procedure CreerVideo(Dialog, hList: HWnd; var szRet: szLongName);
procedure CreerSon(Dialog, hList: HWnd; var szRet: szLongName);
procedure CreerTexte(Dialog, hList: HWnd; var szRet: szLongName);
procedure EditerSon(Dialog: HWnd);
procedure EditerImage(Dialog: HWnd);
procedure EditerVideo(Dialog: HWnd);
procedure EditerTexte(Dialog: HWnd);
function PrendreImage(Dialog: HWnd): Bool;
function PrendreVideo(Dialog: HWnd): Bool;
function PrendreTexte(Dialog: HWnd): Bool;
function PrendreSon(Dialog: HWnd): Bool;
procedure EnvoieImage(Dialog: HWnd);
procedure EnvoieTexte(Dialog: HWnd);
procedure EnvoieSon(Dialog: HWnd);

function DrawPosition(DC: HDC; hWind: hWnd;
  Position, ANote, AMax, AMin: integer): Bool;
function DrawPositionInRect(DC: HDC; R: TRECT;
  Position, ANote, AMax, AMin: integer): Bool;

function AboutBoxProc(Dialog: HWnd; Message, WParam: DWord; LParam: longint): Bool; stdcall;

{****************** Modif vidéo ****************************}
function VerifieVideo(var tLecon: TypeLecon): Bool;
function ChercheVideo(var tLecon: TypeLecon): boolean;
function VerifieQuestionVideo(var tQuestion: TypeQuestion): Bool;
function RechercheLocal(var tLecon: TypeLecon): Bool;
function TousFichierVideo(var tLecon: TypeLecon): longint;
procedure EffaceAll(szNom: PChar);
procedure Efface(szNom: PChar);
function CompteFichVideo(var tLecon: TypeLecon): integer;
function DateFichier(szNom: PChar): longint;
function TailleFichier(szNom: PChar): longint;
procedure BoiteAlerte(szChaine: PChar);
function DonneNomLocal(szName: PChar): PChar;
function SwapWindows(hWnd1, hWnd2: HWND): Bool;
function ActivateKeyboardFromCharset(bCharset: byte): longbool;
procedure ProcessCloseUp(hDlg, hCombo: HWND; var rDlg, rCombo: TRECT);
procedure ProcessDropDown(hDlg, hCombo: HWND; var rDlg, rCombo: TRECT);
function MakeSharedFile(FileName: PChar): Bool;
function GetItemData(Dialog: HWND; idCombo: word; no: integer): integer;
function GetCurItemData(Dialog: HWND; idCombo: word): integer;
procedure LessonInDlgLB(Dialog: HWND; idLB: word; bUpdate: boolean);
procedure LessonInDlgCombo(Dialog: HWND; idCombo: word; bUpdate: boolean);
procedure FigureHandleSizes(hWin: HWND);
procedure ShowHandle(DC: hDC; hWin: HWND);
procedure UpdateHandle(hWin: HWND);
function ProcessHitTest(hWin: HWnd; Message, wParam: Dword; lParam: longint): word;
function GetDriveType(Drive: integer): word;
procedure UpdatePath(pszFile, pszPath: PChar);
function ProcessOptionsBitmap(tQuestion: TypeQuestion; var mciMessage: TMCISTR): BOOL;
function ProcessOptionsText(tQuestion: TypeQuestion; var mciMessage: TMCISTR): BOOL;

const
  DRIVE_CDROM = DRIVE_REMOTE + 1;

var
  lpCBProc, lpOldCBProc: WNDPROC; {TFARPROC; ####}

function IdleCBProc(Dialog: HWnd; Message, WParam: DWord; LParam: longint): Bool;stdcall;

function MciParamProc(Dialog: HWnd; Message, WParam: DWord; LParam: longint): Bool; stdcall;

procedure FtpPutAnswer(NoElev: longint);
procedure FtpGetAnswerDir(NoElev: longint);
procedure FtpGetAnswer(Dialog: HWND; NoElev: longint; szLesson: PChar);
procedure GetDosName(pszDosName, pszFullName: PChar);
procedure InsertSequenceProp(hList: HWND; id: word; nItem: integer;
  tQuestion: TypeQuestion);

procedure CopyLogFont16to32(var lf32: Windows.LOGFONT; var lf16: LOGFONT16);
procedure CopyLogFont32to16(var lf16: LOGFONT16; var lf32: Windows.LOGFONT);

procedure WmCommand16to32(var wParam, lParam: DWORD);

function GetUrlContent(const Url, LocalFile: string): string;
function LoadXml(XmlFile: string): string;

var
        szWriterApp : array[0..1024] of char;
        szNotesRtf : array[0..1024] of char;
        szXmlFile : array[0..1024] of char;
        szXmlSearch : array[0..1024] of char;
        szXmlTitle : array[0..1024] of char;
        szXmDescription : array[0..4096] of char;
        szXmlAuthor : array[0..1024] of char;
        sXml : String;
        hDescWin : HWND;
        szDescWin : array[0..8192] of char;


implementation

function GetUrlContent(const Url, LocalFile: string): string;
var
  NetHandle: HINTERNET;
  UrlHandle: HINTERNET;
  Buffer: array[0..1024] of Char;
  BytesRead: LongWord;
  var f: file;
  //StrBuffer: UTF8String;
begin
  Result := '';
  NetHandle := InternetOpen('LAVAC64', INTERNET_OPEN_TYPE_PRECONFIG, nil, nil, 0);

  if Assigned(NetHandle) then
  begin
    UrlHandle := InternetOpenUrl(NetHandle, PChar(Url), nil, 0, INTERNET_FLAG_RELOAD, 0);
    Assign(f, LocalFile);
    Rewrite(f, 1);

    if Assigned(UrlHandle) then
      { UrlHandle valid? Proceed with download }
    begin
      FillChar(Buffer, SizeOf(Buffer), 0);
      repeat
        //Result := Result + Buffer;
        FillChar(Buffer, SizeOf(Buffer), 0);
        InternetReadFile(UrlHandle, @Buffer, SizeOf(Buffer), BytesRead);
        //SetString(StrBuffer, PAnsiChar(@Buffer[0]), BytesRead);
        if BytesRead > 0 then BlockWrite(f, Buffer, BytesRead);
        //if BytesRead > 0 then BlockWrite(f, StrBuffer, BytesRead);
      until BytesRead = 0;
      InternetCloseHandle(UrlHandle);
      Close(f);
    end
    else
      { UrlHandle is not valid. Raise an exception. }
      Result := ''; //raise Exception.CreateFmt('Cannot open URL %s', [Url]);

    InternetCloseHandle(NetHandle);
  end
  else
    { NetHandle is not valid. Raise an exception }
    Result := ''; //raise Exception.Create('Unable to initialize Wininet');
end;

function LoadXml(XmlFile: string): string;
var
  Buffer: array[0..1024] of Char;
  BytesRead: LongWord;
  var f: file;
begin
    Result := '';
    Assign(f, XmlFile);
    Reset(f, 1);

    begin
      //FillChar(Buffer, SizeOf(Buffer), 0);
      repeat
        //FillChar(Buffer, SizeOf(Buffer), 0);
        BlockRead(f, Buffer, 1024, BytesRead);
        if BytesRead > 0 then Result := Result + Buffer;
      until BytesRead = 0;
      Close(f);
    end
end;

procedure WmCommand16to32(var wParam, lParam: DWORD);
begin
  if HiWord(wParam) = 0 then
    wParam := MakeLong(LoWord(wParam), HiWord(lParam));
end;


procedure CopyLogFont16to32(var lf32: Windows.LOGFONT; var lf16: LOGFONT16);
begin
  with lf32 do
  begin
    lfHeight := lf16.lfHeight;
    lfWidth := lf16.lfWidth;
    lfEscapement := lf16.lfEscapement;
    lfOrientation := lf16.lfOrientation;
    lfWeight := lf16.lfWeight;
    lfItalic := lf16.lfItalic;
    lfUnderline := lf16.lfUnderline;
    lfStrikeOut := lf16.lfStrikeOut;
    lfCharSet := lf16.lfCharSet;
    lfOutPrecision := lf16.lfOutPrecision;
    lfClipPrecision := lf16.lfClipPrecision;
    lfQuality := lf16.lfQuality;
    lfPitchAndFamily := lf16.lfPitchAndFamily;
    lfFaceName := lf16.lfFaceName;
  end;
end;

procedure CopyLogFont32to16(var lf16: LOGFONT16; var lf32: Windows.LOGFONT);
begin
  with lf16 do
  begin
    lfHeight := lf32.lfHeight;
    lfWidth := lf32.lfWidth;
    lfEscapement := lf32.lfEscapement;
    lfOrientation := lf32.lfOrientation;
    lfWeight := lf32.lfWeight;
    lfItalic := lf32.lfItalic;
    lfUnderline := lf32.lfUnderline;
    lfStrikeOut := lf32.lfStrikeOut;
    lfCharSet := lf32.lfCharSet;
    lfOutPrecision := lf32.lfOutPrecision;
    lfClipPrecision := lf32.lfClipPrecision;
    lfQuality := lf32.lfQuality;
    lfPitchAndFamily := lf32.lfPitchAndFamily;
    lfFaceName := lf32.lfFaceName;
  end;
end;


procedure InsertSequenceProp(hList: HWND; id: word; nItem: integer;
  tQuestion: TypeQuestion);
var
  lpSeqProp: PSEQPROP;
begin
  lpSeqProp := new(PSEQPROP);
  if lpSeqProp <> nil then
  begin
    lpSeqProp^.pszText := StrNew(tQuestion.Nom);
    if lpSeqProp^.pszText = nil then
      lpSeqProp^.pszText := StrNew(' ');
    //lpSeqProp^.hLogFnt := tQuestion.hLogFnt;
    CopyLogFont16to32(lpSeqProp^.hLogFnt, tQuestion.hLogFnt);

    lpSeqProp^.FrColRef := tQuestion.FrColRef;
    lpSeqProp^.BkColRef := tQuestion.BkColRef;
    SendDlgItemMessage(hList, id, LB_INSERTSTRING, nItem, longint(lpSeqProp));
  end;
end;

procedure GetDosName(pszDosName, pszFullName: PChar);
const
  szLUT: array[0..255] of char = (
    #0,
    '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_',
    '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_',
    '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_',
    '_', '_', '_', '_', '_', '_', '.', '_', '0', '1', '2',
    '3', '4', '5', '6', '7', '8', '9', '_', '_', '_', '_', '_', '_', '_',
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',
    'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
    'Z', '_', '_', '_', '_', '_', '_', 'a', 'b', 'c', 'd',
    'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',
    's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '_', '_', '_',
    '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_',
    '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_',
    '_', '_', '_', '_', '_', '_', '_', '_', 'Y', '_', 'i', 'c', 'l', '.',
    'Y', 'I', 'S', '_', 'c', '2', '_', '_', '_', 'r', '_',
    '_', '_', '_', '_', '_', 'u', 'P', '_', '_', '_', '_', '_', '_', '_',
    '_', '_', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'C', 'E',
    'E', 'E', 'E', 'I', 'I', 'I', 'I', 'D', 'N', 'O', 'O', 'O', 'O', 'O',
    '_', '0', 'U', 'U', 'U', 'U', 'Y', '_', 'B', 'a', 'a',
    'a', 'a', 'a', 'a', 'a', 'c', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i',
    'o', 'n', 'o', 'o', 'o', 'o', 'o', '_', '0', 'u', 'u',
    'u', 'u', 'y', '_', 'y');

var
  i: integer;

begin
  StrCopy(pszDosName, pszFullName);
  pszDosName[12] := #0;
  if pszDosName[8] <> #0 then
    pszDosName[8] := '.';
  if pszDosName[9] = #0 then
    pszDosName[8] := #0;
  for i := 0 to 11 do
    pszDosName[i] := szLUT[Ord(pszDosName[i])];

  {while StrPos(pszDosName, ' ') <> nil do StrPos(pszDosName, ' ')[0] := '_';
  while StrPos(pszDosName, '/') <> nil do StrPos(pszDosName, '/')[0] := '_';
  while StrPos(pszDosName, '\') <> nil do StrPos(pszDosName, '\')[0] := '_';
  while StrPos(pszDosName, ':') <> nil do StrPos(pszDosName, ':')[0] := '_';
  while StrPos(pszDosName, '*') <> nil do StrPos(pszDosName, '*')[0] := '_';
  while StrPos(pszDosName, '?') <> nil do StrPos(pszDosName, '?')[0] := '_';
  while StrPos(pszDosName, '"') <> nil do StrPos(pszDosName, '"')[0] := '_';
  while StrPos(pszDosName, '<') <> nil do StrPos(pszDosName, '<')[0] := '_';
  while StrPos(pszDosName, '>') <> nil do StrPos(pszDosName, '>')[0] := '_';
  while StrPos(pszDosName, '|') <> nil do StrPos(pszDosName, '|')[0] := '_';
  while StrPos(pszDosName, '+') <> nil do StrPos(pszDosName, '+')[0] := '_';
  while StrPos(pszDosName, 'ç') <> nil do StrPos(pszDosName, 'ç')[0] := 'c';}

end;

{****************************************************************}
function MciParamProc(Dialog: HWnd; Message, WParam: DWord; LParam: longint): Bool; stdcall;

const
  lpszMciParam: PChar = nil;
var
  szFormat, szInfo: array[0..128] of char;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR + 23, Message, wParam, lParam, 'WM_', True);
  {$ENDIF}

  MciParamProc := True;
  case Message of
    wm_InitDialog:
    begin
      CenterDialog(Dialog);
      lpszMciParam := PChar(lParam);
      GetDlgItemText(Dialog, 102, szFormat, SizeOf(szFormat));
      wvsprintf(szInfo, szFormat, lpszMciParam);
      SetDlgItemText(Dialog, 102, szInfo);
      SetDlgItemText(Dialog, 101, lpszMciParam);
      SendDlgItemMessage(Dialog, 101, EM_SETSEL, word(False), MAKELONG(0, word(-1)));
      SetFocus(GetDlgItem(Dialog, 101));
      PostMessage(Dialog, WM_MMPAINT, 0, 0);
    end;

    wm_mmpaint:
    begin
      ShowWindow(Dialog, SW_SHOW);
    end;

    wm_Command:
    begin
      case LoWord(wParam) of
        idOk:
        begin
          GetDlgItemText(Dialog, 101, lpszMciParam, SizeOf(szLongName));
          EndDialog(Dialog, 1);
        end;
      end;
    end;
  end;
  MciParamProc := False;
end;

{***************************************************************************}

{*************************************************************}
{**                  Fonction IdleCBProc                     **}
{** SE:                                                     **}
{** SI:                                                     **}
{*************************************************************}

function IdleCBProc(Dialog: HWnd; Message, WParam: DWord;
  LParam: longint): Bool; stdcall;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR + 24, Message, wParam, lParam, 'WM_', True);
  {$ENDIF}

  case Message of

    WM_CTLCOLOR:
    begin
      if LOWORD(lParam) <> 0 then
      begin
        wParam := SendMessage(LOWORD(lParam), LB_GETCURSEL, 0, 0);
        if wParam >= 0 then
        begin
          wParam := word(SendMessage(LOWORD(lParam), LB_GETITEMDATA, wParam, 0));
          if wParam >= 0 then
            PostMessage(GetParent(Dialog), WM_USER + 100, wParam, lParam);
        end;
      end;
    end;

  end;
  IdleCBProc := BOOL(CallWindowProc(lpOldCBProc, Dialog, Message, wParam, lParam));
end;

{***************************************************************************}

function ProcessOptionsText(tQuestion: TypeQuestion; var mciMessage: TMCISTR): BOOL;

  {***************************************************************************}

var
  gOptions, tOptions: byte;
  szPasStr: array[0..255] of char;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR + 2, 0, 0, 0, nil, True);
  {$ENDIF}


  tOptions := tQuestion.Options and $F0;
  case tOptions of
    $10:
    begin
      StrCat(mciMessage, ' TEXT HIDEN');
    end;
    $20:
    begin
      StrCat(mciMessage, ' TEXT ZOOMED');
    end;
    $30:
    begin
      StrCat(mciMessage, ' TEXT DEFAULT');
    end;
    $40:
    begin
      StrCat(mciMessage, ' TEXT NORMAL');
    end;
    $50:
    begin
      StrPCopy(szPasStr, ' TEXT AT ' + IntToStr(tQuestion.tx1) +
        ' ' + IntToStr(tQuestion.ty1) + ' ' + IntToStr(tQuestion.tx2) +
        ' ' + IntToStr(tQuestion.ty2));

      StrCat(mciMessage, @szPasStr);
    end;

    else
    begin
      StrCat(mciMessage, ' TEXT NORMAL');
    end;
  end;

  if tQuestion.wStyle and QS_TXTTOP <> 0 then
    StrCat(mciMessage, ' TOP');

  if tQuestion.wStyle and QS_TXTBOTTOM <> 0 then
    StrCat(mciMessage, ' BOTTOM');

end;

{*************************************************************}


{***************************************************************************}

function ProcessOptionsBitmap(tQuestion: TypeQuestion;
  var mciMessage: TMCISTR): BOOL;

  {***************************************************************************}

var
  gOptions, tOptions: byte;
  szPasStr: array[0..255] of char;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_LAVACCR, nFUNC_LAVACCR + 3, 0, 0, 0, nil, True);
  {$ENDIF}


  {--Taille et style des fenêtres--}
  if tQuestion.wStyle and QS_STRECHED <> 0 then
    StrCat(mciMessage, ' STRETCHED')
  else
    StrCat(mciMessage, ' UNSTRETCHED');

  gOptions := tQuestion.Options and $0F;
  case gOptions of
    $01:
    begin
      StrCat(mciMessage, ' BITMAP HIDEN');
    end;
    $02:
    begin
      StrCat(mciMessage, ' BITMAP ZOOMED');
    end;
    $03:
    begin
      StrCat(mciMessage, ' BITMAP DEFAULT');
    end;
    $04:
    begin
      StrCat(mciMessage, ' BITMAP NORMAL');
    end;
    $05:
    begin
      StrPCopy(szPasStr, ' BITMAP AT ' + IntToStr(tQuestion.gx1) +
        ' ' + IntToStr(tQuestion.gy1) + ' ' +
        IntToStr(tQuestion.gx2) + ' ' +
        IntToStr(tQuestion.gy2));

      StrCat(mciMessage, @szPasStr);
    end;

    else
    begin
      StrCat(mciMessage, ' BITMAP NORMAL');
    end;
  end;

  if tQuestion.wStyle and QS_BMPTOP <> 0 then
    StrCat(mciMessage, ' TOP');

  if tQuestion.wStyle and QS_BMPBOTTOM <> 0 then
    StrCat(mciMessage, ' BOTTOM');

  if tQuestion.wVer >= $0400 then
  begin
    if tQuestion.wStyle and QS_STRECHED = 0 then
    begin
      StrPCopy(szPasStr, ' % ' + IntToStr(tQuestion.nZoom));
      StrCat(mciMessage, @szPasStr);
    end;

    if tQuestion.wStyle and QS_VIDEOBAR <> 0 then
    begin
      StrCat(mciMessage, ' TRACKBAR');
    end;

  end;
end;

{*************************************************************}

procedure FileSplit(szPath, szDir, szName, szExt: PChar);
var
  str_path: pathstr;
  str_dir: dirstr;
  str_name: namestr;
  str_ext: extstr;
begin
  str_path := string(szPath);
  FSplit(str_path, str_dir, str_name, str_ext);

  // fixed
  str_dir[Length(str_dir) + 1] := #0;
  // fixed
  str_name[Length(str_name) + 1] := #0;
  // fixed
  str_ext[Length(str_ext) + 1] := #0;

  StrCopy(szDir, PChar(@str_dir[1]));
  StrCopy(szName, PChar(@str_name[1]));
  StrCopy(szExt, PChar(@str_ext[1]));
end;


procedure UpdatePath(pszFile, pszPath: PChar);
var
  Dir: array[0..255] of char;
  Name: array[0..255] of char;
  Ext: array[0..255] of char;
begin
  FileSplit(pszFile, Dir, Name, Ext);
  if pszPath[StrLen(pszPath) - 1] = '\' then
  begin
    StrECopy(StrECopy(StrECopy(StrECopy(pszFile, pszPath), ''), Name), Ext);
  end
  else
  begin
    StrECopy(StrECopy(StrECopy(StrECopy(pszFile, pszPath), '\'), Name), Ext);
  end;
end;

{*----------------------------------------------------------------
 *
 *  IsCDROMDrive() -
 *
 * Purpose:  Return non-zero if drive is a CDROM drive
 *
 *  wDrive   drive index (0=A, 1=B, ...)
 *
 *  return   TRUE/FALSE
 *---------------------------------------------------------------*}

function IsCDROMDrive(wDrive: word): BOOL;

var
  f: BOOL;
begin

  f := False;
  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 1, 0, 0, 0, nil, True);
  {$ENDIF}

  IsCDROMDrive := f;
end;

function GetDriveType(Drive: integer): word;
var
  szDrive: array[0..4] of char;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 2, 0, 0, 0, nil, True);
  {$ENDIF}
  {
  if IsCDROMDrive(Drive) then
  begin
    GetDriveType := DRIVE_CDROM;
  end
  else
 }
 begin
    szDrive[0] := Chr(Drive + Ord('A'));
    szDrive[1] := ':';
    szDrive[2] := '\';
    szDrive[3] := #0;
    GetDriveType := Windows.GetDriveType(szDrive);
  end;
end;

{
function GetKeyboardLayoutName(pwszKLID : PCHAR) : BOOL; external 'USER';
function LoadKeyboardLayout(pwszKLID : PCHAR; uFlags : WORD) : DWORD; external 'USER';
function ActivateKeyboardLayout(hkl : DWORD;  Flags : WORD) : DWORD; external 'USER';
function GetKeyboardLayoutList(nBuff :integer; lpList : PLONGINT) : WORD; external 'USER';
}
function ActivateKeyboardFromCharset(bCharset: byte): longbool;
var
  dwKBList: array[1..100] of longint;
  dwOldKB: longbool;
  wKB: word;
  i: integer;
  bFind: bool;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 3, 0, 0, 0, nil, True);
  {$ENDIF}

  bFind := False;
  GetCurCharset := 255;
  wKB := GetKeyboardLayoutList(sizeOf(dwKBList), dwKBList);
  dwOldKB := ActivateKeyboardLayout(dwKBList[1], 0);
  for i := 1 to wKB do
  begin
    SetFocus(window);
    ActivateKeyboardLayout(dwKBList[i], 0);
    {WriteLn(bCharset, ' ', GetCurCharset);}
    if GetCurCharset = bCharset then
    begin
      bFind := True;
      break;
    end;
  end;
  if bFind then
  begin
    ActivateKeyboardFromCharset := dwOldKb;
  end
  else
  begin
    ActivateKeyboardLayout(longint(dwOldKb), 0);
    ActivateKeyboardFromCharset := longbool(-1);
  end;
end;

function ProcessHitTest(hWin: HWnd; Message, wParam: Dword; lParam: longint): word;
var
  pt: TPOINT;
  rc: TRECT;
  i: integer;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 4, 0, 0, 0, nil, True);
  {$ENDIF}

  FigureHandleSizes(hWin);

  GetClientRect(hWin, rc);
  pt.x := integer(LOWORD(lParam));
  pt.y := integer(HIWORD(lParam));

  for i := 0 to 7 do
  begin
    if PtInRect(DialogHandles[i].rcArea, pt) then
    begin
      ProcessHitTest := DialogHandles[i].dwNCHITVALUE;
      Exit;
    end;
  end;

  ProcessHitTest := HTCAPTION;

end;

{*************************************************************}
procedure UpdateHandle(hWin: HWND);
var
  rc: TRECT;
  i: integer;
  hNext: HWND;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 5, 0, 0, 0, nil, True);
  {$ENDIF}


  if hWin = 0 then
    exit;

  FigureHandleSizes(hWin);
  for i := 0 to 7 do
  begin
    rc := DialogHandles[i].rcArea;
    MapWindowPoints(HWND_DESKTOP, hWin, rc, 2);
    if (bWin95 or bWinNT) then
    begin
      InflateRect(rc, 1, 1);
    end;
    InvalidateRect(hWin, @rc, True);

    if hWin = hQcmProc then
    begin
      hNext := GetWindow(hWin, GW_CHILD);
      while hNext <> 0 do
      begin
        rc := DialogHandles[i].rcArea;
        MapWindowPoints(HWND_DESKTOP, hNext, rc, 2);
        if (bWin95 or bWinNT) then
        begin
          InflateRect(rc, 1, 1);
        end;
        InvalidateRect(hNext, @rc, True);
        hNext := GetWindow(hNext, GW_HWNDNEXT);
      end;
      SendMessage(hNext, WM_NCPAINT, 0, 0);

      hNext := GetWindow(GetWindow(hWin, GW_CHILD), GW_CHILD);
      while hNext <> 0 do
      begin
        rc := DialogHandles[i].rcArea;
        MapWindowPoints(HWND_DESKTOP, hNext, rc, 2);
        if (bWin95 or bWinNT) then
        begin
          InflateRect(rc, 1, 1);
        end;
        InvalidateRect(hNext, @rc, True);
        hNext := GetWindow(hNext, GW_HWNDNEXT);
      end;
      SendMessage(hNext, WM_NCPAINT, 0, 0);
    end;
  end;
  {SetWindowPos(hWin, 0, 0, 0, 0, 0, SWP_DRAWFRAME OR SWP_NOMOVE OR SWP_NOSIZE OR SWP_NOZORDER);}
  {SendMessage(hWin, WM_NCPAINT, 0, 0);}
end;

{*************************************************************}
procedure ShowHandle(DC: hDC; hWin: HWND);
var
  rc: TRECT;
  i: integer;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 6, 0, 0, 0, nil, True);
  {$ENDIF}


  FigureHandleSizes(hWin);
  for i := 0 to 7 do
  begin
    rc := DialogHandles[i].rcArea;
    MapWindowPoints(HWND_DESKTOP, hWin, rc, 2);
    if (GetWindowLong(hWin, GWL_STYLE) and WS_THICKFRAME) = WS_THICKFRAME then
    begin
      if (bWin95 or bWinNT) then
      begin
        OffSetRect(rc,
          GetSystemMetrics(SM_CXFRAME){ + 1},
          GetSystemMetrics(SM_CYFRAME){ + 1});
      end
      else
      begin
        OffSetRect(rc,
          GetSystemMetrics(SM_CXFRAME) + 1,
          GetSystemMetrics(SM_CYFRAME) + 1);
      end;
    end;
    FillRect(DC, rc, GetStockObject(DKGRAY_BRUSH));
  end;
end;

{*************************************************************}
procedure FigureHandleSizes(hWin: HWND);
var
  rc: TRECT;
  dx, dy: integer;

  procedure MakeHandle(iIndex, x, y: integer; dwHitValue: DWORD);
  begin

  {$IFDEF _DEBUG}
    AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 7, 0, 0, 0, nil, True);
  {$ENDIF}

    DialogHandles[iIndex].rcArea.left := x;
    DialogHandles[iIndex].rcArea.top := y;
    DialogHandles[iIndex].rcArea.right := x + dx + 1;
    DialogHandles[iIndex].rcArea.bottom := y + dy + 1;
    DialogHandles[iIndex].dwNCHITVALUE := dwHitValue;

  end;

begin
  dx := GetSystemMetrics(SM_CXFRAME) * 2 - 1;
  dy := GetSystemMetrics(SM_CYFRAME) * 2 - 1;

  GetWindowRect(hWin, rc);
  Dec(rc.right);
  Dec(rc.bottom);

  MakeHandle(0, rc.left, (rc.top + rc.bottom) div 2 - dy div 2, HTLEFT);
  MakeHandle(1, rc.right - dx, (rc.top + rc.bottom) div 2 - dy div 2, HTRIGHT);
  MakeHandle(2, (rc.left + rc.right) div 2 - dx div 2, rc.top, HTTOP);
  MakeHandle(3, rc.left, rc.top, HTTOPLEFT);
  MakeHandle(4, rc.right - dx, rc.top, HTTOPRIGHT);
  MakeHandle(5, (rc.left + rc.right) div 2 - dx div 2, rc.bottom - dy, HTBOTTOM);
  MakeHandle(6, rc.left, rc.bottom - dy, HTBOTTOMLEFT);
  MakeHandle(7, rc.right - dy, rc.bottom - dy, HTBOTTOMRIGHT);
end;

{*************************************************************}
function IsSoundFile(pFile: PChar): BOOL;
var
  Dir: array[0..255] of char;
  Name: array[0..255] of char;
  Ext: array[0..255] of char;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 8, 0, 0, 0, nil, True);
  {$ENDIF}

  FileSplit(pFile, Dir, Name, Ext);
  IsSoundFile := StrPos(szSoundExt, StrUpper(Ext)) <> nil;
end;

{*************************************************************}
function IsVideoFile(pFile: PChar): BOOL;
var
  Dir: array[0..255] of char;
  Name: array[0..255] of char;
  Ext: array[0..255] of char;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 8, 0, 0, 0, nil, True);
  {$ENDIF}

  FileSplit(pFile, Dir, Name, Ext);
  IsVideoFile := StrPos(szVideoExt, StrUpper(Ext)) <> nil;
end;

{*************************************************************}
function IsImageFile(pFile: PChar): BOOL;
var
  Dir: array[0..255] of char;
  Name: array[0..255] of char;
  Ext: array[0..255] of char;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 9, 0, 0, 0, nil, True);
  {$ENDIF}

  FileSplit(pFile, Dir, Name, Ext);
  IsImageFile := StrPos(szImageExt, StrUpper(Ext)) <> nil;
end;

{*************************************************************}
function IsTextFile(pFile: PChar): BOOL;
var
  Dir: array[0..255] of char;
  Name: array[0..255] of char;
  Ext: array[0..255] of char;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 10, 0, 0, 0, nil, True);
  {$ENDIF}

  FileSplit(pFile, Dir, Name, Ext);
  IsTextFile := StrPos(szTextExt, StrUpper(Ext)) <> nil;
end;

{*************************************************************}
procedure AdjustRectToDesktop(var rWin: TRECT);
var
  rNew, rDsk: TRECT;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 11, 0, 0, 0, nil, True);
  {$ENDIF}

  GetClientRect(window, rDsk);
  if (rDsk.right - rDsk.left > LAVACWIDTH) or (rDsk.bottom - rDsk.top >
    LAVACHEIGHT) then
  begin
    {WriteLn(rDsk.right - rDsk.left, ' ', rDsk.bottom - rDsk.top);}
    rNew.left := MulDiv(rWin.left, (rDsk.right - rDsk.left), LAVACWIDTH);
    rNew.top := MulDiv(rWin.top, (rDsk.bottom - rDsk.top), LAVACHEIGHT);
    rNew.right := MulDiv(rWin.right, (rDsk.right - rDsk.left), LAVACWIDTH);
    rNew.bottom := MulDiv(rWin.bottom, (rDsk.bottom - rDsk.top), LAVACHEIGHT);
    rWin := rNew;
  end;
end;

procedure AdjustToDesktop(Dialog: HWND);
var
  rDsk: TRECT;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 12, 0, 0, 0, nil, True);
  {$ENDIF}

  //GetWindowRect(GetDesktopWindow, rDsk);
  rDsk := rcApp;
  AdjustToRect(Dialog, rDsk, LAVACWIDTH, LAVACHEIGHT);
end;

{*************************************************************}
procedure AdjustToRect(Dialog: HWND; rDsk: TRECT; nWidth, nHeight: integer);
var
  rWin, rNew, rDlg: TRECT;
  hChild: HWND;
  nW, nH: integer;
  szClass: array[0..255] of char;

  procedure AdjustWindow(hWin: HWND);
  begin

          {$IFDEF _DEBUG}
    AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 13, 0, 0, 0, nil, True);
          {$ENDIF}

    GetWindowRect(hWin, rWin);
    rNew.left := MulDiv(rWin.left, (rDsk.right - rDsk.left), nWidth) - rDlg.left;
    rNew.top := MulDiv(rWin.top, (rDsk.bottom - rDsk.top), nHeight) - rDlg.top;
    rNew.right := MulDiv(rWin.right, (rDsk.right - rDsk.left), nWidth) - rDlg.left;
    rNew.bottom := MulDiv(rWin.bottom, (rDsk.bottom - rDsk.top), nHeight) - rDlg.top;
    GetClassName(hWin, szClass, SizeOf(szClass));
    {AutoCentré en X}
    if (StrComp(StrUpper(szClass), 'BORBTN') = 0) or
      (StrComp(StrUpper(szClass), 'STATIC') = 0) then
    begin
      nW := rNew.right - rNew.left;
      Inc(rNew.left, (nW - (rWin.right - rWin.left)) div 2);
      rNew.right := rNew.left + (rWin.right - rWin.left);
    end;
    {AutoCentré en Y}
    if (StrComp(StrUpper(szClass), 'BORBTN') = 0) or
      (StrComp(StrUpper(szClass), 'STATIC') = 0) or
      (StrComp(StrUpper(szClass), 'MCIWNDTRACKBAR') = 0) or
      (StrComp(StrUpper(szClass), 'EDIT') = 0) then
    begin
      nH := rNew.bottom - rNew.top;
      Inc(rNew.top, (nH - (rWin.bottom - rWin.top)) div 2);
      rNew.bottom := rNew.top + (rWin.bottom - rWin.top);
    end;
    if (StrComp(StrUpper(szClass), 'COMBOBOX') = 0) then
    begin
      Inc(rNew.bottom, (rDlg.bottom - rDlg.top) div 2);
    end;
    SetWindowPos(hWin,
      0,
      rNew.left,
      rNew.top,
      rNew.right - rNew.left,
      rNew.bottom - rNew.top,
      SWP_NOZORDER or SWP_NOREDRAW);
  end;

begin
  if (rDsk.right - rDsk.left > nWidth) or (rDsk.top - rDsk.bottom > nHeight) then
  begin
    { calcul nouvelles coordonées de la dialogue avec ajustement sur style }
    GetWindowRect(Dialog, rWin);
    rDlg.left := MulDiv(rWin.left, (rDsk.right - rDsk.left), nWidth);
    rDlg.top := MulDiv(rWin.top, (rDsk.bottom - rDsk.top), nHeight);
    rDlg.right := MulDiv(rWin.right, (rDsk.right - rDsk.left), nWidth);
    rDlg.bottom := MulDiv(rWin.bottom, (rDsk.bottom - rDsk.top), nHeight);
    rNew := rDlg;
    AdjustWindowRectEx(rNew, GetWindowLong(Dialog, GWL_STYLE),
      boolean(GetMenu(Dialog)), GetWindowLong(Dialog, GWL_EXSTYLE));
    //dec(rDlg.left, rNew.left - rDlg.left);
    //dec(rDlg.top, rNew.top - rDlg.top);

    { calcul nouvelles coordonées des enfants de la dialogue et les déplace }
    hChild := GetWindow(Dialog, GW_CHILD);
    while hChild <> 0 do
    begin
      AdjustWindow(hChild);
      hChild := GetWindow(hChild, GW_HWNDNEXT);
    end;

    { calcul nouvelles coordonées de la dialogue la déplace }
    GetWindowRect(Dialog, rWin);
    rDlg.left := MulDiv(rWin.left, (rDsk.right - rDsk.left), nWidth);
    rDlg.top := MulDiv(rWin.top, (rDsk.bottom - rDsk.top), nHeight);
    rDlg.right := MulDiv(rWin.right, (rDsk.right - rDsk.left), nWidth);
    rDlg.bottom := MulDiv(rWin.bottom, (rDsk.bottom - rDsk.top), nHeight);
    SetWindowPos(Dialog,
      0,
      rDlg.left,
      rDlg.top,
      rDlg.right - rDlg.left,
      rDlg.bottom - rDlg.top,
      SWP_NOZORDER or SWP_NOREDRAW);
  end;
end;

{*************************************************************}
procedure CenterDialog(Dialog: HWND);
var
  rDlg, rDsk: TRECT;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 14, 0, 0, 0, nil, True);
  {$ENDIF}

  //GetWindowRect(GetDesktopWindow, rDsk);
  rDsk := rcApp;
  GetWindowRect(Dialog, rDlg);
  SetWindowPos(Dialog, 0, (rDsk.right - rDsk.left) div 2 - (rDlg.right - rDlg.left) div 2,
    (rDsk.bottom - rDsk.top) div 2 - (rDlg.bottom - rDlg.top) div 2,
    0,
    0,
    SWP_NOZORDER or SWP_NOSIZE or SWP_NOREDRAW);
end;

{*************************************************************}
function GetItemData(Dialog: HWND; idCombo: word; no: integer): integer;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 15, 0, 0, 0, nil, True);
  {$ENDIF}

  GetItemData := SendDlgItemMessage(Dialog, idCombo, CB_GETITEMDATA,
    word(no), longint(0));
end;

function GetCurItemData(Dialog: HWND; idCombo: word): integer;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 16, 0, 0, 0, nil, True);
  {$ENDIF}

  GetCurItemData := -1;
  dwReturn := SendDlgItemMessage(Dialog, idCombo, CB_GETCURSEL, 0, longint(0));
  if (dwReturn <> CB_ERR) and (dwReturn <> CB_ERRSPACE) then
  begin
    GetCurItemData := SendDlgItemMessage(Dialog, idCombo, CB_GETITEMDATA,
      word(dwReturn), longint(0));
  end;
end;

{*************************************************************}

{*************************************************************}
procedure LessonInDlgCombo(Dialog: HWND; idCombo: word; bUpdate: boolean);
var
  nRec: integer;
  dwReturn: longint;
  szLecon: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 17, 0, 0, 0, nil, True);
  {$ENDIF}

  { récupère le nom en cours }
  if bUpdate then
    GetDlgItemText(Dialog, idCombo, szLecon, SizeOf(szLecon));

  { -- Charger dans la Combo la liste des leçons par ordre Alpha -- }
  SendDlgItemMessage(Dialog, idCombo, CB_RESETCONTENT, 0, 0);
  StrCopy(PathFichier, PathLecons);
  { Lecons.lst contient la liste des leçons }
  StrCat(PathFichier, 'LECONS.LST');
  Assign(fLecon, PChar(PathFichier));
  FileMode := OF_SHARE_DENY_NONE or OF_READ;
  {$i-}
  reset(fLecon);
  {$i+}
  if IOResult = 0 then
  begin
    nRec := 0;
    {$i-}
    while not EOF(fLecon) do
    begin
      Read(fLecon, tLecon);
      if tLecon.Syquest then
        StrCopy(tLecon.Nom, szCOMPRESS);
      {$IFDEF _ASSIST}
      if tLecon.bAssist <> 0 then
      begin
      {$ENDIF}
        dwReturn := SendDlgItemMessage(Dialog, idCombo, CB_ADDSTRING, 0, longint(@tLecon.Nom));
        if (dwReturn <> CB_ERR) and (dwReturn <> CB_ERRSPACE) then
        begin
          SendDlgItemMessage(Dialog, idCombo, CB_SETITEMDATA, word(dwReturn), longint(nRec));
        end;
      {$IFDEF _ASSIST}
      end;
      {$ENDIF}
      Inc(nRec);
      {$i+}
    end;
  end;
  {$i-}
  Close(fLecon);
  {$i+}
  if IOResult <> 0 then;
  FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;

  { repositionne sur la leçon en cours}
  if bUpdate then
  begin
    dwReturn := SendDlgItemMessage(Dialog, idCombo, CB_FINDSTRINGEXACT,
      word(-1), DWORD(@szLecon));
    if dwReturn <> CB_ERR then
    begin
      { si trouvée alors sélectionne }
      dwReturn := SendDlgItemMessage(Dialog, idCombo, CB_SETCURSEL, word(dwReturn), 0);
    end
    else
    begin
      { si pas trouvée alors sélectionne 1° }
      dwReturn := SendDlgItemMessage(Dialog, idCombo, CB_SETCURSEL, 0, 0);
    end;
  end;

end;

{*************************************************************}
procedure LessonInDlgLB(Dialog: HWND; idLB: word; bUpdate: boolean);
var
  nRec: integer;
  dwReturn: longint;
  szLecon: szLongName;
  PathFichier: szLongName;
  szErr: array[0..255] of char;
  Dir: array[0..fsDirectory] of char;
  Name: array[0..fsFileName] of char;
  Ext: array[0..fsExtension] of char;
  Drive: array[0..1] of char;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 18, 0, 0, 0, nil, True);
  {$ENDIF}

  { récupère le nom en cours }
  if bUpdate then
    GetDlgItemText(Dialog, idLB, szLecon, SizeOf(szLecon));

  { -- Charger dans la LB la liste des leçons par ordre Alpha -- }
  SendDlgItemMessage(Dialog, idLB, LB_RESETCONTENT, 0, 0);
  StrCopy(PathFichier, PathLecons);
  { Lecons.lst contient la liste des leçons }
  StrCat(PathFichier, 'LECONS.LST');
  Assign(fLecon, PChar(PathFichier));
  FileMode := OF_SHARE_DENY_NONE or OF_READ;
  {$i-}
  reset(fLecon);
  {$i+}

  if IOResult <> 0 then
  begin
    {$i-}
    Close(fLecon);
    {$i+}
    StrCopy(szErr, 'Le fichier ');
    StrCat(szErr, PathFichier);
    StrCat(szErr, ' n''existe pas, voulez-vous le créer ?');
    if MessageBox(Dialog, szErr, tLecon.Nom, MB_YESNO or MB_APPLMODAL) = idYes then
    begin

      InOutRes := 0;
      FileSplit(PathFichier, Dir, Name, Ext);
      if (Dir[StrLen(Dir) - 1] = '\') then
        Dir[StrLen(Dir) - 1] := #0;

      CreerRep(Dir);

      Assign(fLecon, PChar(PathFichier));
      FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;
      {$i-}
      rewrite(fLecon);
      {$i+}
      if IOResult <> 0 then
      begin
        StrCopy(szErr, 'Le fichier ');
        StrCat(szErr, PathFichier);
        StrCat(szErr, ' n''a pas été créé !');
        MessageBox(Dialog, szErr, tLecon.Nom, MB_OK or MB_APPLMODAL);
        InOutRes := 0;
        exit;
      end
      else
      begin
        {$i-}
        GetFattr(fLecon, wReturn);
        SetFattr(fLecon, wReturn or faShare);
        {$i+}
        if DosError <> 0 then
          InOutRes := DosError;
      end;

    end
    else
    begin
      InOutRes := -1;
    end;
  end;

  if IOResult <> 0 then
  begin
    {$i-}
    Close(fLecon);
    {$i+}
    InOutRes := 0;
    exit;
  end;

  {$i-}
  nRec := 0;
  while not EOF(fLecon) do
  begin
    Read(fLecon, tLecon);
    if tLecon.Syquest then
      StrCopy(tLecon.Nom, szCOMPRESS);
    dwReturn := SendDlgItemMessage(Dialog, idLB, LB_ADDSTRING, 0, longint(@tLecon.Nom));
    if (dwReturn <> LB_ERR) and (dwReturn <> LB_ERRSPACE) then
    begin
      SendDlgItemMessage(Dialog, idLB, LB_SETITEMDATA, word(dwReturn), longint(nRec));
    end;
    Inc(nRec);
  end;
  Close(fLecon);
  {$i+}
  if IOResult <> 0 then;
  FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;

  { repositionne sur la leçon en cours}
  if bUpdate then
  begin
    dwReturn := SendDlgItemMessage(Dialog, idLB, LB_FINDSTRINGEXACT,
      word(-1), DWORD(@szLecon));
    if dwReturn <> LB_ERR then
    begin
      { si trouvée alors sélectionne }
      dwReturn := SendDlgItemMessage(Dialog, idLB, LB_SETCURSEL, word(dwReturn), 0);
    end
    else
    begin
      { si pas trouvée alors sélectionne 1° }
      dwReturn := SendDlgItemMessage(Dialog, idLB, LB_SETCURSEL, 0, 0);
    end;
  end;

end;

{*************************************************************}

function MakeSharedFile(FileName: PChar): Bool;
var
  wReturn: word;
  f: file;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 19, 0, 0, 0, nil, True);
  {$ENDIF}

  {--ResetIOResult--}
  InOutRes := 0;
  {$I-}
  Assign(f, FileName);
  GetFattr(f, wReturn);
  SetFattr(f, wReturn or faShare);
  {$I+}
  MakeSharedFile := IOResult = 0;
end;

procedure ProcessCloseUp(hDlg, hCombo: HWND; var rDlg, rCombo: TRECT);
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 20, 0, 0, 0, nil, True);
  {$ENDIF}

  {$IFDEF _E0}
  Exit;
  {$ENDIF}
  MoveWindow(hCombo, rCombo.left, rCombo.top, rCombo.right - rCombo.left,
    rCombo.bottom - rCombo.top, False);
  SetWindowPos(hDlg, 0, rDlg.left, rDlg.top, rDlg.right, rDlg.bottom,
    SWP_NOZORDER or SWP_NOREDRAW);
end;

procedure ProcessDropDown(hDlg, hCombo: HWND; var rDlg, rCombo: TRECT);
var
  rBack: TRECT;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 21, 0, 0, 0, nil, True);
  {$ENDIF}

  {$IFDEF _E0}
  Exit;
  {$ENDIF}
  rBack := rCombo;
  if not (bWin95 or bWinNT) then
  begin
    SendMessage(hCombo, CB_GETDROPPEDCONTROLRECT, 0, longint(@rCombo));
    MapWindowPoints(HWND_DESKTOP, hDlg, rCombo, 2);
  end;
  SetWindowPos(hDlg, 0, rDlg.left, rDlg.top, 0, 0, SWP_NOZORDER or SWP_NOREDRAW);
  MoveWindow(hCombo, rCombo.left, rCombo.top,
    max(rCombo.right - rCombo.left, nMaxLargCombo), rCombo.bottom - rCombo.top, False);
  if (bWin95 or bWinNT) then
  begin
    rCombo := rBack;
  end;
end;

function sndPlaySoundResource(lpszRes: PChar): BOOL;
var
  hResInfo, hResData: THANDLE;
  lpResData: Pointer;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 22, 0, 0, 0, nil, True);
  {$ENDIF}

  hResInfo := FindResource(hInstRes, lpszRes, 'WAVE');
  hResData := LoadResource(hInstRes, hResInfo);
  lpResData := LockResource(hResData);
  sndPlaySoundResource := sndPlaySound(lpResData, SND_SYNC or SND_MEMORY);
  UnlockResource(hResData);
  FreeResource(hResData);
end;

{************************************************}

function SwapWindows(hWnd1, hWnd2: HWND): Bool;

  {************************************************}
var
  r: TRECT;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 23, 0, 0, 0, nil, True);
  {$ENDIF}

  ShowWindow(hWnd2, SW_SHOW);
  ShowWindow(hWnd1, SW_HIDE);
end;

{************************************************}
{       Fonction UpdateSbpMixBaseAddr            }
{ SE:                                            }
{ SI:                                            }
{************************************************}
function UpdateSbpMixBaseAddr: Bool;
  {------------------------------------------------}
var
  szAddr: szPName;
  ErrPos: integer;

  {------------------------------------------------}
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 24, 0, 0, 0, nil, True);
  {$ENDIF}

  GetPrivateProfileString('WAVE', 'SBP_PORT', 'FFFF', szAddr, SizeOf(szAddr), gszIni);
  Val('$' + StrPas(szAddr), SbpBaseAddr, ErrPos);
  if ErrPos <> 0 then
    SbpBaseAddr := $FFFF;
  UpdateSbpMixBaseAddr := (SbpBaseAddr <> $FFFF);
end;

{************************************************}

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure SetSbpMixSource(Source: byte);
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 25, 0, 0, 0, nil, True);
  {$ENDIF}

  if SbpBaseAddr <> $FFFF then
  begin
    {$IFDEF FALSE}
    Port[SbpBaseAddr + SbpMixAddrPort] := SbpMixInSetReg;
    wReturn := Port[SbpBaseAddr + SbpMixDataPort];
    Port[SbpBaseAddr + SbpMixDataPort] := wReturn and SbpMixSourceMask or Source;
    {$ENDIF}
  end
  else
  begin
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure SetSbpMixFilter(Filter: byte);
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 26, 0, 0, 0, nil, True);
  {$ENDIF}

  if SbpBaseAddr <> $FFFF then
  begin
    {$IFDEF FALSE}
    Port[SbpBaseAddr + SbpMixAddrPort] := SbpMixInSetReg;
    wReturn := Port[SbpBaseAddr + SbpMixDataPort];
    Port[SbpBaseAddr + SbpMixDataPort] := wReturn and SbpMixFilterMask or Filter;
    {$ENDIF}
  end
  else
  begin
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function LeadingZero(w: word): string;
var
  s: string;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 27, 0, 0, 0, nil, True);
  {$ENDIF}


  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 28, 0, 0, 0, nil, True);
  {$ENDIF}

  Str(w: 0, s);
  if Length(s) = 1 then
    s := '0' + s;
  LeadingZero := s;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function SystemTime: PChar;
var
  h, m, s, hund: word;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 29, 0, 0, 0, nil, True);
  {$ENDIF}

  GetTime(h, m, s, hund);
  StrPCopy(heure,
    LeadingZero(h) + ':' + LeadingZero(m) + ':' + LeadingZero(s));
  SystemTime := heure;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function IntToStr(I: longint): string;
  { Conversion d'entier en chaîne }
var
  S: string[11];
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 30, 0, 0, 0, nil, True);
  {$ENDIF}

  Str(I, S);
  IntToStr := S;
  while Pos(' ', S) > 0 do
    S[Pos(' ', S)] := '0';
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function AZTtoSTRING(AZT: PChar): string;
var
  s: string;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 31, 0, 0, 0, nil, True);
  {$ENDIF}

  // s[0] := Chr(StrLen(AZT));
  SetLength(s, StrLen(AZT));
  //Move(AZT^,s[1],StrLen(AZT));
  s := string(AZT);
  AZTtoSTRING := s;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function FileExist(FileName: PChar): boolean;
var
  DirInfo: TSearchRec;
    {F : Integer;
    TOF : TOFSTRUCT;}
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 32, 0, 0, 0, nil, True);
  {$ENDIF}

  FileExist := False;
  if FileName[0] <> #0 then
  begin
    DirInfo.size := 0;
    FindFirst(FileName, faAnyFile, DirInfo);
    //FileExist := (DosError = 0) and (DirInfo.Size <> 0);
    FileExist := DirInfo.Size <> 0;
    {F := OpenFile(FileName, TOF, OF_EXIST OR OF_SHARE_DENY_NONE);
    FileExist := F <> -1;}
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure CreerRep(Path: PChar);
var
  //Dir: array[0..fsDirectory] of Char;
  //Name: array[0..fsFileName] of Char;
  //Ext: array[0..fsExtension] of Char;
  Dir: array[0..255] of char;
  Name: array[0..255] of char;
  Ext: array[0..255] of char;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 33, 0, 0, 0, nil, True);
  {$ENDIF}

  FileSplit(Path, Dir, Name, Ext);
  if Name[0] <> #0 then
  begin
    if (Dir[StrLen(Dir) - 1] = '\') then
      Dir[StrLen(Dir)-1]:=#0;
    CreerRep(Dir);
    CreateDir(Path);
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure CopyErrorMessage(szMessage: PChar);
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 34, 0, 0, 0, nil, True);
  {$ENDIF}

  StrCopy(szMessage, 'Copy Error');
   {Case CopyError of
    LZERROR_BADINHANDLE  :
      StrCopy(szMessage, 'The handle identifying the source file was not valid.');
    LZERROR_BADOUTHANDLE:
      StrCopy(szMessage, 'The handle identifying the destination file was not valid.');
    LZERROR_BADVALUE    :
      StrCopy(szMessage, 'The input parameter is out of the allowable range.');
    LZERROR_GLOBALLOC   :
      StrCopy(szMessage, 'There is insufficient memory for the required buffers.');
    LZERROR_GLOBLOCK    :
      StrCopy(szMessage, 'The handle identifying the internal data structures is invalid.');
    LZERROR_READ         :
      StrCopy(szMessage, 'The source file format was not valid.');
    LZERROR_UNKNOWNALG   :
      StrCopy(szMessage, 'The source file was compressed with an unrecognized compression algorithm.');
    LZERROR_WRITE    :
      StrCopy(szMessage, 'There is insufficient space for the output file.');
      $0001: StrCopy(szMessage, 'Invalid function');
      $0002: StrCopy(szMessage, 'File not found');
      $0003: StrCopy(szMessage, 'Path not found');
      $0004: StrCopy(szMessage, 'Too many open files');
      $0005: StrCopy(szMessage, 'Access denied');
      $0006: StrCopy(szMessage, 'Invalid handle');
      $0007: StrCopy(szMessage, 'Arena trashed');
      $0008: StrCopy(szMessage, 'Not enough memory');
      $0009: StrCopy(szMessage, 'Invalid block');
      $000A: StrCopy(szMessage, 'Bad environment');
      $000B: StrCopy(szMessage, 'Bad format');
      $000C: StrCopy(szMessage, 'Invalid access');
      $000D: StrCopy(szMessage, 'Invalid data');
      $000F: StrCopy(szMessage, 'Invalid drive');
      $0010: StrCopy(szMessage, 'Current directory');
      $0011: StrCopy(szMessage, 'Not same device');
      $0012: StrCopy(szMessage, 'No more files');
      $0013: StrCopy(szMessage, 'Write protect error');
      $0014: StrCopy(szMessage, 'Bad unit');
      $0015: StrCopy(szMessage, 'Not ready');
      $0016: StrCopy(szMessage, 'Bad command');
      $0017: StrCopy(szMessage, 'CRC error');
      $0018: StrCopy(szMessage, 'Bad length');
      $0019: StrCopy(szMessage, 'Seek error');
      $001A: StrCopy(szMessage, 'Not MS-DOS disk');
      $001B: StrCopy(szMessage, 'Sector not found');
      $001C: StrCopy(szMessage, 'Out of paper');
      $001D: StrCopy(szMessage, 'Write fault');
      $001E: StrCopy(szMessage, 'Read fault');
      $001F: StrCopy(szMessage, 'General failure');
      $0020: StrCopy(szMessage, 'Sharing violation');
      $0021: StrCopy(szMessage, 'Lock violation');
      $0022: StrCopy(szMessage, 'Wrong disk');
      $0023: StrCopy(szMessage, 'File control block unavailable');
      $0024: StrCopy(szMessage, 'Sharing buffer exceeded');
      $0032: StrCopy(szMessage, 'Not supported');
      $0033: StrCopy(szMessage, 'Remote not listed');
      $0034: StrCopy(szMessage, 'Duplicate name');
      $0035: StrCopy(szMessage, 'Bad netpath');
      $0036: StrCopy(szMessage, 'Network busy');
      $0037: StrCopy(szMessage, 'Device does not exist');
      $0038: StrCopy(szMessage, 'Too many commands');
      $0039: StrCopy(szMessage, 'Adaptor hardware error');
      $003A: StrCopy(szMessage, 'Bad network response');
      $003B: StrCopy(szMessage, 'Unexpected network error');
      $003C: StrCopy(szMessage, 'Bad remote adaptor');
      $003D: StrCopy(szMessage, 'Print queue full');
      $003E: StrCopy(szMessage, 'No spool space');
      $003F: StrCopy(szMessage, 'Print canceled');
      $0040: StrCopy(szMessage, 'Netname deleted');
      $0041: StrCopy(szMessage, 'Network access denied');
      $0042: StrCopy(szMessage, 'Bad device type');
      $0043: StrCopy(szMessage, 'Bad network name');
      $0044: StrCopy(szMessage, 'Too many names');
      $0045: StrCopy(szMessage, 'Too many sessions');
      $0046: StrCopy(szMessage, 'Sharing paused');
      $0047: StrCopy(szMessage, 'Request not accepted');
      $0048: StrCopy(szMessage, 'Redirection paused');
      $0050: StrCopy(szMessage, 'File exists');
      $0051: StrCopy(szMessage, 'Duplicate file control block');
      $0052: StrCopy(szMessage, 'Cannot make');
      $0053: StrCopy(szMessage, 'Interrupt 24 failure');
      $0054: StrCopy(szMessage, 'Out of structures');
      $0055: StrCopy(szMessage, 'Already assigned');
      $0056: StrCopy(szMessage, 'Invalid password');
      $0057: StrCopy(szMessage, 'Invalid parameter');
      $0058: StrCopy(szMessage, 'Net write fault');
  end;}
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function FastCopyFile(Source, Dest: PChar): Bool;
var
  FD: integer;
  FS: integer;
  LZRet: longint;
  TOF1: TOFSTRUCT;
  TOF2: TOFSTRUCT;
  f: file;
  Dir: array[0..fsDirectory] of char;
  Name: array[0..fsFileName] of char;
  Ext: array[0..fsExtension] of char;
  Buf: array[0..2048] of char;
  Read, Write: word;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 35, 0, 0, 0, nil, True);
  {$ENDIF}

  CopyError := 0;
  FastCopyFile := False;
  FS := OpenFile(Source, TOF1, OF_READ or OF_SHARE_DENY_NONE);

  { test si pas compressés... }
  if FS = -1 then
  begin
    Source[strlen(Source) - 1] := '_';
    Dest[strlen(Dest) - 1] := '_';
    FS := OpenFile(Source, TOF1, OF_READ or OF_SHARE_DENY_NONE);
  end;

  if FS <> -1 then
  begin
    FileSplit(Dest, Dir, Name, Ext);
    if (Dir[StrLen(Dir) - 1] = '\') then
      Dir[StrLen(Dir) - 1] := #0;
    CreerRep(Dir);
    FD := OpenFile(Dest, TOF2, OF_CREATE or OF_SHARE_DENY_NONE);
    if FD <> -1 then
    begin
      {$i-}
      repeat
        Read := _LRead(FS, @Buf[0], SizeOf(Buf));
        Write := Read;
        if Write <> word(-1) then
          Write := _LWrite(FD, Buf, Read);
      until (Read = 0) or (Write = word(-1)) or (Write < Read);
      _LClose(FS);
      _LClose(FD);

      {--erreur en écriture--}
      if (Write = word(-1)) or (Write <> Read) then
      begin
        DeleteFile(Dest);
        CopyError := LZERROR_WRITE;
      end
      else
      begin
        Assign(f, Dest);
        GetfAttr(f, wReturn);
        SetfAttr(f, wReturn or faShare); {SHARE Flag}
        FastCopyFile := True;
      end;
      {$i+}
      InOutRes := 0;

    end
    else
    begin
      CopyError := TOF2.nErrCode;
      _LClose(FS);
    end;
  end
  else
  begin
    CopyError := TOF1.nErrCode;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function CopyFile(Source, Dest: PChar): Bool;
var
  FD: integer;
  FS: integer;
  LZRet: longint;
  TOF1: TOFSTRUCT;
  TOF2: TOFSTRUCT;
  f: file;
var
  Dir: array[0..fsDirectory] of char;
  Name: array[0..fsFileName] of char;
  Ext: array[0..fsExtension] of char;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 36, 0, 0, 0, nil, True);
  {$ENDIF}

  SetCursor(LoadCursor(0, IDC_WAIT));
  CopyError := 0;
  CopyFile := False;
  FS := LZOpenFile(Source, TOF1, OF_READ or OF_SHARE_DENY_NONE);

  { test si pas compressés... }
  if FS = -1 then
  begin
    Source[strlen(Source) - 1] := '_';
    { si compressé récup nom d'origine... }
    if GetExpandedName(Source, Dir) >= 0 then
    begin
      Dest[strlen(Dest) - 1] := Dir[strlen(Dir) - 1];
    end;
    FS := LZOpenFile(Source, TOF1, OF_READ or OF_SHARE_DENY_NONE);
  end;

  if FS <> -1 then
  begin
    FileSplit(Dest, Dir, Name, Ext);
    if (Dir[StrLen(Dir) - 1] = '\') then
      Dir[StrLen(Dir) - 1] := #0;
    CreerRep(Dir);
    FD := OpenFile(Dest, TOF2, OF_CREATE or OF_SHARE_DENY_NONE);
    if FD <> -1 then
    begin
      LZRet := LZCopy(FS, FD);
      LZClose(FS);
      _LClose(FD);

      Assign(f, Dest);
      GetfAttr(f, wReturn);
      SetfAttr(f, wReturn or faShare); {SHARE Flag}

      if LZRet >= 0 then
        CopyFile := True
      else
        CopyError := LZRet;
    end
    else
    begin
      CopyError := TOF2.nErrCode;
      LZClose(FS);
    end;
  end
  else
  begin
    CopyError := TOF1.nErrCode;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function DeleteFile(FileName: PChar): Bool;
var
  F: integer;
  TOF: TOFSTRUCT;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 37, 0, 0, 0, nil, True);
  {$ENDIF}

  DeleteFile := False;
  if StrLen(FileName) > 0 then
  begin
    F := OpenFile(FileName, TOF, OF_DELETE or OF_SHARE_DENY_NONE);
    if F <> -1 then
      DeleteFile := True;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function HookBmpFunc(Dialog: HWnd; Message, WParam: DWord;
  LParam: longint): DWord; stdcall;

var
  hHookDIB: THandle;
  pHookDIB: PBitmapInfo;
  pHookBits: Pointer;
  hHookPal: THandle;
  pHookPal: PLOGPALETTE;
  HookPalette: HPalette;
  F: integer;              { File Handle for Windows file functions }
  Header: TBitmapFileHeader;    { Bitmap file header }
  i, Size, N: longint;              { Size of bitmap, Size of color spec }
  TPE: TPaletteEntry;
  R: TRECT;
  rItem: TRECT;
  DCG: HDC;
  PathFichier: array[0..fsPathName] of char;
  wReturn: word;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 38, 0, 0, 0, nil, True);
  {$ENDIF}

  HookBmpFunc := 0;
  case Message of
    wm_initdialog:
    begin
      CenterDialog(Dialog);
    end;

    wm_command:
      case LoWord(wParam) of
        id_ComDlg_LB_File:
          //Case HiWord(LPARAM) of
          case HiWord(wParam) of
            LBN_SELCHANGE:
            begin
              wReturn := word(SendDlgItemMessage(Dialog, id_ComDlg_LB_File, LB_GETCURSEL, 0, 0));
              SendDlgItemMessage(Dialog, id_ComDlg_LB_File, LB_GETTEXT,
                wReturn, DWORD(@PathFichier));

              {Load Bitmap}
              F := _LOpen(PathFichier, of_Read);
              if F = -1 then
                Exit;

              { read in the Bitmap file header }
              if (_LRead(F, @Header, SizeOf(Header)) <> SizeOf(Header)) or
                (Header.bfType <> BMType) then
              begin
                _LClose(F);
                Exit;
              end;

              { read the rest of the file }
              Size := _LFileSize(F) - SizeOf(TBitmapFileHeader);
              hHookPal := GlobalAlloc(GPTR, SizeOf(TLogPalette) +
                SizeOf(TPaletteEntry) * 256);  { Allocate the memory }
              hHookDIB := GlobalAlloc(GPTR, Size);  { Allocate the memory }
              if (hHookDIB = 0) or (hHookPal = 0) then
              begin
                _LClose(F);
                GlobalUnlock(hHookDIB);
                GlobalFree(hHookDIB);
                GlobalUnlock(hHookPal);
                GlobalFree(hHookPal);
                hHookDIB := 0;
                hHookPal := 0;
                pHookDIB := nil;
                pHookPal := nil;
                Exit;
              end;

              pHookDIB := GlobalLock(hHookDIB);        { Lock it down }
              pHookPal := GlobalLock(hHookPal);        { Lock it down}

              {HugeIO ####}
              if (_LRead(F, pHookDIB, Size) <> 0) and
                (pHookDIB^.bmiHeader.biSize = SizeOf(TBitmapInfoHeader)) then
              begin
                { Compute the offset from the beginning of P^ }
                { where the actual image begins }
                N := Header.bfOffBits - SizeOf(TBitmapFileHeader);
                pHookBits := pHookDIB + N;

                { actually create the Bitmap }

                DCG := GetDC(Dialog);

                if pHookDIB^.bmiHeader.biBitCount = 8 then
                begin
                  pHookPal^.palVersion := $300;
                  pHookPal^.palNumEntries := 256;
                  HookPalette := CreatePalette(pHookPal^);
                  for i := 0 to 255 do
                  begin
                    TPE.peRed := pHookDIB^.bmiColors[i].rgbRed;
                    TPE.peGreen := pHookDIB^.bmiColors[i].rgbGreen;
                    TPE.peBlue := pHookDIB^.bmiColors[i].rgbBlue;
                    TPE.peFlags := PC_NOCOLLAPSE;
                    SetPaletteEntries(HookPalette, i, 1, TPE);
                  end;
                  DeleteObject(SelectPalette(DCG, HookPalette, False));
                  RealizePalette(DCG);
                end
                else
                begin
                  HookPalette := 0;
                end;

                GetItemRect(Dialog, Dlgs.cmb2, rItem);
                PatBlt(DCG, rItem.Right + 3, rItem.Bottom - 80 - 2,
                  106 + 2, 80 + 2, Blackness);
                SetStretchBltMode(DCG, STRETCH_DELETESCANS);
                StretchDIBits(DCG, rItem.Right + 3 + 1, rItem.Bottom - 80 - 1, 106, 80,
                  0, 0, pHookDIB^.bmiHeader.biWidth, pHookDIB^.bmiHeader.biHeight,
                  pHookBits,
                  pHookDIB^,
                  dib_RGB_Colors,
                  SRCCOPY);

                ReleaseDC(Dialog, DCG);
              end;
              _LClose(F);
              GlobalUnlock(hHookDIB);
              GlobalFree(hHookDIB);
              GlobalUnlock(hHookPal);
              GlobalFree(hHookPal);
              hHookDIB := 0;
              hHookPal := 0;
              pHookDIB := nil;
              pHookPal := nil;
            end;
          end;
      end;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function HookWavFunc(Dialog: HWnd; Message: DWord; WParam: longint;
  LParam: longint): DWord; stdcall;

var
  HookPathFichier: szLongName;
  wMyReturn: integer;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 39, 0, 0, 0, nil, True);
  {$ENDIF}

  HookWavFunc := 0;
  case Message of

    wm_InitDialog:
    begin
      CenterDialog(Dialog);
    end;

    wm_command:
      case LoWord(wParam) of
        id_ComDlg_LB_File:
          //Case HiWord(LPARAM) of
          case HiWord(wParam) of
            LBN_SELCHANGE:
            begin
              wMyReturn := SendDlgItemMessage(Dialog, id_ComDlg_LB_File, LB_GETCURSEL, 0, 0);
              SendDlgItemMessage(Dialog, id_ComDlg_LB_File, LB_GETTEXT,
                wMyReturn, DWORD(@HookPathFichier));
              {Play Wave}
              sndPlaySound(HookPathFichier, SND_ASYNC);
            end;
          end;
      end;

  end;
end;

{

DWORD CALLBACK RtfStreaminCallback
(
DWORD dwCookie, // application-defined value
LPBYTE pbBuff, // data buffer
LONG cb, // number of bytes to read or write
LONG *pcb // number of bytes transferred
)
{
CString* pStr = (CString*) dwCookie;
*pcb = min(pStr-&gt;GetLength(), cb);
memmove(pbBuff, pStr-&gt;GetBuffer(0), *pcb);
pStr-&gt;Right(pStr-&gt;GetLength() - (*pcb));
return 0;
}

}

function RTFStreamInCallback(dwCookie: DWORD_PTR; pbBuff: LPBYTE;
  cb: LONG; pcb: LPLONG): DWORD; stdcall;
var ret_cb : LONG;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 40, 0, 0, 0, nil, True);
  {$ENDIF}

  { Read in up to cb bytes}
  ret_cb := _lread(THANDLE(dwCookie), pbBuff, cb);
  { Check to see if we reached the EOF or encountered an error}
  if ret_cb <= 0 then
    ret_cb := 0;    { signal EOF to edit control}
  pcb^ := ret_cb;
  RTFStreamInCallback := 0;
end;

var   es: EDITSTREAM;
procedure MyLoadRTFFile(hRTFWnd: HWND; szFileName: PChar; wStreamFormat: word);
var
  hF: THANDLE;
  tof: TOFSTRUCT;
  MSG: TMSG;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 41, 0, 0, 0, nil, True);
  {$ENDIF}


  { Standard means of opening a file }
  hF := OpenFile(szFileName, tof, OF_READ);

  if hF = THANDLE(-1) then
  begin
    MessageBox(GetActiveWindow, szFileName, 'Fichier introuvable',
      MB_OK or MB_ICONEXCLAMATION);
    Exit;
  end;

  { Use the cookie for the file handle}
  es.dwCookie := DWORD(hF);
  { No error to start with }
  es.dwError := 0;
  { Set the callback function to the above sample }
  es.pfnCallback := @RTFStreamInCallback;

  { Just do it }
  SendMessage(hRTFWnd, EM_STREAMIN, wStreamFormat, longint(@es));

  { Close yer file }
  _lclose(hF);
  while PeekMessage(MSG, 0, 0, 0, PM_REMOVE) do
  begin

  {$IFDEF _DEBUG}
    AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 42, 0, 0, 0, nil, True);
  {$ENDIF}

    TranslateMessage(MSG);
    DispatchMessage(MSG);
  end;
end;

function RTFStreamOutCallback(dwCookie: DWORD_PTR; pbBuff: LPBYTE;
  cb: LONG; pcb: LPLONG): DWORD; stdcall;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 43, 0, 0, 0, nil, True);
  {$ENDIF}

  { Write out up to cb bytes}
  pcb^ := _lWrite(THANDLE(dwCookie), PCHAR(pbBuff), cb);
  { Check to see if we reached the EOF or encountered an error}
  if pcb^ <= 0 then
    pcb^ := 0;    { signal EOF to edit control}
  RTFStreamOutCallback := 0;
end;

procedure MySaveRTFFile(hRTFWnd: HWND; szFileName: PChar; wStreamFormat: word);
var
  hF: THANDLE;
  tof: TOFSTRUCT;
  es: EDITSTREAM;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 44, 0, 0, 0, nil, True);
  {$ENDIF}


  { Standard means of opening a file }
  hF := OpenFile(szFileName, tof, OF_WRITE);

  if hF = THANDLE(-1) then
  begin
    MessageBox(GetActiveWindow, szFileName, 'Fichier impossible à ouvrir',
      MB_OK or MB_ICONEXCLAMATION);
    Exit;
  end;

  { Use the cookie for the file handle}
  es.dwCookie := DWORD(hF);
  { No error to start with }
  es.dwError := 0;
  { Set the callback function to the above sample }
  es.pfnCallback := @RTFStreamOutCallback;
  { Just do it }
  SendMessage(hRTFWnd, EM_STREAMOUT, wStreamFormat, longint(@es));
  { Close yer file }
  _lclose(hF);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function HookTxtFunc(Dialog: HWnd; Message, WParam: DWord;
  LParam: longint): DWord; stdcall;

var
  wMyReturn: integer;
  R: TRECT;
  wRead: word;
  wSize: word;
  hBuffer: THANDLE;
  lpszBuffer: PChar;
  f: file;
  szEdit: array[0..8] of char;
  HookPathFichier: szLongName;
  hdcChild: HDC;
  hwndChild: HWND;
  nCtlType: integer;
  hF: THANDLE;
  tof: TOFSTRUCT;
  es: EDITSTREAM;
  hFnt: HFONT;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 45, 0, 0, 0, nil, True);
  {$ENDIF}

  HookTxtFunc := 0;
  case Message of
    wm_initdialog:
    begin
      GetWindowRect(Dialog, R);
      {szEdit[0] := 'E';
      szEdit[1] := 'D';
      szEdit[2] := 'I';
      szEdit[3] := 'T';
      szEdit[4] := #0;

      szEdit[0] := 'R';
      szEdit[1] := 'I';
      szEdit[2] := 'C';
      szEdit[3] := 'H';
      szEdit[4] := 'E';
      szEdit[5] := 'D';
      szEdit[6] := '1';
      szEdit[7] := '6';
      szEdit[8] := #0;

      MoveWindow(Dialog,R.left, R.top, R.right - R.left, R.Bottom - R.top + 116, FALSE);
      CenterDialog(Dialog);
      GetClientRect(Dialog,R);
      CreateWindow(szEdit,
                   @szEdit[8],
                   WS_CHILD OR
                   WS_BORDER OR
                   WS_VISIBLE OR
                   WS_VSCROLL OR
                   WS_HSCROLL OR
                   ES_MULTILINE OR
                   ES_AUTOHSCROLL OR
                   ES_AUTOVSCROLL,
                   8,
                   R.Bottom-108,
                   R.Right - 16,
                   100,
                   Dialog,
                   32767,
                   GetWindowWord(Dialog, GWW_HINSTANCE),
                   nil);
      SendDlgItemMessage(Dialog, 32767, WM_SETFONT,
                         SendDlgItemMessage(Dialog, Dlgs.lst1, WM_GETFONT, 0, 0),
                         0);
      SendDlgItemMessage(Dialog, 32767, WM_USER + 77, 2, 1);
      SendDlgItemMessage(Dialog, 32767, EM_SETTARGETDEVICE, 0, 0);}
    end;

      {WM_CTLCOLOR :
      begin
        hdcChild  := wParam;
        hwndChild := LOWORD(lParam);
        nCtlType  := HIWORD(lParam);
        HookTxtFunc := GetClassWord(hBoutonsProc, GCW_HBRBACKGROUND);
        if nCtlType = CTLCOLOR_DLG then begin
        end;
      end;}

    wm_command:
      case LoWord(wParam) of
        id_ComDlg_LB_File:
          //Case HiWord(LPARAM) of
          case HiWord(wParam) of
            LBN_SELCHANGE:
            begin
              wMyReturn := SendDlgItemMessage(Dialog, id_ComDlg_LB_File, LB_GETCURSEL, 0, 0);
              SendDlgItemMessage(Dialog, id_ComDlg_LB_File, LB_GETTEXT,
                wMyReturn, DWORD(@HookPathFichier));
              {Display Texte}
              { Standard means of opening a file }
              hF := OpenFile(HookPathFichier, tof, OF_READ);
              { Use the cookie for the file handle}
              es.dwCookie := DWORD(hF);
              { No error to start with }
              es.dwError := 0;
              { Set the callback function to the above sample }
              es.pfnCallback := @RTFStreamInCallback;
              { Just do it }
              if StrPos(StrUpper(HookPathFichier), '.RTF') <> nil then
              begin

  {$IFDEF _DEBUG}
                AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 46, 0, 0, 0, nil, True);
  {$ENDIF}

                SendMessage(GetDlgItem(Dialog, 32767),
                  EM_STREAMIN,
                  SF_RTF,
                  longint(@es));
              end
              else
              begin
                SendMessage(GetDlgItem(Dialog, 32767),
                  EM_STREAMIN,
                  SF_TEXT,
                  longint(@es));
              end;
              { Close yer file }
              _lclose(hF);
            end;
          end;
      end;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function GetFileName(Libelle, DefExt: PChar): PChar;
var
  OpenFN: TOpenFileNameA;
  Filter: array [0..100] of char;
  FileName: szLongName;
  ElementName: szLongName;
  TemplateName: szLongName;
  MyMenu: HMenu;

const
  szExeExt: array [0..70] of char =
    'Systeme' + #0 + '*.COM' + #0 + 'Batch' + #0 +
    '*.BAT' + #0 + 'DosWin' + #0 +
    '*.PIF' + #0 + 'Tous' + #0 +
    '*.EXE;*.COM;*.BAT;*.PIF' + #0 + #0;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 47, 0, 0, 0, nil, True);
  {$ENDIF}

  StrCopy(FileName, '');
  StrCopy(ElementName, '');

{ Set up a filter buffer to look for Wave files only.  Recall that filter
  buffer is a set of string pairs, with the last one terminated by a
  double-null.
}
  FillChar(Filter, SizeOf(Filter), #0);  { Set up for double null at end }
  StrCopy(Filter, Libelle);
  StrCopy(@Filter[StrLen(Filter) + 1], '*.');
  StrCopy(@Filter[StrLen(Filter) + 3], DefExt);
  if (StrIComp(DefExt, 'EXE') = 0) then
  begin
    Move(szExeExt, Filter[StrLen(Filter) + 7], sizeof(szExeExt));
  end;

  FillChar(OpenFN, SizeOf(TOpenFileName), #0);

  with OpenFN do
  begin
    hInstance := HInstRes;
    hwndOwner := GetActiveWindow;
    lpstrDefExt := DefExt;
    lpstrFile := ElementName;
    lpstrFilter := Filter;
    lpstrFileTitle := nil;     {Title not needed right now ... use full path }
    flags := ofn_FileMustExist;
    lStructSize := SizeOf(TOpenFileName);
    nFilterIndex := 1;       {Use first Filter String in lpstrFilter}
    nMaxFile := SizeOf(FileName);
    Flags := Flags or OFN_HIDEREADONLY;
    {lpHookFunc    := nil;}

    if StrComp(StrUpper(DefExt), 'WAV') = 0 then
    begin
      Flags := Flags or OFN_ENABLEHOOK;
      lpFnHook := LPOFNHOOKPROC(@HookWavFunc);
      {lpHookFunc := MakeProcInstance(@HookWavFunc, HInstance);}
    end;

    if StrPos(szImageExt, StrUpper(DefExt)) <> nil then
    begin
      Flags := Flags or OFN_ENABLEHOOK;
      lpFnHook := LPOFNHOOKPROC(@HookBmpFunc);
      {lpHookFunc := MakeProcInstance(@HookBmpFunc, HInstance);}
    end;

    if StrPos(szTextExt, StrUpper(DefExt)) <> nil then
    begin
      Flags := Flags or OFN_ENABLEHOOK;
      lpFnHook := LPOFNHOOKPROC(@HookTxtFunc);
      Flags := Flags or OFN_ENABLETEMPLATE;
      StrCopy(TemplateName, 'OpenText');
      lpTemplateName := @TemplateName;
    end;

    if StrComp(StrUpper(DefExt), 'LST') = 0 then
    begin
      Flags := Flags and not ofn_FileMustExist and not ofn_PathMustExist;
      StrCopy(Filter, Libelle);
      StrCopy(@Filter[StrLen(Filter) + 1], 'LECONS.LST');
      lpstrFilter := Filter;
      lpstrDefExt := nil;
    end;

  end;

  {#### attention renvoie pointeur sur chaine allouée en pile, ça marche mais ... }
  if GetOpenFileNamePreview(@OpenFN) then
  begin
    GetFileName := StrNew(OPenFN.lpstrFile);
  end
  else
  begin
    GetFileName := nil;
  end;

  {if lpHookFunc <> nil then FreeProcInstance(lpHookFunc);}
  if StrComp(StrUpper(DefExt), 'WAV') = 0 then
  begin
    MessageBeep(0);
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function GetItemRect(hDlg: hWnd; ID: word; var IDRect: TRect): Bool;
var
  IWnd: hWnd;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 48, 0, 0, 0, nil, True);
  {$ENDIF}

  IWnd := GetDlgItem(hDlg, ID);
  GetWindowRect(IWnd, IDRect);
  MapWindowPoints(HWND_DESKTOP, hDlg, IDRect, 2);
  GetItemRect := IWnd <> 0;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function RectIntersect(R1, R2: TRect): Bool;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 49, 0, 0, 0, nil, True);
  {$ENDIF}

  RectIntersect := False;
  if (R2.Left >= R1.Left) and (R2.Left <= R1.Right) and (R2.Top >= R1.Top) and
    (R2.Top <= R1.Bottom) then
  begin
    RectIntersect := True;
  end
  else
  begin
    if (R2.Right >= R1.Left) and (R2.Right <= R1.Right) and
      (R2.Top >= R1.Top) and (R2.Top <= R1.Bottom) then
    begin
      RectIntersect := True;
    end
    else
    begin
      if (R2.Left >= R1.Left) and (R2.Left <= R1.Right) and
        (R2.Bottom >= R1.Top) and (R2.Bottom <= R1.Bottom) then
      begin
        RectIntersect := True;
      end
      else
      begin
        if (R2.Right >= R1.Left) and (R2.Right <= R1.Right) and
          (R2.Bottom >= R1.Top) and (R2.Bottom <= R1.Bottom) then
        begin
          RectIntersect := True;
        end;
      end;
    end;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure AfficheBitmap;
var
  R: TRECT;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 50, 0, 0, 0, nil, True);
  {$ENDIF}

  GetClientRect(hGraphiqueProc, R);
  InvalidateRect(hGraphiqueProc, @R, True);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure AfficheBitmapNow;
var
  R: TRECT;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 51, 0, 0, 0, nil, True);
  {$ENDIF}

  GetClientRect(hGraphiqueProc, R);
  InvalidateRect(hGraphiqueProc, @R, True);
  PostMessage(hGraphiqueProc, wm_size, 0, 0);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure AfficheBitmapIn(hWind: hWnd; InX, InY: longint; var hInDIB: THandle;
  var pInDIB: PBitmapInfo;
  var pInBits: POINTER; InPalette: hPalette; Erase, Stretch: Bool);
var
  R: TRECT;
  DC, DCG: HDC;
  hOldActive: HWND;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 52, 0, 0, 0, nil, True);
  {$ENDIF}

  if hInDIB <> 0 then
  begin
    hOldActive := SetActiveWindow(hWind);
    DCG := GetDC(hWind);
    GetClientRect(hWind, R);
    if Erase then
      PatBlt(DCG, 0, 0, R.Right, R.Bottom, Whiteness);
    if pInDIB^.bmiHeader.biBitCount = 8 then
    begin
      DeleteObject(SelectPalette(DCG, InPalette, False));
      RealizePalette(DCG);
    end;
    if Stretch then
    begin
      SetStretchBltMode(DCG, STRETCH_DELETESCANS);
      StretchDIBits(DCG, InX, InY, R.Right - InX, R.Bottom - InY,
        0, 0, pInDIB^.bmiHeader.biWidth, pInDIB^.bmiHeader.biHeight,
        pInBits,
        pInDIB^,
        dib_RGB_Colors,
        SRCCOPY);
    end
    else
    begin
      StretchDIBits(DCG, InX, InY, pInDIB^.bmiHeader.biWidth,
        pInDIB^.bmiHeader.biHeight,
        0, 0, pInDIB^.bmiHeader.biWidth, pInDIB^.bmiHeader.biHeight,
        pInBits,
        pInDIB^,
        dib_RGB_Colors,
        SRCCOPY);
    end;
    ReleaseDC(hWind, DCG);
    SetActiveWindow(hOldActive);
  end;
end;

function TwipsToPixels(nTwips, nDirection: integer): integer;
var
  dc: HDC;
  nPixelsPerInch: integer;

const
  nTwipsPerInch = 1440;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 53, 0, 0, 0, nil, True);
  {$ENDIF}

  dc := GetDC(0);
  if (nDirection = 0) then
    nPixelsPerInch := GetDeviceCaps(dc, LOGPIXELSX)
  else
    nPixelsPerInch := GetDeviceCaps(dc, LOGPIXELSY);

  dc := ReleaseDC(0, dc);
  TwipsToPixels := MulDiv(nTwips, nPixelsPerInch, nTwipsPerInch);
end;

function PixelsToTwips(nPixels, nDirection: integer): integer;
var
  dc: HDC;
  nPixelsPerInch: integer;

const
  nTwipsPerInch = 1440;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 54, 0, 0, 0, nil, True);
  {$ENDIF}

  dc := GetDC(0);
  if (nDirection = 0) then
    nPixelsPerInch := GetDeviceCaps(dc, LOGPIXELSX)
  else
    nPixelsPerInch := GetDeviceCaps(dc, LOGPIXELSY);

  dc := ReleaseDC(0, dc);
  PixelsToTwips := MulDiv(nPixels, nTwipsPerInch, nPixelsPerInch);
end;


function RtfGetVal(pszLine, pszField: PChar): integer;
var
  psz: PChar;
  nVal, nErr, nPos: integer;
  c: char;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 55, 0, 0, 0, nil, True);
  {$ENDIF}

  nVal := -1;
  psz := StrPos(pszLine, pszField);
  if psz <> nil then
  begin
    Inc(psz, StrLen(pszField));
    Val(psz, nVal, nPos);
    if nPos <> 0 then
    begin
      nErr := nPos - 1;
      c := psz[nErr];
      psz[nErr] := #0;
      Val(psz, nVal, nPos);
      psz[nErr] := c;
    end;
    if nPos <> 0 then
    begin
      nVal := -1;
    end;
  end;
  RtfGetVal := nVal;
end;

function RtfGetPageInfo(szFileName: PChar; var nPaperw: integer;
  var nPaperh: integer; var nMargl: integer;
  var nMargr: integer; var nMargt: integer;
  var nMargb: integer): integer;
var
  f: Text;
  szLine: array[0..1024] of char;
  nVal: integer;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 56, 0, 0, 0, nil, True);
  {$ENDIF}

  RtfGetPageInfo := -1;
  {$i-}
  Assign(f, szFileName);
  reset(f);
  {$i+}
  if IOResult <> 0 then
    exit;

  {$i-}
  nVal := -1;
  nPaperw := -1;
  nPaperh := -1;
  nMargl := -1;
  nMargr := -1;
  nMargt := -1;
  nMargb := -1;
  while not EOF(f) and (InOutRes = 0) and ((nPaperw = -1) or
      (nPaperh = -1) or (nMargl = -1) or (nMargr = -1) or
      (nMargt = -1) or (nMargb = -1)) do
  begin
    ReadLn(f, szLine);

    nVal := RtfGetVal(szLine, '\paperw');
    if nVal <> -1 then
      nPaperw := nVal;

    nVal := RtfGetVal(szLine, '\paperh');
    if nVal <> -1 then
      nPaperh := nVal;

    nVal := RtfGetVal(szLine, '\margl');
    if nVal <> -1 then
      nMargl := nVal;

    nVal := RtfGetVal(szLine, '\margr');
    if nVal <> -1 then
      nMargr := nVal;

    nVal := RtfGetVal(szLine, '\margt');
    if nVal <> -1 then
      nMargt := nVal;

    nVal := RtfGetVal(szLine, '\margb');
    if nVal <> -1 then
      nMargb := nVal;

  end;

  Close(f);
  {$i+}
  if IOResult = 0 then
    RtfGetPageInfo := 0;
end;

function RtfSetVal(pszLine, pszField: PChar; nNewVal: integer): integer;
var
  psz: PChar;
  nVal, nErr, nPos: integer;
  c: char;
  pszFormat: array[0..1024] of char;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 57, 0, 0, 0, nil, True);
  {$ENDIF}

  nVal := -1;
  psz := StrPos(pszLine, pszField);
  if psz <> nil then
  begin

    { Copier le début de la chaine }
    c := psz[0];
    psz[0] := #0;
    StrCopy(pszFormat, pszLine);
    psz[0] := c;

    StrCat(pszFormat, pszField);
    StrCat(pszFormat, '%d');

    Inc(psz, StrLen(pszField));
    Val(psz, nVal, nPos);
    if nPos <> 0 then
    begin
      Inc(psz, nPos - 1);
      StrCat(pszFormat, psz);
    end;
    wvsprintf(pszLine, pszFormat, @nNewVal);
  end;
  RtfSetVal := nNewVal;
end;

function RtfSetPageInfo(szFileName: PChar; nPaperw: integer;
  nPaperh: integer; nMargl: integer;
  nMargr: integer; nMargt: integer;
  nMargb: integer): integer;
var
  fIn, fOut: Text;
  szLine: array[0..1024] of char;
  szExtra: array[0..1024] of char;
  nVal: integer;
  nNewPaperw: integer;
  nNewPaperh: integer;
  nNewMargl: integer;
  nNewMargr: integer;
  nNewMargt: integer;
  nNewMargb: integer;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 58, 0, 0, 0, nil, True);
  {$ENDIF}

  RtfSetPageInfo := -1;

  {$i-}
  Assign(fIn, szFileName);
  reset(fIn);
  {$i+}
  if IOResult <> 0 then
    exit;

  {$i-}
  szFileName[StrLen(szFileName) - 1] := '~';
  Assign(fOut, szFileName);
  rewrite(fOut);
  {$i+}
  if IOResult <> 0 then
  begin
    exit;
    Close(fIn);
  end;

  {$i-}
  nVal := -1;
  nNewPaperw := nPaperw;
  nNewPaperh := nPaperh;
  nNewMargl := nMargl;
  nNewMargr := nMargr;
  nNewMargt := nMargt;
  nNewMargb := nMargb;
  nPaperw := -1;
  nPaperh := -1;
  nMargl := -1;
  nMargr := -1;
  nMargt := -1;
  nMargb := -1;
  while not EOF(fIn) and (InOutRes = 0) do
  begin
    ReadLn(fIn, szLine);

    if nPaperw = -1 then
    begin
      nVal := RtfGetVal(szLine, '\paperw');
      if nVal <> -1 then
      begin
        nPaperw := nVal;
        if nPaperw <> nNewPaperw then
          RtfSetVal(szLine, '\paperw', nNewPaperw);
      end;
    end;

    if nPaperh = -1 then
    begin
      nVal := RtfGetVal(szLine, '\paperh');
      if nVal <> -1 then
      begin
        nPaperh := nVal;
        if nPaperh <> nNewPaperh then
          RtfSetVal(szLine, '\paperh', nNewPaperh);
      end;
    end;

    if nMargl = -1 then
    begin
      nVal := RtfGetVal(szLine, '\margl');
      if nVal <> -1 then
      begin
        nMargl := nVal;
        if nMargl <> nNewMargl then
          RtfSetVal(szLine, '\margl', nNewMargl);
      end;
    end;

    if nMargr = -1 then
    begin
      nVal := RtfGetVal(szLine, '\margr');
      if nVal <> -1 then
      begin
        nMargr := nVal;
        if nMargr <> nNewMargr then
          RtfSetVal(szLine, '\margr', nNewMargr);
      end;
    end;

    if nMargt = -1 then
    begin
      nVal := RtfGetVal(szLine, '\margt');
      if nVal <> -1 then
      begin
        nMargt := nVal;
        if nMargt <> nNewMargt then
          RtfSetVal(szLine, '\margt', nNewMargt);
      end;
    end;

    if nMargb = -1 then
    begin
      nVal := RtfGetVal(szLine, '\margb');
      if nVal <> -1 then
      begin
        nMargb := nVal;
        if nMargb <> nNewMargb then
          RtfSetVal(szLine, '\margb', nNewMargb);
      end;
    end;

    WriteLn(fOut, szLine);
  end;

  Close(fIn);
  Close(fOut);
  {$i+}
  if IOResult = 0 then
  begin

    {$i-}
    erase(fIn);
    {$i+}
    if IOResult <> 0 then
      exit;

    {$i-}
    szFileName[StrLen(szFileName) - 1] := 'f';
    rename(fOut, szFileName);
    {$i+}
    if IOResult <> 0 then
      exit;

    RtfSetPageInfo := 0;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure SetWindowTextFromFile(hWin: HWND; szFileName: PSTR);
var
  szTexte: array[0..fsDirectory] of char;
  hOldCursor: HCURSOR;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 59, 0, 0, 0, nil, True);
  {$ENDIF}

  hOldCursor := SetCursor(LoadCursor(0, IDC_WAIT));
  SetCapture(GetActiveWindow);
  if StrPos(StrUpper(szFileName), '.RTF') <> nil then
  begin

    SendMessage(hWin, WM_USER + 77, 2, 1);
    SendMessage(hWin, EM_SETTARGETDEVICE, 0, 0);

    MyLoadRTFFile(hWin, szFileName, SF_RTF);

  end
  else
  begin
    StrCopy(szTexte, PathTextes);
    StrCat(szTexte, 'RTF.New');
    MyLoadRTFFile(hWin, szTexte, SF_RTF);
    MyLoadRTFFile(hWin, szFileName, SF_TEXT);
  end;
  SetCursor(hOldCursor);
  ReleaseCapture;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure GetWindowTextToFile(hWin: HWND; szFileName: PSTR);
var
  f: file;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 60, 0, 0, 0, nil, True);
  {$ENDIF}

  GetWindowText(hWin, lpszLineBuffer, MAXTEXTBUFFER);
  SauveReponseTexte(szFileName);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function WriteSubClassProc(hWin: HWnd; Msg, wParam: DWord;
  lParam: longint): DWord; stdcall;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 61, 0, 0, 0, nil, True);
  {$ENDIF}

  case Msg of

    WM_CHAR:
    begin
      MessageBeep(0);
    end;

    WM_COMMAND:
    begin
      case LoWord(wParam) of
        WM_CLOSE:
        begin
        end;
      end;
    end;

  end;
  WriteSubClassProc := CallWindowProc(WNDPROC(GetClassLong(hWin, GCL_WNDPROC)),
    hWin, Msg, wParam, lParam);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure ReadTextFile(szFileName: PSTR);
var
  f: file;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 62, 0, 0, 0, nil, True);
  {$ENDIF}

  SendDlgItemMessage(hTexteProc, 101, EM_SETREADONLY, word(True), DWORD(0));
  SetWindowTextFromFile(GetDlgItem(hTexteProc, 101), szFileName);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure FileName(pszName, pszTemplateName, pszExt: PChar; No: longint);
var
  szNo: szPName;
  PathFichier: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 63, 0, 0, 0, nil, True);
  {$ENDIF}

  StrPCopy(szNo, IntToStr(No));
  StrCopy(PathFichier, tLecon.PathLecon);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, pszTemplateName);
  StrLCopy(pszName, PathFichier, StrLen(PathFichier) - (StrLen(szNo) - 1));
  StrCat(pszName, szNo);
  { pszExt contient le . (4 cars) }
  StrCat(pszName, pszExt);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure BitmapFileName(var PropositionName: szLongName; PropositionNo: longint);
var
  szNo: szPName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 64, 0, 0, 0, nil, True);
  {$ENDIF}

  StrPCopy(szNo, IntToStr(PropositionNo));
  StrCopy(PathFichier, tLecon.PathLecon);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, B000000);
  StrLCopy(PropositionName, PathFichier, StrLen(PathFichier) - (StrLen(szNo) - 1));
  StrCat(PropositionName, szNo);
  StrCat(PropositionName, '.');
  StrCat(PropositionName, szImageDefExt);
end;

{************************************************}

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure VideoFileName(var PropositionName: szLongName; PropositionNo: longint);
var
  szNo: szPName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 65, 0, 0, 0, nil, True);
  {$ENDIF}

  StrPCopy(szNo, IntToStr(PropositionNo));
  StrCopy(PathFichier, tLecon.PathLecon);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, V000000);
  StrLCopy(PropositionName, PathFichier, StrLen(PathFichier) - (StrLen(szNo) - 1));
  StrCat(PropositionName, szNo);
  StrCat(PropositionName, '.');
  StrCat(PropositionName, szVideoDefExt);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure TexteFileName(var PropositionName: szLongName; PropositionNo: longint);
var
  szNo: szPName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 66, 0, 0, 0, nil, True);
  {$ENDIF}

  StrPCopy(szNo, IntToStr(PropositionNo));
  StrCopy(PathFichier, tLecon.PathLecon);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, T000000);
  StrLCopy(PropositionName, PathFichier, StrLen(PathFichier) - (StrLen(szNo) - 1));
  StrCat(PropositionName, szNo);
  StrCat(PropositionName, '.');
  StrCat(PropositionName, szTextDefExt);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure QuestionFileName(var PropositionName: szLongName; PropositionNo: longint);
var
  szNo: szPName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 67, 0, 0, 0, nil, True);
  {$ENDIF}

  StrPCopy(szNo, IntToStr(PropositionNo));
  StrCopy(PathFichier, tLecon.PathLecon);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, Q000000);
  StrLCopy(PropositionName, PathFichier, StrLen(PathFichier) - (StrLen(szNo) - 1));
  StrCat(PropositionName, szNo);
  StrCat(PropositionName, '.WAV');
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure QcmWavFileName(var PropositionName: szLongName; PropositionNo: longint);
var
  szNo: szPName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 68, 0, 0, 0, nil, True);
  {$ENDIF}

  StrPCopy(szNo, IntToStr(PropositionNo));
  StrCopy(PathFichier, tLecon.PathLecon);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, QCM0000);
  StrLCopy(PropositionName, PathFichier, StrLen(PathFichier) - (StrLen(szNo) - 1));
  StrCat(PropositionName, szNo);
  StrCat(PropositionName, '.WAV');
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure QcmBmpFileName(var PropositionName: szLongName; PropositionNo: longint);
var
  szNo: szPName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 69, 0, 0, 0, nil, True);
  {$ENDIF}

  StrPCopy(szNo, IntToStr(PropositionNo));
  StrCopy(PathFichier, tLecon.PathLecon);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, QCM0000);
  StrLCopy(PropositionName, PathFichier, StrLen(PathFichier) - (StrLen(szNo) - 1));
  StrCat(PropositionName, szNo);
  StrCat(PropositionName, '.');
  StrCat(PropositionName, szImageDefExt);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure MCIFileName(var PropositionName: szLongName; PropositionNo: longint);
var
  szNo: szPName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 70, 0, 0, 0, nil, True);
  {$ENDIF}

  StrPCopy(szNo, IntToStr(PropositionNo));
  StrCopy(PathFichier, tLecon.PathLecon);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, M000000);
  StrLCopy(PropositionName, PathFichier, StrLen(PathFichier) - (StrLen(szNo) - 1));
  StrCat(PropositionName, szNo);
  StrCat(PropositionName, '.CMD');
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure ReponseFileName(var PropositionName: szLongName;
  NoELEV, PropositionNo: longint);
var
  szNo: szPName;
  tEtudiant: TypeEtudiant;
  szStudent, szLesson: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 71, 0, 0, 0, nil, True);
  {$ENDIF}

  GetEtudiantRec(noElev, tEtudiant);
  GetDosName(szStudent, tEtudiant.Nom);
  GetDosName(szLesson, tEtudiant.LessonName);
  {StrCopy(PathFichier,PathServeur);}
  StrCopy(PathFichier, PathEleves);
  StrCat(PathFichier, szStudent);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, szLesson);
  CreerRep(PathFichier);
  {StrCat(PathFichier, ELEV);
  StrPCopy(szNo, IntToStr(NoELEV));
  StrCat(PathFichier,szNo);}
  StrCat(PathFichier, '\');
  StrCat(PathFichier, R000000);
  StrPCopy(szNo, IntToStr(PropositionNo));
  StrLCopy(PropositionName, PathFichier, StrLen(PathFichier) - (StrLen(szNo) - 1));
  StrCat(PropositionName, szNo);
  StrCat(PropositionName, '.WAV');
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure EleveRep(var PathFichier: szLongName; NoELEV: longint);
var
  szNo: szPName;
  tEtudiant: TypeEtudiant;
  szStudent, szLesson: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 72, 0, 0, 0, nil, True);
  {$ENDIF}

  GetEtudiantRec(noElev, tEtudiant);
  GetDosName(szStudent, tEtudiant.Nom);
  GetDosName(szLesson, tEtudiant.LessonName);
  {StrCopy(PathFichier,PathServeur);}
  StrCopy(PathFichier, PathEleves);
  StrCat(PathFichier, szStudent);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, szLesson);
  CreerRep(PathFichier);
  {StrCat(PathFichier,ELEV);
  StrPCopy(szNo, IntToStr(NoELEV));
  StrCat(PathFichier,szNo);}
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure EleveRoot(var PathFichier: szLongName; NoELEV: longint);
var
  szNo: szPName;
  tEtudiant: TypeEtudiant;
  szStudent: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 72, 0, 0, 0, nil, True);
  {$ENDIF}

  GetEtudiantRec(noElev, tEtudiant);
  GetDosName(szStudent, tEtudiant.Nom);
  {StrCopy(PathFichier,PathServeur);}
  StrCopy(PathFichier, PathEleves);
  StrCat(PathFichier, szStudent);
  {StrCat(PathFichier,ELEV);
  StrPCopy(szNo, IntToStr(NoELEV));
  StrCat(PathFichier,szNo);}

end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure ReponseTxtFileName(var PropositionName: szLongName;
  NoELEV, PropositionNo: longint);
var
  szNo: szPName;
  PathFichier: szLongName;
  tEtudiant: TypeEtudiant;
  szStudent, szLesson: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 73, 0, 0, 0, nil, True);
  {$ENDIF}

  GetEtudiantRec(noElev, tEtudiant);
  GetDosName(szStudent, tEtudiant.Nom);
  GetDosName(szLesson, tEtudiant.LessonName);
  {StrCopy(PathFichier,PathServeur);}
  StrCopy(PathFichier, PathEleves);
  StrCat(PathFichier, szStudent);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, szLesson);
  CreerRep(PathFichier);
  {StrCat(PathFichier,ELEV);
  StrPCopy(szNo, IntToStr(NoELEV));
  StrCat(PathFichier,szNo);}
  StrCat(PathFichier, '\');
  StrCat(PathFichier, R000000);
  StrPCopy(szNo, IntToStr(PropositionNo));
  StrLCopy(PropositionName, PathFichier, StrLen(PathFichier) - (StrLen(szNo) - 1));
  StrCat(PropositionName, szNo);
  StrCat(PropositionName, '.TXT');
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure ReponseRtfFileName(var PropositionName: szLongName;
  NoELEV, PropositionNo: longint);
var
  szNo: szPName;
  PathFichier: szLongName;
  tEtudiant: TypeEtudiant;
  szStudent, szLesson: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 74, 0, 0, 0, nil, True);
  {$ENDIF}

  GetEtudiantRec(noElev, tEtudiant);
  GetDosName(szStudent, tEtudiant.Nom);
  GetDosName(szLesson, tEtudiant.LessonName);
  {StrCopy(PathFichier,PathServeur);}
  StrCopy(PathFichier, PathEleves);
  StrCat(PathFichier, szStudent);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, szLesson);
  CreerRep(PathFichier);
  {StrCat(PathFichier,ELEV);
  StrPCopy(szNo, IntToStr(NoELEV));
  StrCat(PathFichier,szNo);}
  StrCat(PathFichier, '\');
  StrCat(PathFichier, R000000);
  StrPCopy(szNo, IntToStr(PropositionNo));
  StrLCopy(PropositionName, PathFichier, StrLen(PathFichier) - (StrLen(szNo) - 1));
  StrCat(PropositionName, szNo);
  StrCat(PropositionName, '.RTF');
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure MessageSelFileName(var PropositionName: szLongName; NoELEV: longint);
var
  szNo: szPName;
  tEtudiant: TypeEtudiant;
  szStudent, szLesson: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 75, 0, 0, 0, nil, True);
  {$ENDIF}

  GetEtudiantRec(noElev, tEtudiant);
  GetDosName(szStudent, tEtudiant.Nom);
  GetDosName(szLesson, tEtudiant.LessonName);
  {StrCopy(PathFichier,PathServeur);}
  StrCopy(PathFichier, PathEleves);
  StrCat(PathFichier, szStudent);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, szLesson);
  CreerRep(PathFichier);
  {StrCat(PathFichier,ELEV);
  StrPCopy(szNo, IntToStr(NoELEV));
  StrCat(PathFichier,szNo);}
  StrCat(PathFichier, '\');
  StrCopy(PropositionName, PathFichier);
  StrCat(PropositionName, 'MESSAGE.SEL');
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure MessageBmpFileName(var PropositionName: szLongName; NoELEV: longint);
var
  szNo: szPName;
  tEtudiant: TypeEtudiant;
  szStudent, szLesson: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 76, 0, 0, 0, nil, True);
  {$ENDIF}

  GetEtudiantRec(noElev, tEtudiant);
  GetDosName(szStudent, tEtudiant.Nom);
  GetDosName(szLesson, tEtudiant.LessonName);
  {StrCopy(PathFichier,PathServeur);}
  StrCopy(PathFichier, PathEleves);
  StrCat(PathFichier, szStudent);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, szLesson);
  CreerRep(PathFichier);
  {StrCat(PathFichier,ELEV);
  StrPCopy(szNo, IntToStr(NoELEV));
  StrCat(PathFichier,szNo);}
  StrCat(PathFichier, '\');
  StrCopy(PropositionName, PathFichier);
  StrCat(PropositionName, 'MESSAGE.BMP');
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure MessageTxtFileName(var PropositionName: szLongName; NoELEV: longint);
var
  szNo: szPName;
  tEtudiant: TypeEtudiant;
  szStudent, szLesson: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 77, 0, 0, 0, nil, True);
  {$ENDIF}

  GetEtudiantRec(noElev, tEtudiant);
  GetDosName(szStudent, tEtudiant.Nom);
  GetDosName(szLesson, tEtudiant.LessonName);
  {StrCopy(PathFichier,PathServeur);}
  StrCopy(PathFichier, PathEleves);
  StrCat(PathFichier, szStudent);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, szLesson);
  CreerRep(PathFichier);
  {StrCat(PathFichier,ELEV);
  StrPCopy(szNo, IntToStr(NoELEV));
  StrCat(PathFichier,szNo);}
  StrCat(PathFichier, '\');
  StrCopy(PropositionName, PathFichier);
  StrCat(PropositionName, 'MESSAGE.TXT');
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure MessageRtfFileName(var PropositionName: szLongName; NoELEV: longint);
var
  szNo: szPName;
  tEtudiant: TypeEtudiant;
  szStudent, szLesson: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 78, 0, 0, 0, nil, True);
  {$ENDIF}

  GetEtudiantRec(noElev, tEtudiant);
  GetDosName(szStudent, tEtudiant.Nom);
  GetDosName(szLesson, tEtudiant.LessonName);
  {StrCopy(PathFichier,PathServeur);}
  StrCopy(PathFichier, PathEleves);
  StrCat(PathFichier, szStudent);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, szLesson);
  CreerRep(PathFichier);
  {StrCat(PathFichier,ELEV);
  StrPCopy(szNo, IntToStr(NoELEV));
  StrCat(PathFichier,szNo);}
  StrCat(PathFichier, '\');
  StrCopy(PropositionName, PathFichier);
  StrCat(PropositionName, 'MESSAGE.RTF');
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure MessageWavFileName(var PropositionName: szLongName; NoELEV: longint);
var
  szNo: szPName;
  tEtudiant: TypeEtudiant;
  szStudent, szLesson: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 79, 0, 0, 0, nil, True);
  {$ENDIF}

  GetEtudiantRec(noElev, tEtudiant);
  GetDosName(szStudent, tEtudiant.Nom);
  GetDosName(szLesson, tEtudiant.LessonName);
  {StrCopy(PathFichier,PathServeur);}
  StrCopy(PathFichier, PathEleves);
  StrCat(PathFichier, szStudent);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, szLesson);
  CreerRep(PathFichier);
  {StrCat(PathFichier,ELEV);
  StrPCopy(szNo, IntToStr(NoELEV));
  StrCat(PathFichier,szNo);}
  StrCat(PathFichier, '\');
  StrCopy(PropositionName, PathFichier);
  StrCat(PropositionName, 'MESSAGE.WAV');
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure SauveReponseTexte(PropositionPName: PChar);
var
  f: Text;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 80, 0, 0, 0, nil, True);
  {$ENDIF}

  {--ResetIOResult--}
  InOutRes := 0;
  {$i-}
  Assign(f, PropositionPName);
  rewrite(f);
  Write(f, lpszLineBuffer);
  Close(f);
  GetfAttr(f, wReturn);
  SetfAttr(f, wReturn or faShare); {SHARE Flag}
  {$i+}
  InOutRes := 0;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function NewFile(pszName, pszTemplateName, pszExt: PChar; No: longint): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 81, 0, 0, 0, nil, True);
  {$ENDIF}

  repeat
    FileName(pszName, pszTemplateName, pszExt, No);
    No := No + 1;
  until not FileExist(pszName);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function NewQuestionFile(var Name: szLongName; No: longint): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 82, 0, 0, 0, nil, True);
  {$ENDIF}

  repeat
    QuestionFileName(Name, No);
    No := No + 1;
  until not FileExist(Name);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function NewQcmWavFile(var Name: szLongName; No: longint): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 83, 0, 0, 0, nil, True);
  {$ENDIF}

  repeat
    QcmWavFileName(Name, No);
    No := No + 1;
  until not FileExist(Name);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function NewQcmBmpFile(var Name: szLongName; No: longint): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 84, 0, 0, 0, nil, True);
  {$ENDIF}

  repeat
    QcmBmpFileName(Name, No);
    No := No + 1;
  until not FileExist(Name);
end;

{************************************************************************}
{**    SE : Génère un nom de fichier dans Name en fonction de No       **}
{**    SI : Crée un nom à partir de No et vérifie si le fichier existe **}
{**         déjà. Si oui, Incrémente No.                               **}
{************************************************************************}
function NewQcmFile(var Name: szLongName; No: longint): boolean;
var
  szNo: szPName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 85, 0, 0, 0, nil, True);
  {$ENDIF}

  repeat
    StrPCopy(szNo, IntToStr(No));
    StrCopy(PathFichier, tLecon.PathLecon);
    StrCat(PathFichier, '\');
    StrCat(PathFichier, Q000000);
    StrLCopy(Name, PathFichier, StrLen(PathFichier) - (StrLen(szNo) - 1));
    StrCat(Name, szNo);
    StrCat(Name, '.QCM');
    No := No + 1;
  until not FileExist(Name);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function NewMCIFile(var Name: szLongName; No: longint): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 86, 0, 0, 0, nil, True);
  {$ENDIF}

  repeat
    MCIFileName(Name, No);
    No := No + 1;
  until not FileExist(Name);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function NewBitmapFile(var Name: szLongName; No: longint): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 87, 0, 0, 0, nil, True);
  {$ENDIF}

  repeat
    BitmapFileName(Name, No);
    No := No + 1;
  until not FileExist(Name);
end;

{**************************************************************}

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function NewVideoFile(var Name: szLongName; No: longint): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 88, 0, 0, 0, nil, True);
  {$ENDIF}

  repeat
    VideoFileName(Name, No);
    No := No + 1;
  until not FileExist(Name);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function NewTexteFile(var Name: szLongName; No: longint): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 89, 0, 0, 0, nil, True);
  {$ENDIF}

  repeat
    TexteFileName(Name, No);
    No := No + 1;
  until not FileExist(Name);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure FreeAllGlobal;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 90, 0, 0, 0, nil, True);
  {$ENDIF}

  GlobalUnLock(hFormat);
  GlobalFree(hFormat);

  GlobalUnLock(hDataRec[0]);
  GlobalFree(hDataRec[0]);
  GlobalUnLock(hWavHdrRec[0]);
  GlobalFree(hWavHdrRec[0]);
  GlobalUnLock(hDataRec[1]);
  GlobalFree(hDataRec[1]);
  GlobalUnLock(hWavHdrRec[1]);
  GlobalFree(hWavHdrRec[1]);
  GlobalUnLock(hDataRec[2]);
  GlobalFree(hDataRec[2]);
  GlobalUnLock(hWavHdrRec[2]);
  GlobalFree(hWavHdrRec[2]);
  GlobalUnLock(hBlockBlanc);
  GlobalFree(hBlockBlanc);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function OpenNewWaveFile(Window: HWnd; FileName: szLongName): boolean;
var
  wRet: word;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 91, 0, 0, 0, nil, True);
  {$ENDIF}

  {Crée .WAV}
  OpenNewWaveFile := False;
  hmio := mmioOpen(FileName, nil, MMIO_CREATE or MMIO_WRITE or MMIO_DENYNONE);
  if hmio = 0 then
  begin
    MessageBox(Window, mmLoadString(hInstRes, ERR_CREATEFILE), FileName, MB_OK +
      MB_ICONSTOP);
  end
  else
  begin
    {Crée chunk WAVE}
    FillChar(mmckinfoParent, SizeOf(mmckinfoParent), 0);
    mmckinfoParent.fccType := mmioStringToFOURCC('WAVE', 0);
    wRet := mmioCreateChunk(hmio, @mmckinfoParent, MMIO_CREATERIFF);
    if wRet <> 0 then
    begin
      case wRet of
        MMIOERR_CANNOTWRITE:
          MessageBox(Window, mmLoadString(hInstRes, ERR_CREATECHUNK),
            'WAVE MMIOERR_CANNOTWRITE', MB_OK + MB_ICONSTOP);
        MMIOERR_CANNOTSEEK:
          MessageBox(Window, mmLoadString(hInstRes, ERR_CREATECHUNK),
            'WAVE MMIOERR_CANNOTSEEK', MB_OK + MB_ICONSTOP);
        else
          MessageBox(Window, mmLoadString(hInstRes, ERR_CREATECHUNK),
            'WAVE MMIOERR_UNKNOWN', MB_OK + MB_ICONSTOP);
      end;
    end
    else
    begin
      {Crée chunk fmt}
      mmckinfoSubChunk.ckid := mmioStringToFOURCC('fmt', 0);
      mmckinfoSubChunk.cksize := SizeOf(pFormat^);
      if boolean(mmioCreateChunk(hmio, @mmckinfoSubChunk, 0)) then
      begin
        MessageBox(Window, mmLoadString(hInstRes, ERR_CREATECHUNK),
          'fmt Create', MB_OK + MB_ICONSTOP);
      end
      else
      begin
        dwfmtSize := mmckinfoSubChunk.cksize;
        if (pFormat <> nil) and (mmioWrite(hmio, PSTR(pFormat), dwFmtSize) <> dwFmtSize) then
        begin
          MessageBox(Window, mmLoadString(hInstRes, ERR_CREATECHUNK),
            'fmt Write', MB_OK + MB_ICONSTOP);
        end
        else
        begin
          {Crée data}
          mmckinfoSubChunk.cksize := 0 {taille du fichier};
          mmckinfoSubChunk.ckid := mmioStringToFOURCC('data', 0);
          if boolean(mmioCreateChunk(hmio, @mmckinfoSubChunk, 0)) then
          begin
            MessageBox(Window, mmLoadString(hInstRes, ERR_CREATECHUNK),
              'data', MB_OK + MB_ICONSTOP);
          end
          else
          begin
            {New Wave File créé...}
            OpenNewWaveFile := True;
          end;
        end;
      end;
    end;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function CloseWaveFile: boolean;
var
  f: file;
  wRet: word;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 92, 0, 0, 0, nil, True);
  {$ENDIF}

  {Close Wave File}
  mmioAscend(hmio, @mmckinfoSubChunk, 0);{mise à jour subchunk data size}
  mmioAscend(hmio, @mmckinfoParent, 0);{mise à jour subchunk WAVE size}
  CloseWaveFile := boolean(mmioClose(hmio, 0));
  Assign(f, PChar(OldQName));
  GetFattr(f, wRet);
  SetFattr(f, wRet or faShare);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function NextBlockRec(NoBlock: integer): boolean;
var
  wResult: word;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 93, 0, 0, 0, nil, True);
  {$ENDIF}

  NextBlockRec := False;
  wResult := waveInAddBuffer(hWavIn, lpWavHdrRec[NoBlock], SizeOf(TWAVEHDR));
  if wResult <> 0 then
  begin
    FreeAllGlobal;
  end
  else
  begin
    if waveInStart(hWavIn) <> 0 then
    begin
      FreeAllGlobal;
    end
    else
    begin
      {Le block est en train de s'enregistrer...}
      NextBlockRec := True;
    end;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function SendToBeRec(Window: HWnd): boolean;
var
  i: integer;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 94, 0, 0, 0, nil, True);
  {$ENDIF}

  SendToBeRec := False;
  hBlockBlanc := GlobalAlloc(GMEM_MOVEABLE or GMEM_SHARE, dwBlockSize);
  lpBlockBlanc := GlobalLock(hBlockBlanc);
  if lpBlockBlanc = nil then
  begin
    MessageBox(Window, mmLoadString(hInstRes, ERR_MEMALLOC), 'hData', MB_OK + MB_ICONSTOP);
    FreeAllGlobal;
  end
  else
  begin
    for i := 0 to 2 do
    begin
      lpWavHdrRec[i]^.lpData := lpDataRec[i];
      lpWavHdrRec[i]^.dwBufferLength := GlobalSize(hDataRec[i]);
      lpWavHdrRec[i]^.dwUser := i;
      lpWavHdrRec[i]^.dwFlags := 0;
      lpWavHdrRec[i]^.dwLoops := 0;
    end;
    if (waveInPrepareHeader(hWavIn, lpWavHdrRec[0], SizeOf(TWAVEHDR)) <> 0) or
      (waveInPrepareHeader(hWavIn, lpWavHdrRec[1], SizeOf(TWAVEHDR)) <> 0) or
      (waveInPrepareHeader(hWavIn, lpWavHdrRec[2], SizeOf(TWAVEHDR)) <> 0) then
    begin
      MessageBox(Window, mmLoadString(hInstRes, ERR_PREPARHDR), 'hWavIn', MB_OK +
        MB_ICONSTOP);
      FreeAllGlobal;
    end
    else
    begin
      {Envoie data au Wave périph.}
      if not NextBlockRec(0) or not NextBlockRec(1) or
        not NextBlockRec(2) then
      begin
        MessageBox(Window, mmLoadString(hInstRes, ERR_NEXTBLOCK),
          'RecAudio', MB_OK + MB_ICONSTOP);
        FreeAllGlobal;
      end
      else
      begin
        {Les 3 Blocks sont envoyés à l'enregistrement...}
        SendToBeRec := True;
      end;
    end;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function StartLessonRec(Window: HWnd): boolean;
var
  mmckinfoparent: TMMCKINFO;
  dwDataSize: DWORD;
  i: integer;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 95, 0, 0, 0, nil, True);
  {$ENDIF}

  StartLessonRec := False;
  OldQName[0] := #0;
  NewQName[0] := #0;
  hFormat := 0;
  pFormat := nil;
  for i := 0 to 2 do
  begin
    hDataRec[i] := 0;
    hWavHdrRec[i] := 0;
    lpDataRec[i] := nil;
    lpWavHdrRec[i] := nil;
  end;
  hBlockBlanc := 0;
  lpBlockBlanc := nil;
  {Crée .WAV}
  NbBlocks := 0;
  NoBlock := 0;
  hFormat := GlobalAlloc(GPTR, word(dwfmtSize));
  pFormat := PPCMWAVEFORMAT(GlobalLock(hFormat));
  if pFormat = nil then
  begin
    MessageBox(Window, mmLoadString(hInstRes, ERR_MEMALLOC), 'pFormat', MB_OK +
      MB_ICONSTOP);
  end
  else
  begin

    with pFormat^ do
    begin
      with wf do
      begin
        wFormatTag := WAVE_FORMAT_PCM;
        nChannels := 1;
        nSamplesPerSec := FrequEch;
        nBlockAlign := (wNbBits div 8) * nChannels;
        nAvgBytesPerSec := nSamplesPerSec * nBlockAlign;
      end;
      wBitsPerSample := wNbBits;
    end;
    {Ouvre Wave Périph. #### attention on doit passer l'adresse : Erreur Doc. ####}
    if boolean(waveInOpen(LPHWAVEIN(@hWavIn), word(WAVE_MAPPER),
      LPWAVEFORMATEX(pFormat), DWORD(Window), DWORD(0), CALLBACK_WINDOW)) then
    begin
      MessageBox(Window, mmLoadString(hInstRes, ERR_WAVPERIPH),
        'WaveInOpen', MB_OK + MB_ICONSTOP);
    end
    else
    begin
      dwDataSize := dwBlockSize;
      for i := 0 to 2 do
      begin
        hDataRec[i] := GlobalAlloc(GPTR, dwDataSize);
        lpDataRec[i] := GlobalLock(hDataRec[i]);
      end;
      if lpDataRec[2] = nil then
      begin
        MessageBox(Window, mmLoadString(hInstRes, ERR_MEMALLOC), 'hData', MB_OK +
          MB_ICONSTOP);
      end
      else
      begin
        {Crée et prépare Wave Header}
        for i := 0 to 2 do
        begin
          hWavHdrRec[i] := GlobalAlloc(GPTR, DWORD(SizeOf(TWAVEHDR)));
          lpWavHdrRec[i] := GlobalLock(hWavHdrRec[i]);
        end;
        if lpWavHdrRec[2] = nil then
        begin
          MessageBox(Window, mmLoadString(hInstRes, ERR_MEMALLOC),
            'hWaveHdr', MB_OK + MB_ICONSTOP);
          FreeAllGlobal;
        end
        else
        begin
          {Lance enregistrement des blocks}
          StartLessonRec := SendToBeRec(Window);
        end;
      end;
    end;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure CreerLecon;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 96, 0, 0, 0, nil, True);
  {$ENDIF}

  if not FileExist('Lecons.lst') then
  begin
    Assign(fLecon, 'Lecons.lst');
    rewrite(fLecon);
    Close(fLecon);
    GetfAttr(fLecon, wReturn);
    SetfAttr(fLecon, wReturn or faShare); {SHARE Flag}
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure CreerQuestion;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 97, 0, 0, 0, nil, True);
  {$ENDIF}

  if not FileExist('Question.lst') then
  begin
    Assign(fQuestion, 'Question.lst');
    rewrite(fQuestion);
    Close(fQuestion);
    GetfAttr(fQuestion, wReturn);
    SetfAttr(fQuestion, wReturn or faShare); {SHARE Flag}
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function PlayWaveFile(Window: HWND; lpszFileName: POINTER): DWORD;
var
  wDeviceID: word;
  dwReturn: DWORD;
  mciOpenParms: TMCI_OPEN_PARMS;
  mciPlayParms: TMCI_PLAY_PARMS;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 98, 0, 0, 0, nil, True);
  {$ENDIF}

  mciOpenParms.lpstrDeviceType := 'waveaudio';
  mciOpenParms.lpstrElementName := lpszFileName;
  dwReturn := mciSendCommand(0, MCI_OPEN, DWORD(MCI_OPEN_TYPE or MCI_OPEN_ELEMENT),
    DWORD(@mciOpenParms));
  if dwReturn = 0 then
  begin
    wDeviceID := mciOpenParms.wDeviceID;
    mciPlayParms.dwCallback := DWORD(Window);
    dwReturn := mciSendCommand(wDeviceID, MCI_PLAY, DWORD(MCI_NOTIFY),
      DWORD(@mciPlayParms));
    if dwReturn <> 0 then
      MessageBox(Window, mmLoadString(hInstRes, ERR_WAVPERIPH),
        'MCI_PLAY', MB_OK + MB_ICONSTOP);
  end
  else
  begin
    MessageBox(Window, mmLoadString(hInstRes, ERR_WAVPERIPH), 'MCI_OPEN', MB_OK +
      MB_ICONSTOP);
  end;
  PlayWaveFile := dwReturn;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function max(Val1, Val2: longint): longint;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 99, 0, 0, 0, nil, True);
  {$ENDIF}

  if Val1 > Val2 then
    max := Val1
  else
    max := Val2;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function min(Val1, Val2: longint): longint;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 100, 0, 0, 0, nil, True);
  {$ENDIF}

  if Val1 < Val2 then
    min := Val1
  else
    min := Val2;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function CreateNewLessonRep(NoLecon: longint; var tLecon: TypeLecon): boolean;
var
  szNo: szPName;
  szNewRep: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 101, 0, 0, 0, nil, True);
  {$ENDIF}

  CreateNewLessonRep := False;
  repeat
    {StrCopy(PathFichier,PathServeur);
    StrCat(PathFichier,PathLavac);}
    StrCopy(PathFichier, PathLecons);
    StrPCopy(szNo, IntToStr(NoLecon));
    StrLCopy(szNewRep, L000000, StrLen(L000000) - (StrLen(szNo) - 1));
    StrCat(szNewRep, szNo);
    StrCat(PathFichier, szNewRep);
    {--ResetIOResult--}
    InOutRes := 0;
    {$i-}
    ChDir(AZTtoSTRING(PathFichier));
    {$i+}
    NoLecon := NoLecon + 1;
  until IOResult <> 0;
  {$i-}
  MkDir(AZTtoSTRING(PathFichier));
  {$i+}
  if IOResult = 0 then
  begin
    SetCurrentDirectory(PathFichier);
    CreerQuestion;
    StrCopy(tLecon.PathLecon, PathFichier);
    StrCat(PathFichier, '\lecons.rec');
    {$i-}
    Assign(fLecon, PChar(PathFichier));
    rewrite(fLecon);
    Write(fLecon, tLecon);
    Close(fLecon);
    {$i+}
    InOutRes := 0;
    CreateNewLessonRep := True;
  end
  else
  begin
    {ErrWiMessageBoxOResult)};
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function CopyLessonRec(No: longint; var tLecon: TypeLecon): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 102, 0, 0, 0, nil, True);
  {$ENDIF}

  CopyLessonRec := GetLessonRec(No, tLecon);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function CutLessonRec(No: longint; var tLecon: TypeLecon): boolean;
var
  tOldLecon: TypeLecon;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 103, 0, 0, 0, nil, True);
  {$ENDIF}

  CutLessonRec := False;
  if No >= 0 then
  begin
    {StrCopy(PathFichier,PathServeur);
    StrCat(PathFichier,PathLavac);}
    StrCopy(PathFichier, PathLecons);
    StrCat(PathFichier, 'LECONS.LST');

    FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;

    {--ResetIOResult--}
    InOutRes := 0;
    {$i-}
    Assign(fLecon, PChar(PathFichier));
    reset(fLecon);
    Seek(fLecon, No - 1);
    Read(fLecon, tOldLecon);
    No := No - 1;
    while (not EOF(fLecon) and (IOResult = 0)) do
    begin
      Seek(fLecon, No + 1);
      if (IOResult = 0) then begin
        Read(fLecon, tLecon);
        Seek(fLecon, No);
        Write(fLecon, tLecon);
        No := No + 1;
      end;
    end;
    Seek(fLecon, FileSize(fLecon) - 1);
    Truncate(fLecon);
    Close(fLecon);
    {$i+}
  end;
  if IOResult = 0 then
    CutLessonRec := True;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function GetLessonCount: longint;
begin

  GetLessonCount := 0;
  StrCopy(PathFichier, PathLecons);
  StrCat(PathFichier, 'LECONS.LST');

  FileMode := OF_SHARE_DENY_NONE or OF_READ;
  {--ResetIOResult--}
  InOutRes := 0;
  {$i-}
  Assign(fLecon, PChar(PathFichier));
  reset(fLecon);
  {$i+}
  if IOResult = 0 then
  begin
    GetLessonCount := FileSize(fLecon);
    {$i-}
    Close(fLecon);
    {$i+}
  end;
  FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function GetLessonRec(No: longint; var tLecon: TypeLecon): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 104, 0, 0, 0, nil, True);
  {$ENDIF}

  GetLessonRec := False;
  if No >= 0 then
  begin
    StrCopy(PathFichier, PathLecons);
    StrCat(PathFichier, 'LECONS.LST');
    {--ResetIOResult--}
    InOutRes := 0;
    {$i-}
    Assign(fLecon, PChar(PathFichier));
    FileMode := OF_SHARE_DENY_NONE or OF_READ;
    reset(fLecon);
    Seek(fLecon, No - 1);
    Read(fLecon, tLecon);
    Close(fLecon);
    FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;
    {$i+}
  end;
  if tLecon.Nom[0] = #0 then
    StrCopy(tLecon.Nom, '<Sans Nom>');
  if StrLen(tLecon.PathLecon) > SizeOf(tLecon.PathLecon) - 1 then
  begin
    MessageBox(Window, tLecon.Nom,
      'Le chemin de cette leçon semble incorect !!!', MB_OK);
    tLecon.PathLecon[0] := #0;
  end;
  if IOResult = 0 then
  begin

    { Chemin dynamique }
    if bDynaPath then
    begin
      UpdatePath(tLecon.PathLecon, PathLecons);
      {if UpCase(PathLecons[0]) <> UpCase(tLecon.PathLecon[0]) then begin
        tLecon.PathLecon[0] := PathLecons[0];
      end;}
    end;

    GetLessonRec := True;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function SetLessonRec(No: longint; var tLecon: TypeLecon): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 105, 0, 0, 0, nil, True);
  {$ENDIF}


  SetLessonRec := False;
  if (No < 0) or (No > 10000) then
    exit;

  tLecon.dwTag := dwLavacTag;
  tLecon.wVer := wLavacVer;
  SetLessonRec := False;
  {StrCopy(PathFichier,PathServeur);
  StrCat(PathFichier,PathLavac);}
  StrCopy(PathFichier, PathLecons);
  StrCat(PathFichier, 'LECONS.LST');
  {--ResetIOResult--}
  InOutRes := 0;
  {$i-}
  Assign(fLecon, PChar(PathFichier));
  reset(fLecon);
  {$i+}
  if IOResult = 2 then
  begin
    {$i-}
    Assign(fLecon, PChar(PathFichier));
    rewrite(fLecon);
    {$i+}
  end;
  {$i-}
  Seek(fLecon, No - 1);
  Write(fLecon, tLecon);
  Close(fLecon);
  {$i+}
  if IOResult = 0 then
    SetLessonRec := True;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function CutQuestionRec(No: longint; var tQuestion: TypeQuestion): boolean;
var
  tOldQuestion: TypeQuestion;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 106, 0, 0, 0, nil, True);
  {$ENDIF}

  CutQuestionRec := False;
  if No >= 0 then
  begin
    StrCopy(PathFichier, tLecon.PathLecon);
    StrCat(PathFichier, '\QUESTION.LST');
    {--ResetIOResult--}
    InOutRes := 0;
    {$i-}
    Assign(fQuestion, PChar(PathFichier));
    reset(fQuestion);
    Seek(fQuestion, No - 1);
    Read(fQuestion, tOldQuestion);
    No := No - 1;
    while not EOF(fQuestion) do
    begin
      Seek(fQuestion, No + 1);
      Read(fQuestion, tQuestion);
      Seek(fQuestion, No);
      Write(fQuestion, tQuestion);
      No := No + 1;
    end;
    Seek(fQuestion, FileSize(fQuestion) - 1);
    Truncate(fQuestion);
    tQuestion := tOldQuestion;
    Close(fQuestion);
    {$i+}
  end;
  if IOResult = 0 then
    CutQuestionRec := True;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function PasteQuestionRec(No: longint; var tNewQuestion: TypeQuestion): boolean;
var
  tQuestion: TypeQuestion;
  io: longint;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 107, 0, 0, 0, nil, True);
  {$ENDIF}

  PasteQuestionRec := False;
  if No >= 0 then
  begin
    StrCopy(PathFichier, tLecon.PathLecon);
    StrCat(PathFichier, '\QUESTION.LST');
    {--ResetIOResult--}
    InOutRes := 0;
    {$i-}
    Assign(fQuestion, PChar(PathFichier));
    reset(fQuestion);
    for i := FileSize(fQuestion) - 1 downto No - 1 do
    begin
      Seek(fQuestion, i);
      Read(fQuestion, tQuestion);
      Seek(fQuestion, i + 1);
      Write(fQuestion, tQuestion);
    end;
    Seek(fQuestion, No - 1);
    Write(fQuestion, tNewQuestion);
    Close(fQuestion);
    {$i+}
  end;
  if IOResult = 0 then
    PasteQuestionRec := True;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function PasteFromSequenceFiles(tlFrom: TypeLecon;
  var tqFrom: TypeQuestion; var tqTo: TypeQuestion;
  nItem: integer): boolean;
var
  szMCIFrom: szLongName;
  szMCITo: szLongName;
  Dir: array[0..fsDirectory] of char;
  Name: array[0..fsFileName] of char;
  Ext: array[0..fsExtension] of char;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 108, 0, 0, 0, nil, True);
  {$ENDIF}

  StrCopy(Dir, tlFrom.PathLecon);
  StrCat(Dir, '\');
  Move(tqFrom.Nom, tqTo.Nom, SizeOf(tqTo));
  if tqFrom.FichierGraph[0] <> #0 then
  begin
    if IsVideoFile(tqFrom.FichierGraph) then
    begin
      CopyInCurLesson(tqFrom.FichierGraph, B000000, nItem);
    end
    else
    begin
      CopyInCurLesson(tqFrom.FichierGraph, V000000, nItem);
    end;
    StrCopy(tqTo.FichierGraph, tqFrom.FichierGraph);
  end;
  if tqFrom.FichierTexte[0] <> #0 then
  begin
    CopyInCurLesson(tqFrom.FichierTexte, T000000, nItem);
    StrCopy(tqTo.FichierTexte, tqFrom.FichierTexte);
  end;
  if tqFrom.FichierQuestion[0] <> #0 then
  begin
    CopyInCurLesson(tqFrom.FichierQuestion, Q000000, nItem);
    StrCopy(tqTo.FichierQuestion, tqFrom.FichierQuestion);
  end;
  if tqFrom.FichierQCM[0] <> #0 then
  begin
    CopyInCurLesson(tqFrom.FichierQCM, QCM0000, nItem);
    StrCopy(tqTo.FichierQCM, tqFrom.FichierQCM);
  end;
  if tqFrom.FichierMCI[0] <> #0 then
  begin
    StrCopy(szMCIFrom, Dir);
    StrCat(szMCIFrom, tqFrom.FichierMCI);
    StrCat(szMCIFrom, '.CMD');
    if FileExist(szMCIFrom) then
    begin
      CopyInCurLesson(szMCIFrom, M000000, nItem);
      FileSplit(szMCIFrom, Dir, Name, Ext);
      StrCopy(tqTo.FichierMCI, Name);
    end
    else
    begin
      StrCopy(tqTo.FichierMCI, '');
    end;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function GetQuestionRec(No: longint; var tQuestion: TypeQuestion): boolean;
var
  fQuestion: file of TypeQuestion;
  bRet: boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 109, 0, 0, 0, nil, True);
  {$ENDIF}

  bRet := False;

  if (No <= 0) or (No > 1000) then
  begin
    {$IFDEF _DEBUG}
    AddDebugText(DBG_FILE, 'Index dans QUESTION.LST invalide %ld en lecture.', @No, True);
    {$ENDIF _DEBUG}
    GetQuestionRec := bRet;
    exit;
  end;

  StrCopy(PathFichier, tLecon.PathLecon);
  StrCat(PathFichier, '\QUESTION.LST');
  {--ResetIOResult--}
  InOutRes := 0;
  bRet := True;

  FileMode := OF_SHARE_DENY_NONE or OF_READ;
  Assign(fQuestion, PChar(PathFichier));
  {$i-}
  reset(fQuestion);
  {$i+}
  if IOResult = 0 then
  begin
    {$i-}
    Seek(fQuestion, No - 1);
    {$i+}
    if IOResult = 0 then
    begin
      {$i-}
      Read(fQuestion, tQuestion);
      {$i+}
      if IOResult <> 0 then
      begin
        {$IFDEF _DEBUG}
        AddDebugText(DBG_FILE, 'Impossible de lire QUESTION.LST à l''index %ld', @No, True);
        {$ENDIF _DEBUG}
        bRet := False;
      end;
    end
    else
    begin
      {$IFDEF _DEBUG}
      AddDebugText(DBG_FILE,
        'Impossible de positionner QUESTION.LST à l''index %ld en lecture.', @No, True);
      {$ENDIF _DEBUG}
      bRet := False;
    end;
  end
  else
  begin
    {$IFDEF _DEBUG}
    AddDebugText(DBG_FILE, 'Impossible d''ouvrir QUESTION.LST en lecture.', nil, True);
    {$ENDIF _DEBUG}
    bRet := False;
  end;
  {$i-}
  Close(fQuestion);
  {$i+}
  if IOResult = 0 then
  begin
    { Chemin dynamique }
    if bDynaPath then
    begin

      if (tQuestion.FichierQuestion[0] <> #0) {####AND
         (UpCase(PathLecons[0]) <> UpCase(tQuestion.FichierQuestion[0])) AND
         (StrPos(tQuestion.FichierQuestion, 'LAVAC\LECONS') <> nil)} then
      begin
        UpdatePath(tQuestion.FichierQuestion, tLecon.PathLecon);
        {tQuestion.FichierQuestion[0] := PathLecons[0];}
      end;

      if (tQuestion.FichierGraph[0] <> #0) {####AND
         (UpCase(PathLecons[0]) <> UpCase(tQuestion.FichierGraph[0])) AND
         (StrPos(tQuestion.FichierGraph, 'LAVAC\LECONS') <> nil)} then
      begin
        UpdatePath(tQuestion.FichierGraph, tLecon.PathLecon);
        {tQuestion.FichierGraph[0] := PathLecons[0];}
      end;

      if (tQuestion.FichierTexte[0] <> #0) {####AND
         (UpCase(PathLecons[0]) <> UpCase(tQuestion.FichierTexte[0])) AND
         (StrPos(tQuestion.FichierTexte, 'LAVAC\LECONS') <> nil)} then
      begin
        UpdatePath(tQuestion.FichierTexte, tLecon.PathLecon);
        {tQuestion.FichierTexte[0] := PathLecons[0];}
      end;

      if (tQuestion.FichierQCM[0] <> #0) {####AND
         (UpCase(PathLecons[0]) <> UpCase(tQuestion.FichierQCM[0])) AND
         (StrPos(tQuestion.FichierQCM, 'LAVAC\LECONS') <> nil)} then
      begin
        UpdatePath(tQuestion.FichierQCM, tLecon.PathLecon);
        {tQuestion.FichierQCM[0] := PathLecons[0];}
      end;

      if (tQuestion.FichierExecutable[0] <> #0) and
        {####(NOT FileExist(tQuestion.FichierExecutable)) AND}
        (StrPos(tQuestion.FichierExecutable, 'LAVAC\LECONS') <> nil) then
      begin
        UpdatePath(tQuestion.FichierExecutable, tLecon.PathLecon);
        {tQuestion.FichierExecutable[0] := PathLecons[0];}
      end;
    end;
  end
  else
  begin
    bRet := False;
  end;

  FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;

  GetQuestionRec := bRet;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function SetQuestionRec(No: longint; var tQuestion: TypeQuestion): boolean;
var
  fQuestion: file of TypeQuestion;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 110, 0, 0, 0, nil, True);
  {$ENDIF}


  SetQuestionRec := False;
  if (No <= 0) or (No > 1000) then
  begin
    {$IFDEF _DEBUG}
    AddDebugText(DBG_FILE, 'Index dans QUESTION.LST invalide %ld en ecriture.', @No, True);
    {$ENDIF _DEBUG}
    exit;
  end;

  tQuestion.dwTag := dwLavacTag;
  tQuestion.wVer := wLavacVer;
  SetQuestionRec := False;
  StrCopy(PathFichier, tLecon.PathLecon);
  StrCat(PathFichier, '\QUESTION.LST');
  {--ResetIOResult--}
  InOutRes := 0;

  Assign(fQuestion, PChar(PathFichier));
  {$i-}
  reset(fQuestion);
  {$i+}
  if IOResult = 0 then
  begin
    {$i-}
    Seek(fQuestion, No - 1);
    {$i+}
    if IOResult = 0 then
    begin
      {$i-}
      Write(fQuestion, tQuestion);
      {$i+}
      if IOResult <> 0 then
      begin
        {$IFDEF _DEBUG}
        AddDebugText(DBG_FILE, 'Impossible d''écrire QUESTION.LST à l''index %ld',
          @No, True);
        {$ENDIF _DEBUG}
      end;
    end
    else
    begin
      {$IFDEF _DEBUG}
      AddDebugText(DBG_FILE,
        'Impossible de positionner QUESTION.LST à l''index %ld en ecriture.', @No, True);
      {$ENDIF _DEBUG}
    end;
  end
  else
  begin
    {$IFDEF _DEBUG}
    AddDebugText(DBG_FILE, 'Impossible d''ouvrir QUESTION.LST en ecriture.', nil, True);
    {$ENDIF _DEBUG}
  end;
  {$i-}
  Close(fQuestion);
  {$i+}

  if IOResult = 0 then
    SetQuestionRec := True;
end;

function ExistProc(Dialog: HWnd; Message, WParam: DWord; LParam: longint): Bool; stdcall;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 111, 0, 0, 0, nil, True);
  {$ENDIF}


  ExistProc := True;

  case Message of
    WM_INITDIALOG:
    begin
      MessageBeep(MB_ICONEXCLAMATION);
      CenterDialog(Dialog);
    end;

    WM_COMMAND:
    begin
      case LoWord(wParam) of
        101:
        begin
          EndDialog(Dialog, idYes);
        end;

        102:
        begin
          EndDialog(Dialog, idNo);
        end;

        103:
        begin
          EndDialog(Dialog, idCancel);
        end;
      end;
    end;
  end;

  ExistProc := False;

end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function CreateNewLesson(Dialog: HWND; var tLecon: TypeLecon;
  var QuestionNo: longint): boolean;
var
  NoLecon: longint;
  wReturn: word;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 112, 0, 0, 0, nil, True);
  {$ENDIF}

  CreateNewLesson := False;
  GetDlgItemText(Dialog, idl_Lecon, tLecon.Nom, SizeOf(tLecon.Nom));
  if tLecon.nom[0] = #0 then
  begin
    MessageBox(GetActiveWindow,
      mmLoadString(hInstRes, ERR_LESSONNAME),
      tLecon.Nom,
      MB_APPLMODAL + MB_OK + MB_ICONSTOP);
  end
  else
  begin
    {Nombre de question + 1}
    StrCopy(PathFichier, tLecon.PathLecon);
    StrCat(PathFichier, '\QUESTION.LST');
    {$i-}
    Assign(fQuestion, PChar(PathFichier));
    FileMode := OF_SHARE_DENY_NONE or OF_READ;
    Reset(fQuestion);
    QuestionNo := FileSize(fQuestion);
    Close(fQuestion);
    FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;
    {$i+}
    if IOResult <> 0 then
      QuestionNo := 0;

    { No de la lecon }
    NoLecon := SendDlgItemMessage(Dialog, idl_lecon, CB_GETCURSEL, 0, 0);
    if (NoLecon <> CB_ERR) then
    begin
      NoLecon := GetItemData(Dialog, idl_lecon, NoLecon) + 1;
    end
    else
    begin
      wReturn := MessageBox(Dialog, 'Cette leçon n''existe pas...',
        tLecon.Nom, MB_APPLMODAL + MB_OK + MB_ICONSTOP);
      CreateNewLesson := False;
      exit;
    end;

    if (QuestionNo > 0) then
    begin
      // lpAttenteProc := MakeProcInstance(@ExistProc, HInstance);
      lpAttenteProc := @ExistProc;
      wReturn :=
        DialogBox(hInstRes, 'Exist', GetActiveWindow, DLGPROC(lpAttenteProc));
      // FreeProcInstance(lpAttenteProc);
      case wReturn of
        idYes:
        begin
          QuestionNo := 0;
          if GetLessonRec(NoLecon, tLecon) then
          begin
            CreateNewLesson := True;
          end
          else
          begin
            if CreateNewLessonRep(NoLecon, tLecon) then
              CreateNewLesson := True;
          end;
        end;
        idNo:
        begin
          if GetLessonRec(NoLecon, tLecon) then
          begin
            CreateNewLesson := True;
          end
          else
          begin
            QuestionNo := 0;
            if CreateNewLessonRep(NoLecon, tLecon) then
            begin
              CreateNewLesson := True;
            end;
          end;
        end;
        idCancel:
        begin
          CreateNewLesson := False;
        end;
      end;
    end
    else
    begin
      QuestionNo := 0;
      if GetLessonRec(NoLecon, tLecon) then
      begin
        CreateNewLesson := True;
      end
      else
      begin
        if CreateNewLessonRep(NoLecon, tLecon) then
          CreateNewLesson := True;
      end;
    end;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function OpenLesson(Dialog: HWND; var tLecon: TypeLecon;
  var NoLecon: longint): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 113, 0, 0, 0, nil, True);
  {$ENDIF}

  OpenLesson := False;
  GetDlgItemText(Dialog, idl_Lecon, tLecon.Nom, SizeOf(tLecon.Nom));
  if StrComp(tLecon.nom, '') = 0 then
  begin
    MessageBox(Dialog,
      mmLoadString(hInstRes, ERR_LESSONNAME),
      tLecon.Nom,
      MB_APPLMODAL + MB_OK + MB_ICONSTOP);
  end
  else
  begin
    NoLecon := SendDlgItemMessage(Dialog, idl_lecon,
      CB_FINDSTRINGEXACT, word(-1), DWORD(@tLecon.nom)) + 1;
    if NoLecon - 1 <> CB_ERR then
    begin
      SendDlgItemMessage(Dialog, idl_Lecon, CB_SETCURSEL, NoLecon - 1, 0);
      NoLecon := GetItemData(Dialog, idl_lecon, NoLecon - 1) + 1;
      begin
        if GetLessonRec(NoLecon, tLecon) then
        begin
          OpenLesson := True;
        end
        else
        begin
          if CreateNewLessonRep(NoLecon, tLecon) then
          begin
            if SetLessonRec(NoLecon, tLecon) then
            begin
              OpenLesson := True;
            end;
          end;
        end;
      end;
    end
    else
    begin
      {#### erreur !!! car il n'y a pas les leçons LAVAC dans le cas d'un assistant !!! }
      {#### NoLecon := SendDlgItemMessage(Dialog,idl_lecon, CB_GETCOUNT, WORD(0), DWORD(0)) + 1; }
      NoLecon := GetLessonCount + 1;
      if CreateNewLessonRep(NoLecon, tLecon) then
      begin
        StrCopy(tLecon.Createur, '');
        tLecon.Langue := 0;
        tLecon.Syquest := False;
        tLecon.Serveur := True;
        if SetLessonRec(NoLecon, tLecon) then
        begin
          dwReturn := SendDlgItemMessage(Dialog, idl_Lecon, CB_ADDSTRING,
            0, DWORD(@tLecon.Nom));
          if (dwReturn <> CB_ERR) and (dwReturn <> CB_ERRSPACE) then
          begin
            SendDlgItemMessage(Dialog, idl_Lecon, CB_SETITEMDATA, word(dwReturn),
              longint(NoLecon - 1));
          end;
          SendDlgItemMessage(Dialog, idl_lecon, CB_SETCURSEL, dwReturn, 0);
          OpenLesson := True;
        end;
      end;
    end;
  end;
end;

procedure SetDureeReponse(var tQuestion: TypeQuestion;
  DureeProp, DureeBlanc: longint; Dialog: HWND;
  nFirst, nLast, nRatio: integer);
var
  n: integer;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 114, 0, 0, 0, nil, True);
  {$ENDIF}

  n := nFirst;
  while (IsDlgButtonChecked(Dialog, n) <> 1) and (n <= nLast) do
  begin
    Inc(n);
  end;
  Dec(n, nFirst);
  case n of
    0: tQuestion.DureeReponse := (DureeBlanc div (wNbBits div 8)) div FrequEch;
    1: tQuestion.DureeReponse := (DureeProp div (wNbBits div 8)) div FrequEch + 1;
    2: tQuestion.DureeReponse := 1;
    else
      tQuestion.DureeReponse := 0;
  end;
  tQuestion.DureeReponse := tQuestion.DureeReponse *
    GetTrackPos(GetDlgItem(Dialog, nRatio)) div 5;
  tQuestion.ReponseSon := True;
end;

function MoveTo(_para1: HDC; _para2: longint; _para3: longint): DWORD;
var
  _para4: TPoint;
begin
  //MoveToEx(_para1, _para2, _para3, @_para4);
  //MoveTo := MAKELONG(_para4.x,_para4.y);
  MoveToEx(_para1, _para2, _para3, nil);
  //MoveTo := MAKELONG(_para4.x,_para4.y);
end;

procedure MemoryRead(lpFar: PChar; ofs: DWORD; lpNear: PChar; len: DWORD);
begin
  CopyMemory(lpNear, lpFar + ofs, len);
end;

procedure MemoryWrite(lpFar: PChar; ofs: DWORD; lpNear: PChar; len: DWORD);
begin
  CopyMemory(lpFar + ofs, lpNear, len);
end;



{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function EnregistreProc(Dialog: HWnd; Message, WParam: DWord;
  LParam: longint): Bool; stdcall;
type
  PAPOINT = ^TAPOINT;
  TAPOINT = array[0..15000] of TPOINT;
var
  MinPos, MaxPos, ScrollPos, ScrollValue: integer;
  hWndOscillo: HWND;
  lVert: longint;
  lRouge: longint;
  nTimeCut: integer;
  szLecon, szFormat: array[0..127] of char;
  pLecon: PChar;
  dc: HDC;
  i, j, nmin, nmax, Sample: integer;
  lOfs: longint;
  pt: TPOINT;
  hOldPen: HPEN;
  pSample: POINTER;

const
  RCOFF = 1;
  wSize: word = 0;
  nSubBlock: integer = 0;
  nBase: integer = 0;
  nTop: integer = 0;
  nPoints: integer = 0;
  hPoints: THANDLE = 0;
  pPoints: PAPOINT = nil;
  hRPen: HPEN = 0;
  hGPen: HPEN = 0;
  rc: TRECT = ();
  rSeuil: TRECT = ();
  nSec: integer = 0;
  n10Sec: integer = 0;
  PauseNo: integer = 0;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 115, 0, 0, 0, nil, True);
  {$ENDIF}

  EnregistreProc := True;
  case Message of
    wm_InitDialog:
    begin
      CenterDialog(Dialog);
      GetWindowText(Dialog, szFormat, SizeOf(szFormat));
      GetDlgItemText(hListBar, idl_lecon, szLecon, SizeOf(szLecon));
      pLecon := @szLecon;
      wvsprintf(szMessage, szFormat, pLecon);
      SetWindowText(Dialog, szMessage);
      PropositionNo := 0;
      BlancRestant := 0;
      DureeProp := 0;
      DureeBlanc := 0;
      FileOpen := False;
      EnRoute := False;
      Pause := False;
      nTimeCut := dwIniBlockSize * 10 div (FrequEch * (wNbBits div 8));
      SetTrackRange(GetDlgItem(Dialog, 106), nTimeCut, 80, True);
      nTimeCut := dwBlockSize * 10 div (FrequEch * (wNbBits div 8));
      SetTrackPos(GetDlgItem(Dialog, 106), nTimeCut, True);
      SetTrackRange(GetDlgItem(Dialog, 107), 0, 127, True);
      SetTrackPos(GetDlgItem(Dialog, 107), Seuil, True);
      SetTrackRange(GetDlgItem(Dialog, 201), 0, 49, True);
      SetTrackPos(GetDlgItem(Dialog, 201), 8, True);
      EnableWindow(GetDlgItem(Dialog, 106), False);
      EnableWindow(GetDlgItem(Dialog, 107), False);
      EnableWindow(GetDlgItem(Dialog, 201), False);
      EnableWindow(GetDlgItem(Dialog, 202), False);
      EnableWindow(GetDlgItem(Dialog, 203), False);
      EnableWindow(GetDlgItem(Dialog, 204), False);
      nSec := nTimeCut div 10;
      n10Sec := nTimeCut - (nTimeCut div 10) * 10;
      wvsprintf(szFormat, '%d.%d0', @nSec);
      SetDlgItemText(Dialog, 104, szFormat);
      SetDlgItemInt(Dialog, idr_ValSBlanc, Seuil, False);
      CheckDlgButton(Dialog, 108, 1);
      CheckRadioButton(Dialog, 202, 204, 203);
      SetSbpMixSource(SbpMixLineIn);
      Exit;
    end;

    wm_hScroll:
      if IsDlgButtonChecked(Dialog, 108) = 0 then
      begin
        ScrollPos := GetTrackPos(hiWord(LParam));
        GetTrackRange(hiWord(LParam), MinPos, MaxPos);
        case WPAram of
          SB_LINEUP: ScrollValue := -1;
          SB_LINEDOWN: ScrollValue := +1;
          SB_PAGEUP: ScrollValue := -(MaxPos div 5 + 1);
          SB_PAGEDOWN: ScrollValue := +(MaxPos div 5 + 1);
          SB_THUMBPOSITION,
          SB_THUMBTRACK: ScrollValue := LoWord(LParam) - ScrollPos;
          else
            ScrollValue := 0;
        end;
        ScrollValue := max(-SCrollPos, min(ScrollValue, MaxPos - ScrollPos));
        ScrollPos := ScrollPos + ScrollValue;
        SetTrackPos(hiWord(LParam), ScrollPos, True);
        if hiWord(LParam) = GetDlgItem(Dialog, 106) then
        begin
          nSec := ScrollPos div 10;
          n10Sec := ScrollPos - (ScrollPos div 10) * 10;
          wvsprintf(szFormat, '%d.%d0', @nSec);
          SetDlgItemText(Dialog, 104, szFormat);
          dwBlockSize := longint(ScrollPos) * FrequEch * (wNbBits div 8) div 10;
        end
        else
        begin
          if hiWord(LParam) = GetDlgItem(Dialog, 107) then
          begin
            SetDlgItemInt(Dialog, 105, ScrollPos, False);
            Seuil := ScrollPos;
          end
          else
          begin
            ScrollPos := ScrollPos * 20;
            SetDlgItemInt(Dialog, 200, ScrollPos, False);
          end;
        end;
      end;

    wm_Command:
    begin
      case LoWord(wParam) of

        109:
        begin
          ExecSBPMixer;
        end;

        108:
        begin
          EnableWindow(GetDlgItem(Dialog, 106), IsDlgButtonChecked(Dialog, 108) = 0);
          EnableWindow(GetDlgItem(Dialog, 107), IsDlgButtonChecked(Dialog, 108) = 0);
          EnableWindow(GetDlgItem(Dialog, 201), IsDlgButtonChecked(Dialog, 108) = 0);
          EnableWindow(GetDlgItem(Dialog, 202), IsDlgButtonChecked(Dialog, 108) = 0);
          EnableWindow(GetDlgItem(Dialog, 203), IsDlgButtonChecked(Dialog, 108) = 0);
          EnableWindow(GetDlgItem(Dialog, 204), IsDlgButtonChecked(Dialog, 108) = 0);
        end;

        idr_Quit:
        begin
          if EnRoute then
          begin
            EnRoute := False;
            WaveInStop(hWavIn);
            WaveInReset(hWavIn);
            waveInUnPrepareHeader(hWavIn, lpWavHdrRec[0], SizeOf(TWAVEHDR));
            waveInUnPrepareHeader(hWavIn, lpWavHdrRec[1], SizeOf(TWAVEHDR));
            waveInUnPrepareHeader(hWavIn, lpWavHdrRec[2], SizeOf(TWAVEHDR));
            {#### attention caster le Handle sans passer l'adresse : Erreur Doc. ####}
            if WaveInClose(HWAVEIN(hWavIn)) <> 0 then
              MessageBox(Dialog, mmLoadString(hInstRes, ERR_WAVPERIPH),
                'WaveInClose', MB_OK + MB_ICONSTOP);
            CloseWaveFile;
            FreeAllGlobal;
          end;
          EnregistreProc := True;
          EndDialog(Dialog, -1);
          Exit;
        end;

        idr_Demare:
          if not EnRoute then
          begin
            if not Pause then
            begin
              if CreateNewLesson(hListBar, tLecon, PropositionNo) then
              begin
                nNextWavNo := 1000;
                repeat
                  Inc(nNextWavNo);
                  QuestionFileName(NextQName, nNextWavNo);
                until not FileExist(NextQName);
                { créer un fichier bidon pour activer les caches... }
                if pFormat = nil then
                begin
                  OpenNewWaveFile(Dialog, NextQName);
                  CloseWaveFile;
                  Efface(NextQName);
                end;
                if StartLessonRec(Dialog) then
                begin
                  EnRoute := True;
                  SetDlgItemText(Dialog, idr_Demare, mmLoadString(hInstRes, STR_STOP));
                  SetDlgItemText(Dialog, 110, mmLoadString(hInstRes, STR_REC));
                  //SendDlgItemMessage(Dialog, 113, STM_SETICON, hLed_R, 0);
                end;
              end;
            end;
          end
          else
          begin
            EnRoute := False;
            WaveInStop(hWavIn);
            WaveInReset(hWavIn);
            waveInUnPrepareHeader(hWavIn, lpWavHdrRec[0], SizeOf(TWAVEHDR));
            waveInUnPrepareHeader(hWavIn, lpWavHdrRec[1], SizeOf(TWAVEHDR));
            waveInUnPrepareHeader(hWavIn, lpWavHdrRec[2], SizeOf(TWAVEHDR));
            {#### attention caster le Handle sans passer l'adresse : Erreur Doc. ####}
            if WaveInClose(HWAVEIN(hWavIn)) <> 0 then
              MessageBox(Dialog, mmLoadString(hInstRes, ERR_WAVPERIPH),
                'WaveInClose', MB_OK + MB_ICONSTOP);
            CloseWaveFile;
            FreeAllGlobal;
            FileOpen := False;
            SetDlgItemText(Dialog, idr_Demare, mmLoadString(hInstRes, STR_START));
            SetDlgItemText(Dialog, 110, mmLoadString(hInstRes, STR_STOP));
            //SendDlgItemMessage(Dialog, 113, STM_SETICON, hLed_N, 0);
          end;

        idr_Pause:
          if EnRoute then
          begin
            EnRoute := False;
            if WaveInStop(hWavIn) <> 0 then
              MessageBox(Dialog, mmLoadString(hInstRes, ERR_WAVPERIPH),
                'WaveInStop', MB_OK + MB_ICONSTOP);
            if WaveInReset(hWavIn) <> 0 then
              MessageBox(Dialog, mmLoadString(hInstRes, ERR_WAVPERIPH),
                'WaveInReset', MB_OK + MB_ICONSTOP);
            waveInUnPrepareHeader(hWavIn, lpWavHdrRec[0], SizeOf(TWAVEHDR));
            waveInUnPrepareHeader(hWavIn, lpWavHdrRec[1], SizeOf(TWAVEHDR));
            waveInUnPrepareHeader(hWavIn, lpWavHdrRec[2], SizeOf(TWAVEHDR));
            {#### attention caster le Handle sans passer l'adresse : Erreur Doc. ####}
            if WaveInClose(HWAVEIN(hWavIn)) <> 0 then
              MessageBox(Dialog, mmLoadString(hInstRes, ERR_WAVPERIPH),
                'WaveInClose', MB_OK + MB_ICONSTOP);
            CloseWaveFile;
            FreeAllGlobal;
            SetDlgItemText(Dialog, 110, mmLoadString(hInstRes, STR_PAUSE));
            //SendDlgItemMessage(Dialog, 113, STM_SETICON, hLed_J, 0);
            Pause := True;
            PauseNo := PropositionNo;
          end
          else
          begin
            if Pause then
            begin
              PropositionNo := PauseNo + 1;
              if StartLessonRec(Dialog) then
              begin
                PropositionNo := PropositionNo - 1;
                if PropositionNo < 1 then
                  PropositionNo := 1;
                Pause := False;
                EnRoute := True;
                SetDlgItemText(Dialog, 110, mmLoadString(hInstRes, STR_RESTART));
                //SendDlgItemMessage(Dialog, 113, STM_SETICON, hLed_R, 0);
              end;
            end;
          end;
      end;

      //case HiWord(LParam) of
      case HiWord(wParam) of

        BN_CLICKED:
        begin
          if EnRoute then
            CheckDlgButton(Dialog, 108, 1);
        end;
      end;
    end;

    MM_WIM_OPEN:
    begin
      GetClientRect(GetDlgItem(Dialog, idr_FormeOnde), rc);
      InflateRect(rc, -RCOFF, -RCOFF);
      nBase := (rc.bottom - rc.top) div 2;
      nPoints := (rc.right - rc.left) * 2;
      wSize := pFormat^.wf.nBlockAlign div pFormat^.wf.nChannels;
      case wSize of
        1:
        begin
          nTop := 255;
          Inc(nBase, nBase);
          SeuilHaut := 128 + Seuil;
          SeuilBas := 128 - Seuil;
        end;
        2:
        begin
          nTop := 32767;
          SeuilHaut := Seuil * 256;
          SeuilBas := Seuil * -256;
        end;
      end;
      ExtraBlancDeb := 3000 * pFormat^.wf.nBlockAlign;
      ExtraBlancFin := 3000 * pFormat^.wf.nBlockAlign;
      rSeuil.left := rc.left - 1;
      rSeuil.top := integer(nBase - MulDiv(SeuilHaut, nBase, nTop)) + RCOFF;
      rSeuil.right := rc.right - 1;
      rSeuil.bottom := integer(nBase - MulDiv(SeuilBas, nBase, nTop)) + RCOFF;
      if nPoints = 0 then
      begin
        exit;
      end;
      nSubBlock := lpWavHdrRec[0]^.dwBufferLength div
        pFormat^.wf.nBlockAlign div nPoints * 2;

      hGPen := CreatePen(PS_SOLID, 1, RGB(0, 255, 0));
      hRPen := CreatePen(PS_SOLID, 1, RGB(255, 0, 0));

      { Allocate and lock memory for the waveform data. }
      hPoints := GlobalAlloc(GMEM_MOVEABLE, nPoints * SizeOf(TPOINT));
      { GMEM_SHARE is not needed on 32 bits }
      if (hPoints = 0) then
      begin
        MessageBox(GetActiveWindow, 'Out of memory.',
          'hPoints', MB_OK or MB_ICONEXCLAMATION);
        exit;
      end;

      pPoints := PAPOINT(GlobalLock(hPoints));
      if (pPoints = nil) then
      begin
        MessageBox(GetActiveWindow, 'Failed to lock memory.',
          'hPoints', MB_OK or MB_ICONEXCLAMATION);
        GlobalFree(hPoints);
        exit;
      end;
    end;

    MM_WIM_DATA:
      if EnRoute then
      begin

      {$IFOPT R+}
        {$R-}
        {$DEFINE _RANGE_ON}
      {$ENDIF}
        { Prepare the point array. }
        BlancDeb := 0;
        IncDeb := pFormat^.wf.nBlockAlign;
        BlancFin := 0;
        IncFin := 0;
        i := 0;
        lOfs := 0;
        Sample := 0;
        while i < nPoints do
        begin
          nmin := nTop;
          nmax := -nTop;
          j := 0;
          while j < nSubBlock do
          begin
            pSample := lpDataRec[NoBlock] + lOfs;
            //Ptr(PtrRec(lpDataRec[NoBlock]).Hi + PtrRec(lOfs).Hi * Ofs(AHIncr),PtrRec(lOfs).Lo);
            Move(pSample^, Sample, wSize);
            if Sample > nmax then
              nmax := Sample;
            if Sample < nmin then
              nmin := Sample;
            Inc(lOfs, pFormat^.wf.nBlockAlign);
            Inc(j);
            { detect speech zone }
            if (Sample >= SeuilBas) and (Sample <= SeuilHaut) then
            begin
              Inc(BlancDeb, IncDeb);
              Inc(BlancFin, IncFin);
            end
            else
            begin
              IncDeb := 0;
              BlancFin := 0;
              IncFin := pFormat^.wf.nBlockAlign;
            end;
          end;
          pPoints^[i].x := i div 2 + RCOFF;
          pPoints^[i].y := integer(nBase - MulDiv(nmin, nBase, nTop)) + RCOFF;
          Inc(i);
          pPoints^[i].x := pPoints^[i - 1].x;
          pPoints^[i].y := integer(nBase - MulDiv(nmax, nBase, nTop)) + RCOFF;
          Inc(i);
        end;
        { detect speech zone in rest of the block }
        while lOfs < dwBlockSize do
        begin
          pSample := lpDataRec[NoBlock] + lOfs;
          //Ptr(PtrRec(lpDataRec[NoBlock]).Hi + PtrRec(lOfs).Hi * Ofs(AHIncr),PtrRec(lOfs).Lo);
          Move(pSample^, Sample, wSize);
          Inc(lOfs, pFormat^.wf.nBlockAlign);
          { detect speech zone }
          if (Sample >= SeuilBas) and (Sample <= SeuilHaut) then
          begin
            Inc(BlancDeb, IncDeb);
            Inc(BlancFin, IncFin);
          end
          else
          begin
            IncDeb := 0;
            BlancFin := 0;
            IncFin := pFormat^.wf.nBlockAlign;
          end;
        end;
      {$IFDEF _RANGE_ON}
        {$R+}
        {$UNDEF _RANGE_ON}
      {$ENDIF}

        { Display the sound. }
        dc := GetDC(GetDlgItem(Dialog, idr_FormeOnde));
        ExcludeClipRect(dc, rc.left, rc.bottom, rc.right, rc.bottom + 1);
        PatBlt(dc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, Blackness);
        hOldPen := SelectObject(dc, hRPen);
        MoveTo(dc, rSeuil.right, rSeuil.top);
        LineTo(dc, rSeuil.left, rSeuil.top);
        MoveTo(dc, rSeuil.right, rSeuil.bottom);
        LineTo(dc, rSeuil.left, rSeuil.bottom);
        SelectObject(dc, hGPen);
        PolyLine(dc, TPOINT(pPoints^[0]), nPoints);
        SelectObject(dc, hOldPen);
        ReleaseDC(GetDlgItem(Dialog, idr_FormeOnde), dc);

        { save the sound. }
        {[/\...][.../\]}
        if BlancRestant + BlancDeb >= dwBlockSize then
        begin
          if FileOpen then
          begin
            {Enreg début BlancDeb à la fin du précédant...}
            if (BlancRestant = 0) then
            begin
              if (lpWavHdrRec[NoBlock]^.dwBytesRecorded >= ExtraBlancFin) then
              begin
                mmioWrite(hmio, lpDataRec[NoBlock], ExtraBlancFin);
              end
              else
              begin
                mmioWrite(hmio, lpDataRec[NoBlock], lpWavHdrRec[NoBlock]^.dwBytesRecorded);
              end;
            end;
            {ferme...}
            CloseWaveFile;
            repeat
              Inc(nNextWavNo);
              QuestionFileName(NextQName, nNextWavNo);
            until not FileExist(NextQName);
            wvsprintf(szMessage, mmLoadString(hInstRes, STR_ENDREC), @PropositionNo);
            SetDlgItemText(Dialog, 110, szMessage);
            DureeBlanc := BlancDeb + BlancRestant;
            BlancRestant := 0;
            FileOpen := False;

            if BlancDeb < dwBlockSize then
            begin
              PropositionNo := PropositionNo + 1;
              OldQName := NewQName;
              NewQName := NextQName;
              OpenNewWaveFile(Dialog, NewQName);
              {sauve le Blanc de fin...}
              if BlancDeb >= ExtraBlancDeb then
              begin
                BlancDeb := BlancDeb - ExtraBlancDeb;
              end
              else
              begin
                BlancDeb := 0;
              end;
              if BlancFin >= ExtraBlancFin then
              begin
                BlancFin := BlancFin - ExtraBlancFin;
              end
              else
              begin
                BlancFin := 0;
              end;
              {écrit le Blanc de la fin précedent...}
              mmioWrite(hmio, lpBlockBlanc, BlancRestant);
              BlancRestant := BlancFin;
              MemoryRead(lpDataRec[NoBlock], lpWavHdrRec[NoBlock]^.dwBytesRecorded -
                BlancRestant, lpBlockBlanc, BlancRestant);
              {écrit en enlevant le Blanc du début...}
              MemoryRead(lpDataRec[NoBlock], BlancDeb, lpDataRec[NoBlock],
                lpWavHdrRec[NoBlock]^.dwBytesRecorded - BlancDeb - BlancFin);
              mmioWrite(hmio, lpDataRec[NoBlock],
                lpWavHdrRec[NoBlock]^.dwBytesRecorded - BlancDeb - BlancFin);
              DureeBlanc := DureeBlanc + BlancDeb;
              {Fin du blanc précédent... Sauve la durée...}
              FileOpen := True;
              wvsprintf(szMessage, mmLoadString(hInstRes, STR_STARTREC), @PropositionNo);
              SetDlgItemText(Dialog, 110, szMessage);

              if OldQName[0] <> #0 then
              begin
                FillChar(tQuestion, SizeOf(tQuestion), 0);
                if PropositionNo - 1 < 10 then
                  StrPCopy(tQuestion.Nom, '  ' + IntToStr(PropositionNo - 1) + ' - ')
                else
                  StrPCopy(tQuestion.Nom, IntToStr(PropositionNo - 1) + ' - ');
                StrCopy(tQuestion.FichierQuestion, OldQName);
                SetDureeReponse(tQuestion, DureeProp, DureeBlanc, Dialog, 202, 204, 201);
                SetQuestionRec(PropositionNo - 1, tQuestion);
              end;
              DureeProp := lpWavHdrRec[NoBlock]^.dwBytesRecorded - BlancDeb - BlancFin;
            end;

          end
          else
          begin
            {File Closed...}
            if PropositionNo <> 0 then
            begin
              wvsprintf(szMessage, mmLoadString(hInstRes, STR_BLANKREC), @PropositionNo);
              SetDlgItemText(Dialog, 110, szMessage);
              DureeBlanc := DureeBlanc + BlancDeb;
            end;
          end;
        end
        else
        begin
          {[/\../][\../\]}
          if not FileOpen then
          begin
            PropositionNo := PropositionNo + 1;
            {####}
            OldQName := NewQName;
            NewQName := NextQName;
            OpenNewWaveFile(Dialog, NewQName);
            {sauve le Blanc de fin...}
            if BlancDeb >= ExtraBlancDeb then
            begin
              BlancDeb := BlancDeb - ExtraBlancDeb;
            end
            else
            begin
              BlancDeb := 0;
            end;
            if BlancFin >= ExtraBlancFin then
            begin
              BlancFin := BlancFin - ExtraBlancFin;
            end
            else
            begin
              BlancFin := 0;
            end;
            {écrit le Blanc de la fin précedent...}
            mmioWrite(hmio, lpBlockBlanc, BlancRestant);
            BlancRestant := BlancFin;
            MemoryRead(lpDataRec[NoBlock], lpWavHdrRec[NoBlock]^.dwBytesRecorded -
              BlancRestant, lpBlockBlanc, BlancRestant);
            {écrit en enlevant le Blanc du début...}
            MemoryRead(lpDataRec[NoBlock], BlancDeb, lpDataRec[NoBlock],
              lpWavHdrRec[NoBlock]^.dwBytesRecorded - BlancDeb - BlancFin);
            mmioWrite(hmio, lpDataRec[NoBlock],
              lpWavHdrRec[NoBlock]^.dwBytesRecorded - BlancDeb - BlancFin);
            DureeBlanc := DureeBlanc + BlancDeb;
            {Fin du blanc précédent... Sauve la durée...}
            FileOpen := True;
            wvsprintf(szMessage, mmLoadString(hInstRes, STR_STARTREC), @PropositionNo);
            SetDlgItemText(Dialog, 110, szMessage);
            if OldQName[0] <> #0 then
            begin
              FillChar(tQuestion, SizeOf(tQuestion), 0);
              if PropositionNo - 1 < 10 then
                StrPCopy(tQuestion.Nom, '  ' + IntToStr(PropositionNo - 1) + ' - ')
              else
                StrPCopy(tQuestion.Nom, IntToStr(PropositionNo - 1) + ' - ');
              QuestionFileName(PathFichier, PropositionNo - 1);
              StrCopy(tQuestion.FichierQuestion, OldQName);
              {####}
              SetDureeReponse(tQuestion, DureeProp, DureeBlanc, Dialog, 202, 204, 201);
              SetQuestionRec(PropositionNo - 1, tQuestion);
            end;
            DureeProp := lpWavHdrRec[NoBlock]^.dwBytesRecorded - BlancDeb - BlancFin;
          end
          else
          begin
            {File Opened ...}
            if BlancFin >= ExtraBlancFin then
            begin
              BlancFin := BlancFin - ExtraBlancFin;
            end
            else
            begin
              BlancFin := 0;
            end;
            {écrit le Blanc de la fin précedent...}
            mmioWrite(hmio, lpBlockBlanc, BlancRestant);
            {écrit en enlevant le Blanc de la fin...}
            mmioWrite(hmio, lpDataRec[NoBlock],
              lpWavHdrRec[NoBlock]^.dwBytesRecorded - BlancFin);
            {            mmioWrite(hmio, lpDataRec[NoBlock], lpWavHdrRec[NoBlock]^.dwBytesRecorded);}
            DureeProp := DureeProp + lpWavHdrRec[NoBlock]^.dwBytesRecorded -
              BlancFin + BlancRestant;
            BlancRestant := BlancFin;
            MemoryRead(lpDataRec[NoBlock], lpWavHdrRec[NoBlock]^.dwBytesRecorded -
              BlancRestant, lpBlockBlanc, BlancRestant);
            wvsprintf(szMessage, mmLoadString(hInstRes, STR_PROCESSREC), @PropositionNo);
            SetDlgItemText(Dialog, 110, szMessage);
          end;
        end;
        nSecDureeBlanc := (DureeBlanc div (wNbBits div 8)) div FrequEch;
        wvsprintf(szMessage, mmLoadString(hInstRes, STR_BLANK), @nSecDureeBlanc);
        SetDlgItemText(Dialog, 120, szMessage);
        NextBlockRec(NoBlock);
        NbBlocks := NbBlocks + 1;
        NoBlock := NoBlock + 1;
        if NoBlock > 2 then
          NoBlock := 0;
      end;

    mm_WIM_CLOSE:
    begin

      if NewQName[0] <> #0 then
      begin
        FillChar(tQuestion, SizeOf(tQuestion), 0);
        if PropositionNo < 10 then
          StrPCopy(tQuestion.Nom, '  ' + IntToStr(PropositionNo) + ' - ')
        else
          StrPCopy(tQuestion.Nom, IntToStr(PropositionNo) + ' - ');
        QuestionFileName(PathFichier, PropositionNo);
        StrCopy(tQuestion.FichierQuestion, NewQName);
        SetDureeReponse(tQuestion, DureeProp, DureeBlanc, Dialog, 202, 204, 201);
        SetQuestionRec(PropositionNo, tQuestion);
      end;

      PropositionNo := 0;
      BlancRestant := 0;
      DureeProp := 0;
      DureeBlanc := 0;

      DeleteObject(hGPen);
      DeleteObject(hRPen);
      hGPen := 0;
      hRPen := 0;
      { Unlock and free memory for the waveform point array. }
      GlobalUnlock(hPoints);
      GlobalFree(hPoints);
      hPoints := 0;
      pPoints := nil;
    end;
  end;
  EnregistreProc := False;
end;


{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function AfficheLed(hLed: THandle): THandle;
var
  hOldLed: THandle;
  IconWin: Hwnd;
  IconX, IconY: integer;
  rc: TRECT;
  pt: TPOINT;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 116, 0, 0, 0, nil, True);
  {$ENDIF}

  //hOldLed := THandle(SendDlgItemMessage(hBoutonsProc, 113, STM_GETICON, 0, 0));
  hOldLed := SendDlgItemMessage( hBoutonsProc, 113, BM_GETIMAGE, IMAGE_ICON, 0 );
  if hOldLed = 0 then
    hOldLed := hLed_N;

  SendDlgItemMessage( hBoutonsProc, 113, BM_SETIMAGE, IMAGE_ICON, hLed );

  //SendDlgItemMessage(hBoutonsProc, 113, STM_SETICON, hLed, 0);

  AfficheLed := hOldLed;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure ResetLecon(hList: HWND);
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 117, 0, 0, 0, nil, True);
  {$ENDIF}

  SendDlgItemMessage(hList, idl_ListeQ, LB_RESETCONTENT, 0, longint(0));
  SetDlgItemText(hList, 104, '');
  SetDlgItemText(hList, 202, '');
  SetDlgItemText(hList, 203, '');
  SetDlgItemText(hList, 204, '');
  SetDlgItemText(hList, 205, '');
  SetDlgItemText(hList, 206, '');
  CheckDlgButton(hList, 207, 0);
  CheckDlgButton(hList, 208, 0);
end;

{************************************************}

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
type
  PWinInfo = ^TWinInfo;

  TWinInfo = record
    hInst: THANDLE;
    hWin: HWND;
  end;

function MyEnumWindowsProc(hWin: HWND; lParam: DWORD): BOOL; stdcall;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 118, 0, 0, 0, nil, True);
  {$ENDIF}

  if GetWindowWord(hWin, GWL_HINSTANCE) = PWinInfo(lParam)^.hInst then
  begin
    PWinInfo(lParam)^.hWin := hWin;
    MyEnumWindowsProc := False;
  end
  else
  begin
    MyEnumWindowsProc := True;
  end;
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function Exec(var hInst, hWnd, hMenu: THandle; AppCmd, AppName, AppDir: PChar): BOOL;

var
  lpEnumWindowsProc: TFARPROC;
  WinInfo: TWinInfo;
  MSG: TMSG;
  p: PChar;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 119, 0, 0, 0, nil, True);
  {$ENDIF}

  {#### if (SetActiveWindow(Window) = 0) then MessageBeep(word(-1));}

  p := StrPos(AppName, ' ');
  if p <> nil then
  begin
    p[0] := #0;
    Inc(p);
  end;

  if (p <> nil) and ((StrPos(p, '/cftp.exe') <> nil) or
    (StrPos(p, ' -t "') <> nil)) then
  begin
    hInst := ShellExecute(0, AppCmd, AppName, p, AppDir, SW_SHOWMINIMIZED);
  end
  else
  begin
    hInst := ShellExecute(0, AppCmd, AppName, p, AppDir, SW_SHOW);
  end;
  if hInst > 32 then
  begin
    while PeekMessage(MSG, 0, 0, 0, PM_REMOVE) do
    begin
      TranslateMessage(MSG);
      DispatchMessage(MSG);
    end;

    WinInfo.hWin := 0;
    WinInfo.hInst := hInst;

    //lpEnumWindowsProc := MakeProcInstance(@EnumWindowsProc, hInstance);
    //lpEnumWindowsProc := @MyEnumWindowsProc;
    //EnumWindows(lpEnumWindowsProc, DWORD(@WinInfo));
    //FreeProcInstance(lpEnumWindowsProc);
    //lpEnumWindowsProc := @MyEnumWindowsProc;
    EnumWindows(@MyEnumWindowsProc, DWORD(@WinInfo));

    hWnd := WinInfo.hWin;
    {while (GetParent(hWnd) <> 0) do hWnd := GetParent(hWnd);}
    hMenu := GetMenu(hWnd);

    Exec := True;

  end
  else
  begin

    {Il y a une erreur alors on positionne CopyError}
    MessageBeep(word(-1));
    MessageBox(0, AppName, 'Erreur Exec ...', 0);
    hWnd := 0;
    hMenu := 0;
    CopyError := hInst;

    Exec := False;
  end;

end;

{************************************************}

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
function WaitEnd(hWin: HWND): BOOL;
var
  MSG: TMSG;
begin
  { désactive créateur }
  SendMessage(window, WM_USER + 1000, word(False), 0);

  while IsWindow(hWin) do
  begin
    if PeekMessage(MSG, 0, 0, 0, PM_REMOVE) then
    begin
      TranslateMessage(MSG);
      DispatchMessage(MSG);
    end;
  end;

  { réactive créateur }
  SendMessage(window, WM_USER + 1000, word(True), 0);
end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure ExecSBPMixer;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 120, 0, 0, 0, nil, True);
  {$ENDIF}

  Exec(hInstSBPMixer, hWndSBPMixer, hMenuSBPMixer, nil, szMixer, nil);
end;

{**************************************************************}

function IsInCurLesson(pszFileName: PChar): Bool;
var
  Dir: array[0..fsDirectory] of char;
  Name: array[0..fsFileName] of char;
  Ext: array[0..fsExtension] of char;
  szRetName: array[0..fsDirectory + fsFileName + fsExtension] of char;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 121, 0, 0, 0, nil, True);
  {$ENDIF}

  FileSplit(pszFileName, Dir, Name, Ext);
  if (Dir[StrLen(Dir) - 1] = '\') then
    Dir[StrLen(Dir) - 1] := #0;
  IsInCurLesson := StrIcomp(tLecon.PathLecon, Dir) = 0;

end;

function CopyInCurLesson(pszFileName, pszTemplateName: PChar; nItem: integer): Bool;
var
  Dir: array[0..fsDirectory] of char;
  Name: array[0..fsFileName] of char;
  Ext: array[0..fsExtension] of char;
  szRetName: array[0..fsDirectory + fsFileName + fsExtension] of char;
  szMessage: array[0..255] of char;
  MSG: TMSG;
  {dwRet       : DWORD;}
  fInfo: TSearchRec;

  //Regs : TRegisters;
  szLongFileName: array[0..255] of char;
  szShortFileName: array[0..255] of char;

begin

  CopyInCurLesson := False;

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 121, 0, 0, 0, nil, True);
  {$ENDIF}

  if bWin95 then
  begin
    StrCopy(szLongFileName, pszFileName);
    AnsiToOemBuff(szLongFileName, szLongFileName, 255);
                {
                FillChar(Regs, SizeOf(Regs), 0);
    Regs.ax := $7160;
    Regs.cl := 1;
    Regs.ch := 0;
    Regs.ds := Seg(szLongFileName);
    Regs.si := Ofs(szLongFileName);
    Regs.es := Seg(szShortFileName);
    Regs.di := Ofs(szShortFileName);
    MsDos(Regs);
                }
    while PeekMessage(MSG, 0, 0, 0, PM_REMOVE) do
    begin
      TranslateMessage(MSG);
      DispatchMessage(MSG);
    end;
    OemToAnsiBuff(szShortFileName, szShortFileName, 255);
    StrCopy(pszFileName, szShortFileName);
  end;

  DosError := FindFirst(pszFileName, faAnyFile, fInfo);
  if DosError = 0 then
  begin
    if fInfo.Size > 2048 * 1024 then
    begin
      MessageBeep(MB_ICONQUESTION);
      wvsprintf(szMessage,
        'Le fichier %s fait plus de 2Mo, ' +
        'voulez-vous vraiment le recopier dans le répertoire leçon ?',
        pszFileName);
      if MessageBox(GetActiveWindow, szMessage, 'Question', MB_YESNO or
        MB_APPLMODAL or MB_ICONQUESTION) <> idYes then
        exit;
    end;
  end
  else
  begin
    wvsprintf(szMessage,
      'Le fichier %s n''existe pas.',
      pszFileName);
    MessageBeep(MB_ICONSTOP);
    MessageBox(GetActiveWindow, szMessage, 'Error', MB_OK or MB_APPLMODAL or MB_ICONSTOP);
    StrCopy(pszFileName, '');
    exit;
  end;
  FindClose(fInfo);

  FileSplit(pszFileName, Dir, Name, Ext);
  NewFile(szRetName, pszTemplateName, Ext, nItem);
  if not CopyFile(pszFileName, szRetName) then
  begin
    CopyErrorMessage(szMessage);
    StrCat(szMessage, ' : ');
    StrCat(szMessage, pszFileName);
    StrCat(szMessage, ' -> ');
    StrCat(szMessage, szRetName);
    MessageBeep(MB_ICONSTOP);
    MessageBox(GetActiveWindow, szMessage, 'Error', MB_OK or MB_APPLMODAL or MB_ICONSTOP);
    exit;
  end;

  if bVideoWave and IsVideoFile(pszFileName) then
  begin
    StrCopy(szVideoWave, pszFileName);
    pVideoWave := StrPos(szVideoWave, '.');
    if pVideoWave <> nil then
    begin
      pVideoWave[0] := #0;
      StrCat(szVideoWave, '.WAV');
      StrCopy(pszFileName, szRetName);
      pVideoWave := StrPos(szRetName, '.');
      if pVideoWave <> nil then
      begin
        pVideoWave[0] := #0;
        StrCat(szRetName, '.WAV');
        if not CopyFile(szVideoWave, szRetName) then
        begin
          CopyErrorMessage(szMessage);
          StrCat(szMessage, ' : ');
          StrCat(szMessage, pszFileName);
          StrCat(szMessage, ' -> ');
          StrCat(szMessage, szRetName);
          MessageBeep(MB_ICONSTOP);
          MessageBox(GetActiveWindow, szMessage, 'Error', MB_OK or
            MB_APPLMODAL or MB_ICONSTOP);
          exit;
        end;
      end;
    end;
  end
  else
  begin
    StrCopy(pszFileName, szRetName);
  end;

  CopyInCurLesson := True;

end;

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure CreerImage(Dialog, hList: HWnd; var szRet: szLongName);
var
  szImage: szLongName;
  PropositionName: szLongName;
  dwReturn: DWORD;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 122, 0, 0, 0, nil, True);
  {$ENDIF}

  {#### dwReturn := SendDlgItemMessage(hList, idl_ListeQ, LB_GETCURSEL, 0, LongInt(0)) + 1;}
  dwReturn := LBGetFirstSel(hList, idl_ListeQ) + 1;
  NewBitmapFile(PropositionName, dwReturn);
  SetFocus(GetDlgItem(Dialog, 106));
  {StrCopy(szImage,PathServeur);
  StrCat(szImage,PathLavac);}
  if FileExist(szImageTemplate) then
  begin
    StrCopy(szImage, szImageTemplate);
  end
  else
  begin
    StrCopy(szImage, PathImages);
    StrCat(szImage, 'Bitmap.New');
  end;
  if CopyFile(szImage, PropositionName) then
  begin
    StrCopy(PathFichier, szImageEditor);
    StrCat(PathFichier, ' ');
    StrCat(PathFichier, PropositionName);
    if hInstPBrush = 0 then
    begin
      Exec(hInstPBrush, hWndPBrush, hMenuPBrush, nil, PathFichier, nil);
    end
    else
    begin
      SetActiveWindow(hWndPBrush);
      if hWndPBrush = GetActiveWindow then
      begin
        PostMessage(hWndPBrush, WM_CLOSE, word(0), MakeLong(word(0), word(0)));
      end;
      Exec(hInstPBrush, hWndPBrush, hMenuPBrush, nil, PathFichier, nil);
    end;
    EnableMenuItem(hMenuPBrush, 1000, MF_DISABLED + MF_GRAYED);
    EnableMenuItem(hMenuPBrush, 12, MF_DISABLED + MF_GRAYED);
    EnableMenuItem(hMenuPBrush, 14, MF_DISABLED + MF_GRAYED);
    ItWasBitmap := True;

    WaitEnd(hWndPBrush);
  end;
  szRet := PropositionName;
{  PostMessage(hWndPBrush,WM_COMMAND,WORD(13),MakeLong(WORD(0),WORD(0)));
  PostMessage(hWndPBrush,WM_CLOSE,WORD(0),MakeLong(WORD(0),WORD(0)));}
end;

{***************************************************************}
{ Crée un fichier V000000? dans la leçon en cours sur le serveur}
{***************************************************************}
procedure CreerVideo(Dialog, hList: HWnd; var szRet: szLongName);

var
  szVideo, szChaine, szChaine1: szLongName;
  szNomErreur: szPName;
  PropositionName: szLongName;
  dwReturn: DWORD;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 123, 0, 0, 0, nil, True);
  {$ENDIF}

  {#### dwReturn := SendDlgItemMessage(hList, idl_ListeQ, LB_GETCURSEL, 0, LongInt(0)) + 1;}
  dwReturn := LBGetFirstSel(hList, idl_ListeQ) + 1;
  NewVideoFile(PropositionName, dwReturn);

  SetFocus(GetDlgItem(Dialog, 106));

  if StrPos(StrUpper(szVideoEditor), 'VIDEONT') <> nil then
  begin
    GetPrivateProfileString('VIDEO NT', 'Program', 'C:\VIDEONT',
      PropositionName, SizeOf(PropositionName),
      'VITEC.INI');
    SetCurrentDirectory(PropositionName);
    StrCat(PropositionName, '\CAPTURE.');
    StrCat(PropositionName, szVideoDefExt);

    StrCopy(PathFichier, szVideoEditor);
    StrCat(PathFichier, ' ');
    StrCat(PathFichier, PropositionName);
    if hInstVidCap = 0 then
    begin
      Exec(hInstVidCap, hWndVidCap, hMenuVidCap, nil, PathFichier, nil);
      if ((copyError < 32) and (copyError > 1)) then
      begin
        CopyErrorMessage(szNomErreur);
        StrCat(szNomErreur, ' ');
        StrCat(szNomErreur, PathFichier);
        BoiteAlerte(szNomErreur);
        CopyError := -1;
      end;
    end
    else
    begin
      SetActiveWindow(hWndVidCap);
      if hWndVidCap = GetActiveWindow then
      begin
        PostMessage(hWndVidCap, WM_CLOSE, word(0), MakeLong(word(0), word(0)));
      end;
      Exec(hInstVidCap, hWndVidCap, hMenuVidCap, nil, PathFichier, nil);
    end;
    ItWasVideo := True;

    WaitEnd(hWndVidCap);

    szRet := PropositionName;
    exit;
  end;

  StrCopy(szVideo, PathImages);
  StrCat(szVideo, 'Video.New');
  StrCopy(PropositionName, 'C:\LAVAC.AVI');
  begin
    { On modifie le fichier mmTools.ini }
    if StrPos(StrUpper(szVideoEditor), 'VIDCAP.EXE') <> nil then
    begin
      {if WritePrivateProfileString('VidCap', 'capfile',PropositionName, 'MMTOOLS.INI')=FALSE then begin
        MessageBox(Window, mmLoadString(hInstRes, ERR_OPENFILE), 'MMTOOLS.INI', MB_OK OR MB_ICONSTOP);
        Exit;
      end;}
      StrCopy(PathFichier, szVideoEditor);
    end
    else
    begin
      StrCopy(PathFichier, szVideoEditor);
      StrCat(PathFichier, ' ');
      StrCat(PathFichier, PropositionName);
    end;
    if hInstVidCap = 0 then
    begin
      Exec(hInstVidCap, hWndVidCap, hMenuVidCap, nil, PathFichier, nil);
      if ((copyError < 32) and (copyError > 1)) then
      begin
        CopyErrorMessage(szNomErreur);
        StrCat(szNomErreur, ' ');
        StrCat(szNomErreur, PathFichier);
        BoiteAlerte(szNomErreur);
        CopyError := -1;
      end;
    end
    else
    begin
      SetActiveWindow(hWndVidCap);
      if hWndVidCap = GetActiveWindow then
      begin
        PostMessage(hWndVidCap, WM_CLOSE, word(0), MakeLong(word(0), word(0)));
      end;
      Exec(hInstVidCap, hWndVidCap, hMenuVidCap, nil, PathFichier, nil);
    end;
    ItWasVideo := True;

    WaitEnd(hWndVidCap);
  end;
  szRet := PropositionName;
end;

{**************************************************************}

{************************************************}
{ SE:                                            }
{ SI:                                            }
{************************************************}
procedure CreerSon(Dialog, hList: HWnd; var szRet: szLongName);
var
  szSon: szLongName;
  szFrequ: szPName;
  PropositionName: szLongName;
  dwReturn: DWORD;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 124, 0, 0, 0, nil, True);
  {$ENDIF}

  SetSbpMixSource(SbpMixMic);

  {#### dwReturn := SendDlgItemMessage(hList, idl_ListeQ, LB_GETCURSEL, 0, LongInt(0)) + 1;}
  dwReturn := LBGetFirstSel(hList, idl_ListeQ) + 1;
  NewQuestionFile(PropositionName, dwReturn);
  {StrCopy(szSon,PathServeur);
  StrCat(szSon,PathLavac);}
  StrCopy(szSon, PathSons);
  StrPCopy(szFrequ, IntToStr(FrequEch) + '_' + IntToStr(wNbBits));
  StrCat(szSon, szFrequ);
  StrCat(szSon, '.New');
  if CopyFile(szSon, PropositionName) then
  begin
    StrCopy(PathFichier, szSoundEditor);
    StrCat(PathFichier, ' ');
    StrCat(PathFichier, PropositionName);
    if hInstSoundRec = 0 then
    begin
      Exec(hInstSoundRec, hWndSoundRec, hMenuSoundRec, nil, PathFichier, nil);
    end
    else
    begin
      SetActiveWindow(hWndSoundRec);
      if hWndSoundRec = GetActiveWindow then
      begin
        PostMessage(hWndSoundRec, WM_CLOSE, word(0), MakeLong(word(0), word(0)));
      end;
      Exec(hInstSoundRec, hWndSoundRec, hMenuSoundRec, nil, PathFichier, nil);
    end;
    {EnableMenuItem(hMenuSoundRec,1000,MF_DISABLED + MF_GRAYED);
    EnableMenuItem(hMenuSoundRec,12,MF_DISABLED + MF_GRAYED);
    EnableMenuItem(hMenuSoundRec,14,MF_DISABLED + MF_GRAYED);}
    ItWasSon := True;

    WaitEnd(hWndSoundRec);
  end;
{  PostMessage(hWndSoundRec,WM_COMMAND,WORD(13),MakeLong(WORD(0),WORD(0)));
  PostMessage(hWndSoundRec,WM_CLOSE,WORD(0),MakeLong(WORD(0),WORD(0)));}
  szRet := PropositionName;
end;

procedure CreerTexte(Dialog, hList: HWnd; var szRet: szLongName);
var
  F: integer;
  f2: file;
  szTexte, PropositionName: szLongName;
  dwReturn: DWORD;
  rc: TRECT;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 125, 0, 0, 0, nil, True);
  {$ENDIF}

  {#### dwReturn := SendDlgItemMessage(hList, idl_ListeQ, LB_GETCURSEL, 0, LongInt(0)) + 1;}
  dwReturn := LBGetFirstSel(hList, idl_ListeQ) + 1;
  NewTexteFile(PropositionName, dwReturn);
  if StrPos(StrUpper(PropositionName), '.TXT') <> nil then
  begin
    F := _lcreat(PropositionName, 0);
    if F = -1 then
      exit;
    _lclose(F);
  end
  else
  begin
    if FileExist(szTextTemplate) then
    begin
      StrCopy(szTexte, szTextTemplate);
    end
    else
    begin
      StrCopy(szTexte, PathTextes);
      StrCat(szTexte, 'RTF.New');
    end;
    if not CopyFile(szTexte, PropositionName) then
      exit;

    {####}
    { créer le document à la taille de la fenêtre }
    GetClientRect(GetDlgItem(hTexteProc, 101), rc);
    {InflateRect(rc, -8, -8);}
    RtfSetPageInfo(PropositionName,
      PixelsToTwips(rc.right + 6, 0),
      PixelsToTwips(rc.bottom + 6, 1),
      0,
      0,
      0,
      0);
  end;
  Assign(f2, PChar(PropositionName));
  GetFattr(f2, wReturn);
  SetFattr(f2, wReturn or faShare);
  if StrLen(PropositionName) > 0 then
  begin
    StrCopy(PathFichier, szTextEditor);
    StrCat(PathFichier, ' ');
    StrCat(PathFichier, PropositionName);
    if hInstNotePad = 0 then
    begin
      Exec(hInstNotePad, hWndNotePad, hMenuNotePad, nil, PathFichier, nil);
    end
    else
    begin
      SetActiveWindow(hWndNotePad);
      if hWndNotePad = GetActiveWindow then
      begin
        PostMessage(hWndNotePad, WM_CLOSE, word(0), MakeLong(word(0), word(0)));
      end;
      Exec(hInstNotePad, hWndNotePad, hMenuNotePad, nil, PathFichier, nil);
    end;
    SendMessage(GetWindow(hWndNotePad, GW_CHILD), WM_SETFONT,
      SendDlgItemMessage(hTexteProc, 101, WM_GETFONT, 0, 0), MAKELONG(word(True), 0));
    EnableMenuItem(hMenuNotePad, 1000, MF_DISABLED + MF_GRAYED);
    EnableMenuItem(hMenuNotePad, 12, MF_DISABLED + MF_GRAYED);
    EnableMenuItem(hMenuNotePad, 14, MF_DISABLED + MF_GRAYED);
    ItWasTexte := True;
    WaitEnd(hWndNotePad);
  end;
  szRet := PropositionName;
end;

procedure EditerSon(Dialog: HWnd);
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 126, 0, 0, 0, nil, True);
  {$ENDIF}

  SetSbpMixSource(SbpMixMic);
  GetDlgItemText(HSonProc, 102, PropositionName, SizeOf(PropositionName));
  if (StrLen(PropositionName) > 0) and FileExist(PropositionName) then
  begin
    StrCopy(PathFichier, szSoundEditor);
    StrCat(PathFichier, ' ');
    StrCat(PathFichier, PropositionName);
    if hInstSoundRec = 0 then
    begin
      Exec(hInstSoundRec, hWndSoundRec, hMenuSoundRec, nil, PathFichier, nil);
    end
    else
    begin
      SetActiveWindow(hWndSoundRec);
      if hWndSoundRec = GetActiveWindow then
      begin
        PostMessage(hWndSoundRec, WM_CLOSE, word(0), MakeLong(word(0), word(0)));
      end;
      Exec(hInstSoundRec, hWndSoundRec, hMenuSoundRec, nil, PathFichier, nil);
    end;
    {EnableMenuItem(hMenuSoundRec,1000,MF_DISABLED + MF_GRAYED);
    EnableMenuItem(hMenuSoundRec,12,MF_DISABLED + MF_GRAYED);
    EnableMenuItem(hMenuSoundRec,14,MF_DISABLED + MF_GRAYED);}
    ItWasSon := True;
    WaitEnd(hWndSoundRec);
  end;
{  PostMessage(hWndSoundRec,WM_COMMAND,WORD(13),MakeLong(WORD(0),WORD(0)));
  PostMessage(hWndSoundRec,WM_CLOSE,WORD(0),MakeLong(WORD(0),WORD(0)));}
end;

{********************************************************}
procedure EditerImage(Dialog: HWnd);
var
  pdi: PDIBINFO;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 127, 0, 0, 0, nil, True);
  {$ENDIF}

  GetDlgItemText(hGraphiqueProc, 102, PropositionName, SizeOf(PropositionName));
  if (StrLen(PropositionName) > 0) and FileExist(PropositionName) then
  begin
    pdi := PDIBINFO(SendMessage(hGraphiqueProc, WM_USER + 1006, 0, 0));
    if pdi^.fCanDecompress then
    begin
      MessageBox(GetActiveWindow, 'Cette image est compressée...', 'DrawDib', MB_OK);
    end
    else
    begin
      StrCopy(PathFichier, szImageEditor);
      StrCat(PathFichier, ' ');
      StrCat(PathFichier, PropositionName);
      if hInstPBrush = 0 then
      begin
        Exec(hInstPBrush, hWndPBrush, hMenuPBrush, nil, PathFichier, nil);
      end
      else
      begin
        SetActiveWindow(hWndPBrush);
        if hWndPBrush = GetActiveWindow then
        begin
          PostMessage(hWndPBrush, WM_CLOSE, word(0), MakeLong(word(0), word(0)));
        end;
        Exec(hInstPBrush, hWndPBrush, hMenuPBrush, nil, PathFichier, nil);
      end;
      EnableMenuItem(hMenuPBrush, 1000, MF_DISABLED + MF_GRAYED);
      EnableMenuItem(hMenuPBrush, 12, MF_DISABLED + MF_GRAYED);
      EnableMenuItem(hMenuPBrush, 14, MF_DISABLED + MF_GRAYED);
      ItWasBitmap := True;
      WaitEnd(hWndPBrush);
    end;
  end;
{  PostMessage(hWndPBrush,WM_COMMAND,WORD(13),MakeLong(WORD(0),WORD(0)));
  PostMessage(hWndPBrush,WM_CLOSE,WORD(0),MakeLong(WORD(0),WORD(0)));}
end;

{********************************************************}
procedure EditerVideo(Dialog: HWnd);
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 128, 0, 0, 0, nil, True);
  {$ENDIF}

  GetDlgItemText(hGraphiqueProc, 102, PropositionName, SizeOf(PropositionName));
  if (StrLen(PropositionName) > 0) and FileExist(PropositionName) then
  begin
    { On modifie le fichier mmTools.ini }
    if StrPos(StrUpper(szVideoEditor), 'VIDCAP.EXE') <> nil then
    begin
      if WritePrivateProfileString('VidCap', 'capfile', PropositionName,
        'MMTOOLS.INI') = False then
      begin
        MessageBox(Window, mmLoadString(hInstRes, ERR_OPENFILE),
          'MMTOOLS.INI', MB_OK or MB_ICONSTOP);
        Exit;
      end;
      StrCopy(PathFichier, szVideoEditor);
    end
    else
    begin
      StrCopy(PathFichier, szVideoEditor);
      StrCat(PathFichier, ' ');
      StrCat(PathFichier, PropositionName);
    end;
    if hInstVidCap = 0 then
    begin
      Exec(hInstVidCap, hWndVidCap, hMenuVidCap, nil, PathFichier, nil);
    end
    else
    begin
      SetActiveWindow(hWndVidCap);
      if hWndVidCap = GetActiveWindow then
      begin
        PostMessage(hWndVidCap, WM_CLOSE, word(0), MakeLong(word(0), word(0)));
      end;
      Exec(hInstVidCap, hWndVidCap, hMenuVidCap, nil, PathFichier, nil);
    end;
    ItWasVideo := True;
    WaitEnd(hWndVidCap);
  end;
end;

procedure EditerTexte(Dialog: HWnd);
var
  rc: TRECT;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 129, 0, 0, 0, nil, True);
  {$ENDIF}

  GetDlgItemText(hTexteProc, 102, PropositionName, SizeOf(PropositionName));
  if (PropositionName[0] <> #0) and FileExist(PropositionName) then
  begin

    if StrPos(StrUpper(PropositionName), 'RTF') <> nil then
    begin
      {####}
      { créer le document à la taille de la fenêtre }
      GetClientRect(GetDlgItem(hTexteProc, 101), rc);
      {InflateRect(rc, -8, -8);}
      RtfSetPageInfo(PropositionName,
        PixelsToTwips(rc.right + 6, 0),
        PixelsToTwips(rc.bottom + 6, 1),
        0,
        0,
        0,
        0);
    end;
    StrCopy(PathFichier, szTextEditor);
    StrCat(PathFichier, ' ');
    StrCat(PathFichier, PropositionName);
    if hInstNotePad = 0 then
    begin
      Exec(hInstNotePad, hWndNotePad, hMenuNotePad, nil, PathFichier, nil);
    end
    else
    begin
      SetActiveWindow(hWndNotePad);
      if hWndNotePad = GetActiveWindow then
      begin
        PostMessage(hWndNotePad, WM_CLOSE, word(0), MakeLong(word(0), word(0)));
      end;
      Exec(hInstNotePad, hWndNotePad, hMenuNotePad, nil, PathFichier, nil);
    end;
    SendMessage(GetWindow(hWndNotePad, GW_CHILD), WM_SETFONT,
      SendDlgItemMessage(hTexteProc, 101, WM_GETFONT, 0, 0), MAKELONG(word(True), 0));
    EnableMenuItem(hMenuNotePad, 1000, MF_DISABLED + MF_GRAYED);
    EnableMenuItem(hMenuNotePad, 12, MF_DISABLED + MF_GRAYED);
    EnableMenuItem(hMenuNotePad, 14, MF_DISABLED + MF_GRAYED);
    ItWasTexte := True;
    WaitEnd(hWndNotePad);
  end
  else
  begin
    MessageBeep(MB_ICONEXCLAMATION);
  end;
{  PostMessage(hWndNotePad,WM_COMMAND,WORD(13),MakeLong(WORD(0),WORD(0)));
  PostMessage(hWndNotePad,WM_CLOSE,WORD(0),MakeLong(WORD(0),WORD(0)));}
end;

function PrendreImage(Dialog: HWnd): Bool;
var
  pszFile: PChar;
const
  szBanque: szLongName = #0;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 130, 0, 0, 0, nil, True);
  {$ENDIF}

  PrendreImage := False;
  if szBanque[0] = #0 then
    StrCopy(szBanque, PathImages);
  if szBanque[StrLen(szBanque) - 1] = '\' then
    StrCat(szBanque, '.');
  SetCurrentDirectory(szBanque);
  pszFile := GetFileName(mmLoadString(hInstRes, STR_BMP), PChar(@szImageExt[1]));
  if pszFile <> nil then
  begin
    StrCopy(PropositionName, pszFile);
    StrDispose(pszFile);
  end
  else
  begin
    StrCopy(PropositionName, '');
  end;
  GetCurrentDirectory(SizeOf(szBanque), szBanque);
  if StrLen(PropositionName) > 0 then
  begin
    SetDlgItemText(hGraphiqueProc, 102, PropositionName);
    PrendreImage := True;
  end;
end;

function PrendreVideo(Dialog: HWnd): Bool;
var
  pszFile: PChar;
const
  szBanque: szLongName = #0;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 131, 0, 0, 0, nil, True);
  {$ENDIF}

  PrendreVideo := False;
  if szBanque[0] = #0 then
    StrCopy(szBanque, PathImages);
  if szBanque[StrLen(szBanque) - 1] = '\' then
    StrCat(szBanque, '.');
  SetCurrentDirectory(szBanque);
  pszFile := GetFileName(mmLoadString(hInstRes, STR_AVI), PChar(@szVideoExt[1]));
  if pszFile <> nil then
  begin
    StrCopy(PropositionName, pszFile);
    StrDispose(pszFile);
  end
  else
  begin
    StrCopy(PropositionName, '');
  end;
  GetCurrentDirectory(SizeOf(szBanque), szBanque);
  if StrLen(PropositionName) > 0 then
  begin
    SetDlgItemText(hGraphiqueProc, 102, PropositionName);
    PrendreVideo := True;
  end;
end;

function PrendreTexte(Dialog: HWnd): Bool;
var
  pszFile: PChar;
const
  szBanque: szLongName = #0;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 132, 0, 0, 0, nil, True);
  {$ENDIF}

  PrendreTexte := False;
  if szBanque[0] = #0 then
    StrCopy(szBanque, PathTextes);
  if szBanque[StrLen(szBanque) - 1] = '\' then
    StrCat(szBanque, '.');
  SetCurrentDirectory(szBanque);
  pszFile := GetFileName(mmLoadString(hInstRes, STR_TXT), PChar(@szTextExt[1]));
  if pszFile <> nil then
  begin
    StrCopy(PropositionName, pszFile);
    StrDispose(pszFile);
  end
  else
  begin
    StrCopy(PropositionName, '');
  end;
  GetCurrentDirectory(SizeOf(szBanque), szBanque);
  if StrLen(PropositionName) > 0 then
  begin
    SetDlgItemText(HTexteProc, 102, PropositionName);
    PrendreTexte := True;
  end;
end;

function PrendreSon(Dialog: HWnd): Bool;
var
  pszFile: PChar;
const
  szBanque: szLongName = #0;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 133, 0, 0, 0, nil, True);
  {$ENDIF}

  PrendreSon := False;
  if szBanque[0] = #0 then
    StrCopy(szBanque, PathSons);
  if szBanque[StrLen(szBanque) - 1] = '\' then
    StrCat(szBanque, '.');
  SetCurrentDirectory(szBanque);
  pszFile := GetFileName(mmLoadString(hInstRes, STR_WAV), 'wav');
  if pszFile <> nil then
  begin
    StrCopy(PropositionName, pszFile);
    StrDispose(pszFile);
  end
  else
  begin
    StrCopy(PropositionName, '');
  end;
  GetCurrentDirectory(SizeOf(szBanque), szBanque);
  if StrLen(PropositionName) > 0 then
  begin
    SetDlgItemText(HSonProc, 102, PropositionName);
    PrendreSon := True;
  end;
end;

function MailToProc(Dialog: HWnd; Message, WParam: DWord;
  LParam: longint): Bool; stdcall;

var
  szCommand: array[0..255] of char;
  szDir: array[0..255] of char;
  szText: array[0..255] of char;
  hInst, hWin, hMenu: THANDLE;

const
  pMail: PMailTo = nil;

begin
  MailToProc := True;
  case Message of
    wm_InitDialog:
    begin

      if lParam = 0 then
        exit;
      pMail := PMailTo(lParam);
      SetDlgItemText(Dialog, 101, pMail^.szTo);
      SetDlgItemText(Dialog, 102, pMail^.szCc);
      SetDlgItemText(Dialog, 103, pMail^.szCci);
      SetDlgItemText(Dialog, 104, pMail^.szSubject);
      SetDlgItemText(Dialog, 105, pMail^.szText);
      SetDlgItemText(Dialog, 106, pMail^.szAttach);
      if pMail^.szAttach[0] <> #0 then
      begin
        CheckDlgButton(Dialog, 107, 1);
      end;
      SetFocus(GetDlgItem(Dialog, 105));
      CenterDialog(Dialog);
      ShowWindow(Dialog, SW_SHOW);
      BringWindowToTop(Dialog);
    end;

    wm_command:
    begin
      case LoWord(wParam) of

        6021:
        begin
{<filename>    : file with the message body ('-' for console input, end with ^Z)
-t <recipient>: recipient list (comma separated)
-s <subj>     : subject line
-f <sender>   : overrides the default sender address (must be known to server)
-i <addr>     : a 'From:' address, not necessarily known to the SMTP server.
-c <recipient>: carbon copy recipient list (comma separated)
-b <recipient>: blind carbon copy recipient list (comma separated)
-o <organization>: Organization field
-h            : displays this help.
-mime         : MIME Quoted-Printable Content-Transfer-Encoding.
-base64       : MIME base64 Content-Transfer-Encoding.
-q            : supresses *all* output.
-p <profile>  : send with SMTP server, user and port defined in <profile>.
-server <addr>: overrides the default SMTP server to be used.
-port <port>  : port to be used on the server, defaults to SMTP (25)
-try <n times>: how many time blat should try to send. from '1' to 'INFINITE'
-attach <file>: attach binary file to message (may be repeated)}
          { Send Mail }

          GetDlgItemText(Dialog, 101, pMail^.szTo, SizeOf(pMail^.szTo));
          GetDlgItemText(Dialog, 102, pMail^.szCc, SizeOf(pMail^.szCc));
          GetDlgItemText(Dialog, 103, pMail^.szCci, SizeOf(pMail^.szCci));
          GetDlgItemText(Dialog, 104, pMail^.szSubject, SizeOf(pMail^.szSubject));
          StrCopy(szText, PathProf);
          StrCat(szText, 'temp.txt');
          GetWindowTextToFile(GetDlgItem(Dialog, 105), szText);
          if IsDlgButtonChecked(Dialog, 107) = 1 then
          begin
            GetDlgItemText(Dialog, 106, pMail^.szAttach, SizeOf(pMail^.szAttach));
          end
          else
          begin
            pMail^.szAttach[0] := #0;
          end;

          StrCopy(szDir, PathLavac);
          StrCat(szDir, 'exe');
          StrCopy(szCommand, szDir);
          StrCat(szCommand, '\blat.exe ');
          StrCat(szCommand, szText);
          if pMail^.szTo[0] <> #0 then
          begin
            StrCat(szCommand, ' -t "');
            StrCat(szCommand, pMail^.szTo);
            StrCat(szCommand, '"');
          end;
          if pMail^.szCc[0] <> #0 then
          begin
            StrCat(szCommand, ' -c "');
            StrCat(szCommand, pMail^.szCc);
            StrCat(szCommand, '"');
          end;
          if pMail^.szCci[0] <> #0 then
          begin
            StrCat(szCommand, ' -b "');
            StrCat(szCommand, pMail^.szCci);
            StrCat(szCommand, '"');
          end;
          if pMail^.szSubject[0] <> #0 then
          begin
            StrCat(szCommand, ' -s "');
            StrCat(szCommand, pMail^.szSubject);
            StrCat(szCommand, '"');
          end;
          if pMail^.szAttach[0] <> #0 then
          begin
            StrCat(szCommand, ' -attach ');
            StrCat(szCommand, pMail^.szAttach);
          end;
          StrCat(szCommand, ' -server ');
          StrCat(szCommand, pMail^.szServer);
          wvsprintf(szText, ' -port %d', @(pMail^.nPort));
          StrCat(szCommand, szText);
          StrCat(szCommand, ' -f ');
          StrCat(szCommand, pMail^.szFrom);

          {Messagebox(0, szCommand, szDir, 0);}
          Exec(hInst, hWin, hMenu, 'open', szCommand, szDir);
          if hWin <> 0 then
            WaitEnd(hWin);
          EndDialog(Dialog, 1);

        end;

        idCancel:
        begin
          EndDialog(Dialog, 0);
        end;
      end;
    end;
  end;
  MailToProc := False;
end;

procedure MailTo(szServer: PChar; nPort: integer;
  szFrom, szTo, szCc, szCci, szSubject, szText, szAttach: PChar);
const
  MailTo: TMailTo = ();
begin
  StrCopy(MailTo.szServer, szServer);
  MailTo.nPort := nPort;
  StrCopy(MailTo.szFrom, szFrom);
  StrCopy(MailTo.szTo, szTo);
  StrCopy(MailTo.szCc, szCc);
  StrCopy(MailTo.szCci, szCci);
  StrCopy(MailTo.szSubject, szSubject);
  StrCopy(MailTo.szText, szText);
  StrCopy(MailTo.szAttach, szAttach);
  DialogBoxParam(hInstRes, 'MailTo', window, DLGPROC(@MailToProc), DWORD(@MailTo));
end;

procedure EnvoieImage(Dialog: HWnd);
var
  MessageName: szLongName;
  nbSel: integer;
  PropositionName: szLongName;
  ListeEtudiantInt: array [1..48] of integer;
  i: integer;
  szServer: array[0..255] of char;
  nPort: integer;
  szFrom: array[0..255] of char;
  szTo: array[0..4096] of char;
  szSubject: array[0..255] of char;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 134, 0, 0, 0, nil, True);
  {$ENDIF}

  GetDlgItemText(HGraphiqueProc, 102, PropositionName, SizeOf(PropositionName));
  nbSel := SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_GETSELCOUNT, 0, 0);
  SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_GETSELITEMS, nbSel, DWORD(@ListeEtudiantInt));
  if bFTP then
  begin
    szTo[0] := #0;
    for i := 1 to nbSel do
    begin
      SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_GETTEXT,
        ListeEtudiantInt[i], DWORD(@szFrom));
      if GetPrivateProfileString(szFrom, 'EMAIL', '', @szTo[StrLen(szTo)],
        255, gszIni) > 0 then
      begin
        StrCat(szTo, ',');
      end;
    end;
    if szTo[0] <> #0 then
    begin
      if szTo[StrLen(szTo) - 1] = ',' then
        szTo[StrLen(szTo) - 1] := #0;
      GetPrivateProfileString('SMTP', 'SERVER', '', @szServer, 255, gszIni);
      nPort := GetPrivateProfileInt('SMTP', 'PORT', 25, gszIni);
      StrCopy(szSubject, 'LAVAC à distance : ');
      GetPrivateProfileString('SMTP', 'EMAIL', '', @szFrom, 255, gszIni);
      MailTo(szServer, nPort, szFrom, szTo, '', '', szSubject, '', PropositionName);
    end;
  end
  else
  begin
    for i := 1 to nbSel do
    begin
      MessageBmpFileName(MessageName, ListeEtudiantInt[i] + 1);
      CopyFile(PropositionName, MessageName);
    end;
  end;
end;

procedure EnvoieTexte(Dialog: HWnd);
var
  MessageName: szLongName;
  nbSel: integer;
  PropositionName: szLongName;
  ListeEtudiantInt: array [1..20] of integer;
  i: integer;
  szServer: array[0..255] of char;
  nPort: integer;
  szFrom: array[0..255] of char;
  szTo: array[0..4096] of char;
  szSubject: array[0..255] of char;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 135, 0, 0, 0, nil, True);
  {$ENDIF}

  GetDlgItemText(hTexteProc, 102, PropositionName, SizeOf(PropositionName));
  nbSel := SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_GETSELCOUNT, 0, 0);
  SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_GETSELITEMS, nbSel, DWORD(@ListeEtudiantInt));
  if bFTP then
  begin
    szTo[0] := #0;
    for i := 1 to nbSel do
    begin
      SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_GETTEXT,
        ListeEtudiantInt[i], DWORD(@szFrom));
      if GetPrivateProfileString(szFrom, 'EMAIL', '', @szTo[StrLen(szTo)],
        255, gszIni) > 0 then
      begin
        StrCat(szTo, ',');
      end;
    end;
    if szTo[0] <> #0 then
    begin
      if szTo[StrLen(szTo) - 1] = ',' then
        szTo[StrLen(szTo) - 1] := #0;
      GetPrivateProfileString('SMTP', 'SERVER', '', @szServer, 255, gszIni);
      nPort := GetPrivateProfileInt('SMTP', 'PORT', 25, gszIni);
      GetPrivateProfileString('SMTP', 'EMAIL', '', @szFrom, 255, gszIni);
      StrCopy(szSubject, 'LAVAC à distance : ');
      MailTo(szServer, nPort, szFrom, szTo, '', '', szSubject, '', PropositionName);
    end;
  end
  else
  begin
    for i := 1 to nbSel do
    begin
      if StrPos(StrUpper(PropositionName), '.RTF') <> nil then
      begin
        MessageRtfFileName(MessageName, ListeEtudiantInt[i] + 1);
      end
      else
      begin
        MessageTxtFileName(MessageName, ListeEtudiantInt[i] + 1);
      end;
      CopyFile(PropositionName, MessageName);
    end;
  end;
end;

procedure EnvoieSon(Dialog: HWnd);
var
  MessageName: szLongName;
  nbSel: integer;
  PropositionName: szLongName;
  ListeEtudiantInt: array [1..20] of integer;
  i: integer;
  szServer: array[0..255] of char;
  nPort: integer;
  szFrom: array[0..255] of char;
  szTo: array[0..4096] of char;
  szSubject: array[0..255] of char;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 136, 0, 0, 0, nil, True);
  {$ENDIF}

  GetDlgItemText(HSonProc, 102, PropositionName, SizeOf(PropositionName));
  nbSel := SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_GETSELCOUNT, 0, 0);
  SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_GETSELITEMS, nbSel, DWORD(@ListeEtudiantInt));
  if bFTP then
  begin
    szTo[0] := #0;
    for i := 1 to nbSel do
    begin
      SendDlgItemMessage(hLeconProc, idl_ListeQ, LB_GETTEXT,
        ListeEtudiantInt[i], DWORD(@szFrom));
      if GetPrivateProfileString(szFrom, 'EMAIL', '', @szTo[StrLen(szTo)],
        255, gszIni) > 0 then
      begin
        StrCat(szTo, ',');
      end;
    end;
    if szTo[0] <> #0 then
    begin
      if szTo[StrLen(szTo) - 1] = ',' then
        szTo[StrLen(szTo) - 1] := #0;
      GetPrivateProfileString('SMTP', 'SERVER', '', @szServer, 255, gszIni);
      nPort := GetPrivateProfileInt('SMTP', 'PORT', 25, gszIni);
      GetPrivateProfileString('SMTP', 'EMAIL', '', @szFrom, 255, gszIni);
      StrCopy(szSubject, 'LAVAC à distance : ');
      MailTo(szServer, nPort, szFrom, szTo, '', '', szSubject, '', PropositionName);
    end;
  end
  else
  begin
    for i := 1 to nbSel do
    begin
      MessageWavFileName(MessageName, ListeEtudiantInt[i] + 1);
      CopyFile(PropositionName, MessageName);
    end;
  end;
end;

procedure FtpResetList(hDialog: HWND; ID: word);
var
  pFileInfo: PSearchRec;
  lRet: longint;
begin
  while SendDlgItemMessage(hDialog, ID, LB_GETCOUNT, 0, 0) > 0 do
  begin
    pFileInfo := PSearchRec(SendDlgItemMessage(hDialog, ID, LB_GETITEMDATA, 0, 0));
    if (pFileInfo = PSearchRec(LB_ERR)) then
      pFileInfo := nil;
    if (pFileInfo <> nil) then
    begin
      SendDlgItemMessage(hDialog, ID, LB_SETITEMDATA, 0, 0);
      Dispose(pFileInfo);
    end;
    SendDlgItemMessage(hDialog, ID, LB_DELETESTRING, 0, 0);
  end;
end;

procedure FtpGetLocalList(hDialog: HWND; ID: word;
  szRootDir, szStudent, szLesson: PChar);
var
  szLocalDir: array[0..255] of char;
  FileInfo: TSearchRec;
  pFileInfo: PSearchRec;
  lRet: longint;

begin

  FtpResetList(hDialog, ID);

  StrCopy(szLocalDir, szRootDir);
  if szLocalDir[StrLen(szLocalDir) - 1] <> '\' then
    StrCat(szLocalDir, '\');
  StrCat(szLocalDir, szStudent);
  if szLocalDir[StrLen(szLocalDir) - 1] <> '\' then
    StrCat(szLocalDir, '\');
  StrCat(szLocalDir, szLesson);
  if szLocalDir[StrLen(szLocalDir) - 1] <> '\' then
    StrCat(szLocalDir, '\');
  StrCat(szLocalDir, '*.*');
  DosError := FindFirst(szLocalDir, faArchive, FileInfo);
  while DosError = 0 do
  begin
    pFileInfo := new(PSearchRec);
    if pFileInfo <> nil then
    begin
      pFileInfo^ := FileInfo;
      lRet := SendDlgItemMessage(hDialog, ID, LB_ADDSTRING, 0, longint(@pFileInfo^.Name));
      if lRet > LB_ERR then
      begin
        SendDlgItemMessage(hDialog, ID, LB_SETITEMDATA, word(lRet), longint(pFileInfo));
      end
      else
      begin
        Dispose(pFileInfo);
      end;
    end;
    DosError := FindNext(FileInfo);
  end;
  FindClose(FileInfo);
end;

procedure FtpGetRemoteList(hDialog: HWND; ID: word;
  szServer, szUser, szPassword, szRootDir, szStudent, szLesson: PChar);

var
  szListFile: array[0..255] of char;
  szScriptFile: array[0..255] of char;
  fList: Text;
  fScript: Text;
  szLine: array[0..255] of char;
  szFtpPath: array[0..62] of char;
  hInst, hWin, hMenu: THANDLE;
  pFileInfo: PSearchRec;
  dt: DateTime;
  code: integer;
  lRet: longint;

begin

  FtpResetList(hDialog, ID);

  StrCopy(szListFile, PathFloppy);
  StrCat(szListFile, 'ftplist.txt');
  {$i-}
  Assign(fList, szListFile);
  erase(fList);
  {$i+}
  InOutRes := 0;

  StrCopy(szScriptFile, PathFloppy);
  StrCat(szScriptFile, 'ftp.scr');
  Assign(fScript, szScriptFile);
  rewrite(fScript);

  StrCopy(szLine, 'open ');
  StrCat(szLine, szServer);
  writeln(fScript, szLine);

  StrCopy(szLine, szUser);
  writeln(fScript, szLine);

  StrCopy(szLine, szPassword);
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szRootDir);
  writeln(fScript, szLine);

  StrCopy(szLine, 'mkdir ');
  StrCat(szLine, szStudent);
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szStudent);
  writeln(fScript, szLine);

  StrCopy(szLine, 'mkdir ');
  StrCat(szLine, szLesson);
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szLesson);
  writeln(fScript, szLine);

  StrCopy(szLine, 'dir *.* ftplist.txt');
  writeln(fScript, szLine);

  StrCopy(szLine, 'bye');
  writeln(fScript, szLine);

  Close(fScript);

  GetWindowsDirectory(szFtpPath, SizeOf(szFtpPath));
  StrCat(szFtpPath, '\command.com /cftp.exe -s:ftp.scr');
  Exec(hInst, hWin, hMenu, 'open', szFtpPath, PathFloppy);
  if hWin <> 0 then
    WaitEnd(hWin);

  {$i-}
  StrCopy(szListFile, PathFloppy);
  StrCat(szListFile, 'ftplist.txt');
  Assign(fList, szListFile);
  reset(fList);
  while not EOF(fList) do
  begin
    ReadLn(fList, szLine);
    pFileInfo := new(PSearchRec);
    if pFileInfo <> nil then
    begin
      szLine[FTPSIZE - 1] := #0;
      szLine[FTPHOUR - 1] := #0;
      szLine[FTPMIN - 1] := #0;
      szLine[FTPMIN + 2] := #0;
      szLine[FTPFILENAME - 1] := #0;
      Val(PChar(@szLine[FTPSIZE]), pFileInfo^.Size, code);
      Val(PChar(@szLine[FTPHOUR]), dt.Hour, code);
      Val(PChar(@szLine[FTPMIN]), dt.Min, code);
      pFileInfo^.Time := 0;
      PackTime(dt, pFileInfo^.Time);
      UnpackTime(pFileInfo^.Time, dt);
      {WriteLn(dt.Hour, ':', dt.min);}
      StrCopy(PChar(pFileInfo^.Name), PChar(@szLine[FTPFILENAME]));
      lRet := SendDlgItemMessage(hDialog, ID, LB_ADDSTRING, 0, longint(@pFileInfo^.Name));
      if lRet > LB_ERR then
      begin
        SendDlgItemMessage(hDialog, ID, LB_SETITEMDATA, word(lRet), longint(pFileInfo));
      end
      else
      begin
        Dispose(pFileInfo);
      end;
    end;
  end;
  Close(fList);
  {$i+}
  InOutRes := 0;

end;

procedure FtpUpdateRemote(hDialog: HWND; IDLocal, IDRemote: word;
  szServer, szUser, szPassword, szRootDir, szLocalDir, szStudent,
  szLesson: PChar);

var
  szFile: array[0..255] of char;
  szScriptFile: array[0..255] of char;
  fList: Text;
  fScript: Text;
  szLine: array[0..255] of char;
  szFtpPath: array[0..62] of char;
  hInst, hWin, hMenu: THANDLE;
  pLocalFileInfo: PSearchRec;
  pRemoteFileInfo: PSearchRec;
  nLocalItem, nRemoteItem: integer;
  lFind, lCount, lRet: longint;
  dtLocal, dtRemote: DateTime;

begin

  StrCopy(szScriptFile, PathFloppy);
  StrCat(szScriptFile, 'ftp.scr');
  Assign(fScript, szScriptFile);
  rewrite(fScript);

  StrCopy(szLine, 'open ');
  StrCat(szLine, szServer);
  writeln(fScript, szLine);

  StrCopy(szLine, szUser);
  writeln(fScript, szLine);

  StrCopy(szLine, szPassword);
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szRootDir);
  writeln(fScript, szLine);

  StrCopy(szLine, 'mkdir ');
  StrCat(szLine, szStudent);
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szStudent);
  writeln(fScript, szLine);

  StrCopy(szLine, 'mkdir ');
  StrCat(szLine, szLesson);
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szLesson);
  writeln(fScript, szLine);
  StrCopy(szLine, 'lcd ');
  StrCat(szLine, szLocalDir);
  if szLine[StrLen(szLine) - 1] <> '\' then
    StrCat(szLine, '\');
  StrCat(szLine, szStudent);
  if szLine[StrLen(szLine) - 1] <> '\' then
    StrCat(szLine, '\');
  StrCat(szLine, szLesson);
  writeln(fScript, szLine);

  StrCopy(szLine, 'binary');
  writeln(fScript, szLine);

  StrCopy(szLine, 'prompt');
  writeln(fScript, szLine);

  lCount := SendDlgItemMessage(hDialog, IDLocal, LB_GETCOUNT, 0, 0);
  for nLocalItem := 0 to lCount - 1 do
  begin
    pLocalFileInfo := PSearchRec(SendDlgItemMessage(hDialog, IDLocal,
      LB_GETITEMDATA, nLocalItem, 0));
    if pLocalFileInfo = PSearchRec(LB_ERR) then
      pLocalFileInfo := nil;
    if pLocalFileInfo <> nil then
    begin
      lFind := SendDlgItemMessage(hDialog, IDRemote, LB_FINDSTRINGEXACT,
        word(-1), longint(@pLocalFileInfo^.Name));
      if lFind <> LB_ERR then
      begin
        pRemoteFileInfo := PSearchRec(SendDlgItemMessage(hDialog, IDRemote,
          LB_GETITEMDATA, word(lFind), 0));
        if pRemoteFileInfo = PSearchRec(LB_ERR) then
          pRemoteFileInfo := nil;
        if pRemoteFileInfo <> nil then
        begin
          UnpackTime(pRemoteFileInfo^.Time, dtRemote);
          UnpackTime(pLocalFileInfo^.Time, dtLocal);
          if (pRemoteFileInfo^.Size <> pLocalFileInfo^.Size) or
            {(pRemoteFileInfo^.Time <> pLocalFileInfo^.Time)}
            (dtLocal.Hour <> dtRemote.Hour) or (dtLocal.Min <> dtRemote.Min) then
          begin
            { Remote file need to be updated }
            lFind := LB_ERR;
          end;
        end;
      end;

      { update remote file }
      if lFind = LB_ERR then
      begin
        StrCopy(szLine, 'put ');
        StrCat(szLine, PChar(pLocalFileInfo^.Name));
        writeln(fScript, szLine);
      end;

    end;
  end;

  StrCopy(szLine, 'bye');
  writeln(fScript, szLine);

  Close(fScript);

  GetWindowsDirectory(szFtpPath, SizeOf(szFtpPath));
  StrCat(szFtpPath, '\command.com /cftp.exe -s:ftp.scr');
  Exec(hInst, hWin, hMenu, 'open', szFtpPath, PathFloppy);
  if hWin <> 0 then
    WaitEnd(hWin);

end;

procedure FtpUpdateLocal(hDialog: HWND; IDLocal, IDRemote: word;
  szServer, szUser, szPassword, szRootDir, szLocalDir, szStudent,
  szLesson: PChar);

var
  szFile: array[0..255] of char;
  szScriptFile: array[0..255] of char;
  fList: Text;
  fScript: Text;
  szLine: array[0..255] of char;
  szFtpPath: array[0..62] of char;
  hInst, hWin, hMenu: THANDLE;
  pLocalFileInfo: PSearchRec;
  pRemoteFileInfo: PSearchRec;
  nLocalItem, nRemoteItem: integer;
  lFind, lCount, lRet: longint;
  dtLocal, dtRemote: DateTime;

begin

  StrCopy(szScriptFile, PathFloppy);
  StrCat(szScriptFile, 'ftp.scr');
  Assign(fScript, szScriptFile);
  rewrite(fScript);

  StrCopy(szLine, 'open ');
  StrCat(szLine, szServer);
  writeln(fScript, szLine);

  StrCopy(szLine, szUser);
  writeln(fScript, szLine);

  StrCopy(szLine, szPassword);
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szRootDir);
  writeln(fScript, szLine);

  StrCopy(szLine, 'mkdir ');
  StrCat(szLine, szStudent);
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szStudent);
  writeln(fScript, szLine);

  StrCopy(szLine, 'mkdir ');
  StrCat(szLine, szLesson);
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szLesson);
  writeln(fScript, szLine);

  StrCopy(szLine, 'lcd ');
  StrCat(szLine, szLocalDir);
  if szLine[StrLen(szLine) - 1] <> '\' then
    StrCat(szLine, '\');
  StrCat(szLine, szStudent);
  if szLine[StrLen(szLine) - 1] <> '\' then
    StrCat(szLine, '\');
  StrCat(szLine, szLesson);
  writeln(fScript, szLine);

  StrCopy(szLine, 'binary');
  writeln(fScript, szLine);

  StrCopy(szLine, 'prompt');
  writeln(fScript, szLine);

  lCount := SendDlgItemMessage(hDialog, IDRemote, LB_GETCOUNT, 0, 0);
  for nRemoteItem := 0 to lCount - 1 do
  begin
    pRemoteFileInfo := PSearchRec(SendDlgItemMessage(hDialog, IDRemote,
      LB_GETITEMDATA, nRemoteItem, 0));
    if pRemoteFileInfo = PSearchRec(LB_ERR) then
      pRemoteFileInfo := nil;
    if pRemoteFileInfo <> nil then
    begin
      lFind := SendDlgItemMessage(hDialog, IDLocal, LB_FINDSTRINGEXACT,
        word(-1), longint(@pRemoteFileInfo^.Name));
      if lFind <> LB_ERR then
      begin
        pLocalFileInfo := PSearchRec(SendDlgItemMessage(hDialog, IDLocal,
          LB_GETITEMDATA, word(lFind), 0));
        if pLocalFileInfo = PSearchRec(LB_ERR) then
          pLocalFileInfo := nil;
        if pLocalFileInfo <> nil then
        begin
          UnpackTime(pLocalFileInfo^.Time, dtLocal);
          UnpackTime(pRemoteFileInfo^.Time, dtRemote);
          if (pRemoteFileInfo^.Size <> pLocalFileInfo^.Size) or
            {(pRemoteFileInfo^.Time <> pLocalFileInfo^.Time)}
            (dtLocal.Hour <> dtRemote.Hour) or (dtLocal.Min <> dtRemote.Min) then
          begin
            { Local file need to be updated }
            lFind := LB_ERR;
          end;
        end;
      end;

      { update local file }
      if lFind = LB_ERR then
      begin
        StrCopy(szLine, 'get ');
        StrCat(szLine, PChar(pRemoteFileInfo^.Name));
        writeln(fScript, szLine);
      end;
    end;
  end;

  StrCopy(szLine, 'bye');
  writeln(fScript, szLine);

  Close(fScript);

  GetWindowsDirectory(szFtpPath, SizeOf(szFtpPath));
  StrCat(szFtpPath, '\command.com /cftp.exe -s:ftp.scr');
  Exec(hInst, hWin, hMenu, 'open', szFtpPath, PathFloppy);
  if hWin <> 0 then
    WaitEnd(hWin);

end;

procedure FtpSyncLocal(hDialog: HWND; IDLocal, IDRemote: word;
  szServer, szUser, szPassword, szRootDir, szLocalDir, szStudent,
  szLesson: PChar);

var
  szFile: array[0..255] of char;
  pLocalFileInfo: PSearchRec;
  pRemoteFileInfo: PSearchRec;
  nLocalItem, nRemoteItem: integer;
  lFind, lCount, lRet: longint;
  f: file;
  dtLocal, dtRemote: DateTime;

begin

  lCount := SendDlgItemMessage(hDialog, IDLocal, LB_GETCOUNT, 0, 0);
  for nLocalItem := 0 to lCount do
  begin
    pLocalFileInfo := PSearchRec(SendDlgItemMessage(hDialog, IDLocal,
      LB_GETITEMDATA, nLocalItem, 0));
    if pLocalFileInfo = PSearchRec(LB_ERR) then
      pLocalFileInfo := nil;
    if pLocalFileInfo <> nil then
    begin
      lFind := SendDlgItemMessage(hDialog, IDRemote, LB_FINDSTRINGEXACT,
        word(-1), longint(@pLocalFileInfo^.Name));
      if lFind <> LB_ERR then
      begin
        pRemoteFileInfo := PSearchRec(SendDlgItemMessage(hDialog, IDRemote,
          LB_GETITEMDATA, word(lFind), 0));
        if pRemoteFileInfo = PSearchRec(LB_ERR) then
          pLocalFileInfo := nil;
        if pRemoteFileInfo <> nil then
        begin
          UnpackTime(pRemoteFileInfo^.Time, dtRemote);
          UnpackTime(pLocalFileInfo^.Time, dtLocal);
          if (pRemoteFileInfo^.Size = pLocalFileInfo^.Size) and
            {(pRemoteFileInfo^.Time <> pLocalFileInfo^.Time)}
            ((dtLocal.Hour <> dtRemote.Hour) or (dtLocal.Min <> dtRemote.Min)) then
          begin
            { synchronize local file }
            dtLocal.Hour := dtRemote.Hour;
            dtLocal.Min := dtRemote.Min;
            PackTime(dtLocal, pLocalFileInfo^.Time);
            StrCopy(szFile, szLocalDir);
            if szFile[StrLen(szFile) - 1] <> '\' then
              StrCat(szFile, '\');
            StrCat(szFile, szStudent);
            if szFile[StrLen(szFile) - 1] <> '\' then
              StrCat(szFile, '\');
            StrCat(szFile, szLesson);
            if szFile[StrLen(szFile) - 1] <> '\' then
              StrCat(szFile, '\');
            StrCat(szFile, PChar(pLocalFileInfo^.Name));
            {$i-}
            Assign(f, szFile);
            reset(f);
            SetFTime(f, pLocalFileInfo^.Time);
            Close(f);
            {$i+}
            InOutRes := 0;
          end;
        end;
      end;

    end;
  end;

end;

function FtpStudentProc(Dialog: HWnd; Message, WParam: DWord;
  LParam: longint): Bool; stdcall;

var
  szServer, szUser, szPassword, szRootDir, szLocalDir, szFtpPath,
  szStudent, szLesson: array[0..62] of char;
  szStudentName: array[0..255] of char;
  szLine: array[0..255] of char;
  szFile: array[0..255] of char;
  szLocalFile: array[0..255] of char;
  szScriptFile: array[0..255] of char;
  szListFile: array[0..255] of char;
  fScript: Text;
  fList: Text;
  f: file;
  hInst, hWin, hMenu: THANDLE;
  FileInfo: TSearchRec;
  FileInfoOrig: TSearchRec;
  lRemoteFileSize: longint;
  code: integer;
  dt: TDateTime;
  szTime: array[0..62] of char;

begin
  FtpStudentProc := True;
  case Message of
    wm_InitDialog:
    begin

      if lParam = 0 then
        exit;

      StrCopy(szStudentName, PChar(lParam));
      GetDosName(szStudent, PChar(lParam));
      {####}
      GetDosName(szLesson, tEtudiant.LessonName);

      CenterDialog(Dialog);
      ShowWindow(Dialog, SW_SHOW);
      FlashWindow(Dialog, True);
      BringWindowToTop(Dialog);

      EnableWindow(GetDlgItem(hBoutonsProc, 6006), False);
      SetDlgItemText(hBoutonsProc, 606, 'En cours...');

      GetPrivateProfileString('FTP', 'SERVER', '', szServer, SizeOf(szServer), gszIni);
      GetPrivateProfileString('FTP', 'USER', '', szUser, SizeOf(szServer), gszIni);
      GetPrivateProfileString('FTP', 'PASSWORD', '', szPassword, SizeOf(szServer), gszIni);
      GetPrivateProfileString('FTP', 'ROOTDIR', '', szRootDir, SizeOf(szServer), gszIni);

      StrCopy(szLocalDir, PathEleves);
      StrCopy(szLocalDir, PathFloppy);

      SetWindowText(Dialog, 'FTP : Chargement de la liste des fichiers locaux.');
      FtpGetLocalList(Dialog, 101, szLocalDir, szStudent, szLesson);
      SetWindowText(Dialog, 'FTP : Téléchargement de la liste des fichiers distants.');
      FtpGetRemoteList(Dialog, 102, szServer, szUser, szPassword,
        szRootDir, szStudent, szLesson);

      SetWindowText(Dialog,
        'FTP : Téléchargement des fichiers locaux sur le site distant.');
      FtpUpdateRemote(Dialog, 101, 102, szServer, szUser, szPassword,
        szRootDir, szLocalDir, szStudent, szLesson);
      SetWindowText(Dialog, 'FTP : Téléchargement de la liste des fichiers distants.');
      FtpGetRemoteList(Dialog, 102, szServer, szUser, szPassword,
        szRootDir, szStudent, szLesson);
      SetWindowText(Dialog,
        'FTP : Synchronistaion des fichiers locaux avec les fichiers distant.');
      FtpSyncLocal(Dialog, 101, 102, szServer, szUser, szPassword,
        szRootDir, szLocalDir, szStudent, szLesson);

      SetWindowText(Dialog,
        'FTP : Téléchargement des fichiers distants sur le site local.');
      FtpUpdateLocal(Dialog, 101, 102, szServer, szUser, szPassword,
        szRootDir, szLocalDir, szStudent, szLesson);
      SetWindowText(Dialog, 'FTP : Chargement de la liste des fichiers locaux.');
      FtpGetLocalList(Dialog, 101, szLocalDir, szStudent, szLesson);
      SetWindowText(Dialog,
        'FTP : Synchronistaion des fichiers locaux avec les fichiers distant.');
      FtpSyncLocal(Dialog, 101, 102, szServer, szUser, szPassword,
        szRootDir, szLocalDir, szStudent, szLesson);

      PostMessage(Dialog, WM_COMMAND, idCancel, 0);

    end;

    wm_command:
    begin
      case LoWord(wParam) of
        idOk:
        begin
          ShowWindow(Dialog, SW_SHOWMINIMIZED);
        end;

        idCancel:
        begin
              {$IFNDEF _E0}
          EnableWindow(GetDlgItem(hBoutonsProc, 6006), True);
          SetDlgItemText(hBoutonsProc, 606, 'Envoyer');
          FtpResetList(Dialog, 101);
          FtpResetList(Dialog, 102);
          DestroyWindow(Dialog);
              {$ENDIF}
        end;
      end;
    end;
  end;
  FtpStudentProc := False;
end;

procedure FtpPutAnswer(NoElev: longint);
var
  tEtudiant: TypeEtudiant;
begin
  GetEtudiantRec(NoElev, tEtudiant);
  CreateDialogParam(hInstRes, 'Ftp', window, DLGPROC(@FtpStudentProc),
    longint(@tEtudiant.Nom));
end;

function FtpDirProc(Dialog: HWnd; Message, WParam: DWord;
  LParam: longint): Bool; stdcall;
var
  tEtudiant: TypeEtudiant;
  szServer, szUser, szPassword, szRootDir, szFtpPath, szStudent: array[0..62] of
  char;
  szLine: array[0..255] of char;
  szFile: array[0..255] of char;
  szLesson: array[0..255] of char;
  szScriptFile: array[0..255] of char;
  szListFile: array[0..255] of char;
  fScript: Text;
  fList: Text;
  hInst, hWin, hMenu: THANDLE;
  lRet: longint;

begin
  FtpDirProc := True;
  case Message of
    wm_InitDialog:
    begin

      if lParam = 0 then
        exit;

      NoElev := lParam;

      GetEtudiantRec(NoElev, tEtudiant);
      StrCopy(szStudent, tEtudiant.Nom);
      GetDosName(szStudent, tEtudiant.Nom);

      CenterDialog(Dialog);
      ShowWindow(Dialog, SW_SHOW);
      BringWindowToTop(Dialog);

      GetPrivateProfileString(szStudent, 'SERVER', '', szServer, SizeOf(szServer), gszIni);
      GetPrivateProfileString(szStudent, 'USER', '', szUser, SizeOf(szServer), gszIni);
      GetPrivateProfileString(szStudent, 'PASSWORD', '', szPassword,
        SizeOf(szServer), gszIni);
      GetPrivateProfileString(szStudent, 'ROOTDIR', '', szRootDir,
        SizeOf(szServer), gszIni);

      SetWindowText(Dialog, '<Recherche des informations distantes>');

      StrCopy(szListFile, PathFloppy);
      StrCat(szListFile, 'ftplist.txt');
        {$i-}
      Assign(fList, szListFile);
      erase(fList);
        {$i+}
      InOutRes := 0;

      StrCopy(szScriptFile, PathFloppy);
      StrCat(szScriptFile, 'ftp.scr');
      Assign(fScript, szScriptFile);
      rewrite(fScript);

      StrCopy(szLine, 'open ');
      StrCat(szLine, szServer);
      writeln(fScript, szLine);

      StrCopy(szLine, szUser);
      writeln(fScript, szLine);

      StrCopy(szLine, szPassword);
      writeln(fScript, szLine);

      StrCopy(szLine, 'binary');
      writeln(fScript, szLine);

      StrCopy(szLine, 'cd ');
      StrCat(szLine, szRootDir);
      writeln(fScript, szLine);

      GetDosName(szStudent, szStudent);

      StrCopy(szLine, 'mkdir ');
      StrCat(szLine, szStudent);
      writeln(fScript, szLine);

      StrCopy(szLine, 'cd ');
      StrCat(szLine, szStudent);
      writeln(fScript, szLine);

      StrCopy(szLine, 'lcd ');
      StrCat(szLine, PathFloppy);
      if szLine[StrLen(szLine) - 1] <> '\' then
        StrCat(szLine, '\');
      StrCat(szLine, '.');
      writeln(fScript, szLine);

      StrCopy(szLine, 'dir . ftplist.txt');
      writeln(fScript, szLine);

      StrCopy(szLine, 'bye');
      writeln(fScript, szLine);

      Close(fScript);

      GetWindowsDirectory(szFtpPath, SizeOf(szFtpPath));
      StrCat(szFtpPath, '\command.com /cftp.exe -s:ftp.scr');
      Exec(hInst, hWin, hMenu, 'open', szFtpPath, PathFloppy);
      if hWin <> 0 then
        WaitEnd(hWin);

        {$i-}
      StrCopy(szListFile, PathFloppy);
      StrCat(szListFile, 'ftplist.txt');
      Assign(fList, szListFile);
      reset(fList);
        {$i+}
      if IOResult <> 0 then
      begin
        SetWindowText(Dialog, '<Erreur de connexion>');
        Close(fList);
        exit;
      end;
        {$i-}
      while not EOF(fList) do
      begin
        ReadLn(fList, szFile);
        if StrPos(szFile, '*.*') <> nil then
        begin
          SetWindowText(Dialog, '<Dossier étudiant vide>');
          Close(fList);
          exit;
        end;
        szFile[FTPSIZE - 1] := #0;
        szFile[FTPHOUR - 1] := #0;
        szFile[FTPMIN + 2] := #0;
        szFile[FTPFILENAME - 1] := #0;
        SendDlgItemMessage(Dialog, 101, LB_ADDSTRING, 0, DWORD(@szFile[FTPFILENAME]));
      end;
      Close(fList);
        {$i+}
      InOutRes := 0;

      GetEtudiantRec(NoElev, tEtudiant);
      SetWindowText(Dialog, tEtudiant.Nom);

    end;


    wm_command:
    begin
      case LoWord(wParam) of
        idOk:
        begin
          lRet := SendDlgItemMessage(Dialog, 101, LB_GETCURSEL, 0, 0);
          if lRet > LB_ERR then
          begin
            SendDlgItemMessage(Dialog, 101, LB_GETTEXT, integer(lRet), DWORD(@szLesson));
            FtpGetAnswer(Dialog, NoElev, szLesson);
            EndDialog(Dialog, 0);
          end;
        end;

        idCancel:
        begin
          EndDialog(Dialog, 0);
        end;
      end;
    end;
  end;
  FtpDirProc := False;

end;

procedure FtpGetAnswerDir(NoElev: longint);
var
  tEtudiant: TypeEtudiant;
begin
  GetEtudiantRec(NoElev, tEtudiant);
  DialogBoxParam(hInstRes, 'FtpDir', window, DLGPROC(@FtpDirProc), NoElev);
end;

procedure FtpGetAnswer(Dialog: HWND; NoElev: longint; szLesson: PChar);
var
  tEtudiant: TypeEtudiant;
  szServer, szUser, szPassword, szRootDir, szFtpPath, szStudent: array[0..62] of
  char;
  szLine: array[0..255] of char;
  szFile: array[0..255] of char;
  szLocalFile: array[0..255] of char;
  szScriptFile: array[0..255] of char;
  szListFile: array[0..255] of char;
  fScript: Text;
  fList: Text;
  f: file;
  fEtudiant: file of TypeEtudiant;
  hInst, hWin, hMenu: THANDLE;
  FileInfo: TSearchRec;
  FileInfoOrig: TSearchRec;
  lRemoteFileSize: longint;
  code: integer;
  dt: DateTime;
  szTime: array[0..62] of char;
  nbUpdate: integer;

begin

  GetEtudiantRec(NoElev, tEtudiant);
  StrCopy(szStudent, tEtudiant.Nom);

  GetPrivateProfileString(szStudent, 'SERVER', '', szServer, SizeOf(szServer), gszIni);
  GetPrivateProfileString(szStudent, 'USER', '', szUser, SizeOf(szServer), gszIni);
  GetPrivateProfileString(szStudent, 'PASSWORD', '', szPassword,
    SizeOf(szServer), gszIni);
  GetPrivateProfileString(szStudent, 'ROOTDIR', '', szRootDir, SizeOf(szServer), gszIni);

  SetWindowText(Dialog, '<Recherche des informations étudiant>');

  StrCopy(szListFile, PathFloppy);
  StrCat(szListFile, 'ftplist.txt');
  {$i-}
  Assign(fList, szListFile);
  erase(fList);
  {$i+}
  InOutRes := 0;

  StrCopy(szScriptFile, PathFloppy);
  StrCat(szScriptFile, 'ftp.scr');
  Assign(fScript, szScriptFile);
  rewrite(fScript);

  StrCopy(szLine, 'open ');
  StrCat(szLine, szServer);
  writeln(fScript, szLine);

  StrCopy(szLine, szUser);
  writeln(fScript, szLine);

  StrCopy(szLine, szPassword);
  writeln(fScript, szLine);

  StrCopy(szLine, 'binary');
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szRootDir);
  writeln(fScript, szLine);

  GetDosName(szStudent, szStudent);

  StrCopy(szLine, 'mkdir ');
  StrCat(szLine, szStudent);
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szStudent);
  writeln(fScript, szLine);

  StrCopy(szLine, 'mkdir ');
  StrCat(szLine, szLesson);
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szLesson);
  writeln(fScript, szLine);

  StrCopy(szLine, 'lcd ');
  StrCat(szLine, PathFloppy);
  if szLine[StrLen(szLine) - 1] <> '\' then
    StrCat(szLine, '\');
  StrCat(szLine, '.');
  writeln(fScript, szLine);

  StrCopy(szLine, 'dir *.* ftplist.txt');
  writeln(fScript, szLine);

  StrCopy(szLine, 'bye');
  writeln(fScript, szLine);

  Close(fScript);

  GetWindowsDirectory(szFtpPath, SizeOf(szFtpPath));
  StrCat(szFtpPath, '\command.com /cftp.exe -s:ftp.scr');
  Exec(hInst, hWin, hMenu, 'open', szFtpPath, PathFloppy);
  if hWin <> 0 then
    WaitEnd(hWin);

  SetWindowText(Dialog, '<Comparaison avec les informations locales>');

  nbUpdate := 0;

  StrCopy(szScriptFile, PathFloppy);
  StrCat(szScriptFile, 'ftp.scr');
  Assign(fScript, szScriptFile);
  rewrite(fScript);

  StrCopy(szLine, 'open ');
  StrCat(szLine, szServer);
  writeln(fScript, szLine);

  StrCopy(szLine, szUser);
  writeln(fScript, szLine);

  StrCopy(szLine, szPassword);
  writeln(fScript, szLine);

  StrCopy(szLine, 'binary');
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szRootDir);
  writeln(fScript, szLine);

  StrCopy(szLine, 'mkdir ');
  StrCat(szLine, szStudent);
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szStudent);
  writeln(fScript, szLine);

  StrCopy(szLine, 'mkdir ');
  StrCat(szLine, szLesson);
  writeln(fScript, szLine);

  StrCopy(szLine, 'cd ');
  StrCat(szLine, szLesson);
  writeln(fScript, szLine);

  GetDosName(szStudent, tEtudiant.Nom);

  StrCopy(szLocalFile, PathEleves);
  StrCat(szLocalFile, szStudent);
  StrCat(szLocalFile, '\');
  StrCat(szLocalFile, szLesson);
  CreerRep(szLocalFile);

  StrCopy(szLine, 'lcd ');
  StrCat(szLine, PathEleves);
  if szLine[StrLen(szLine) - 1] <> '\' then
    StrCat(szLine, '\');
  StrCat(szLine, szStudent);
  if szLine[StrLen(szLine) - 1] <> '\' then
    StrCat(szLine, '\');
  StrCat(szLine, szLesson);
  writeln(fScript, szLine);

  StrCopy(szLine, 'prompt');
  writeln(fScript, szLine);

  {$i-}
  StrCopy(szListFile, PathFloppy);
  StrCat(szListFile, 'ftplist.txt');
  Assign(fList, szListFile);
  reset(fList);
  {$i+}
  if IOResult <> 0 then
  begin
    SetWindowText(Dialog, '<Erreur de connexion>');
    Close(fScript);
    exit;
  end;
  {$i-}
  while not EOF(fList) do
  begin
    ReadLn(fList, szFile);
    if StrPos(szFile, '*.*') <> nil then
    begin
      SetWindowText(Dialog, '<Dossier étudiant vide>');
      Close(fScript);
      Close(fList);
      exit;
    end;
    szFile[FTPSIZE - 1] := #0;
    szFile[FTPHOUR - 1] := #0;
    szFile[FTPMIN + 2] := #0;
    szFile[FTPFILENAME - 1] := #0;
    StrCopy(szLocalFile, PathEleves);
    StrCat(szLocalFile, szStudent);
    StrCat(szLocalFile, '\');
    StrCat(szLocalFile, szLesson);
    StrCat(szLocalFile, '\');
    StrCat(szLocalFile, @szFile[FTPFILENAME]);
    DosError := FindFirst(szLocalFile, faAnyFile, FileInfo);
    if DosError = 0 then
    begin
      Val(PChar(@szFile[28]), lRemoteFileSize, code);
      if code = 0 then
      begin
        UnpackTime(FileInfo.Time, dt);
        wvsprintf(szTime, '%.02d:%.02d', @dt.Hour);
        {WriteLn('"', szTime, '" "', PCHAR(@szFile[FTPHOUR]), '"');}
        if (FileInfo.Size <> lRemoteFileSize) or
          (StrComp(szTime, PChar(@szFile[FTPHOUR])) <> 0) then
        begin
          {WriteLn('local file ', PCHAR(@szFile[FTPFILENAME]), ' need to be updated.');}
          Inc(nbUpdate);
          StrCopy(szLine, 'get ');
          StrCat(szLine, PChar(@szFile[FTPFILENAME]));
          writeln(fScript, szLine);
        end
        else
        begin
          {WriteLn('local file ', PCHAR(@szFile[FTPFILENAME]), ' is up to date.');}
        end;
      end
      else
      begin
        {WriteLn('Error extracting remote file size.');}
      end;
    end
    else
    begin
      {WriteLn('File ', PCHAR(@szFile[FTPFILENAME]),' does not exist on local drive.');}
      Inc(nbUpdate);
      StrCopy(szLine, 'get ');
      StrCat(szLine, PChar(@szFile[FTPFILENAME]));
      writeln(fScript, szLine);
    end;
  end;
  FindClose(FileInfo);
  Close(fList);
  {$i+}
  InOutRes := 0;

  StrCopy(szLine, 'bye');
  writeln(fScript, szLine);

  Close(fScript);

  if nbUpdate > 0 then
  begin
    wvsprintf(szLine, '<Téléchargement de %d fichier(s) en cours>', @nbUpdate);
    SetWindowText(Dialog, szLine);

    GetWindowsDirectory(szFtpPath, SizeOf(szFtpPath));
    StrCat(szFtpPath, '\command.com /cftp.exe -s:ftp.scr');
    Exec(hInst, hWin, hMenu, 'open', szFtpPath, PathFloppy);
    if hWin <> 0 then
      WaitEnd(hWin);

    SetWindowText(Dialog, '<Synchonisation avec le serveur en cours>');

    {$i-}
    StrCopy(szListFile, PathFloppy);
    StrCat(szListFile, 'ftplist.txt');
    Assign(fList, szListFile);
    reset(fList);
    while not EOF(fList) do
    begin
      ReadLn(fList, szFile);
      szFile[FTPSIZE - 1] := #0;
      szFile[FTPHOUR - 1] := #0;
      szFile[FTPMIN + 2] := #0;
      szFile[FTPFILENAME - 1] := #0;
      StrCopy(szLocalFile, PathEleves);
      StrCat(szLocalFile, szStudent);
      StrCat(szLocalFile, '\');
      StrCat(szLocalFile, szLesson);
      StrCat(szLocalFile, '\');
      StrCat(szLocalFile, @szFile[FTPFILENAME]);
      DosError := FindFirst(szLocalFile, faAnyFile, FileInfo);
      if DosError = 0 then
      begin
        UnpackTime(FileInfo.Time, dt);
        wvsprintf(szTime, '%.02d:%.02d', @dt.Hour);
        {WriteLn('"', szTime, '" "', PCHAR(@szFile[FTPHOUR]), '"');}
        if (StrComp(szTime, PChar(@szFile[FTPHOUR])) <> 0) then
        begin
          {WriteLn('Local file ', PCHAR(@szFile[FTPFILENAME]), ' is not sync.');}
          szFile[FTPHOUR + 2] := #0;
          Val(PChar(@szFile[FTPHOUR]), dt.Hour, code);
          Val(PChar(@szFile[FTPMIN]), dt.Min, code);

          PackTime(dt, FileInfo.Time);
          Assign(f, szLocalFile);
          reset(f);
          SetFTime(f, FileInfo.Time);
          Close(f);

          FindClose(FileInfo);
          DosError := FindFirst(szLocalFile, faAnyFile, FileInfo);
          UnpackTime(FileInfo.Time, dt);
          wvsprintf(szTime, '%.02d:%.02d', @dt.Hour);
          {WriteLn('Time is now "', szTime, '" "', PCHAR(@szFile[48]), '"');}
        end
        else
        begin
          {WriteLn('local file ', PCHAR(@szFile[FTPFILENAME]), ' is sync.');}
        end;
      end
      else
      begin
        {WriteLn('File ', PCHAR(@szFile[FTPFILENAME]),' does not exist on local drive.');}
      end;
    end;
    Close(fList);
    FindClose(FileInfo);
    {$i+}
    InOutRes := 0;

    SetWindowText(Dialog, '<Synchonisation avec le serveur terminée>');
  end
  else
  begin
    SetWindowText(Dialog, '<Dossier déjà à jours>');
  end;

  {$i-}
  StrCopy(szLocalFile, PathEleves);
  StrCat(szLocalFile, szStudent);
  StrCat(szLocalFile, '\');
  StrCat(szLocalFile, szLesson);
  StrCat(szLocalFile, '\ETUDIANT.LST');
  Assign(fEtudiant, szLocalFile);
  reset(fEtudiant);
  Read(fEtudiant, tEtudiant);
  Close(fEtudiant);
  {$i+}
  if IOResult = 0 then
  begin
    wvsprintf(szLocalFile, '<%d nouveaux fichiers>', @nbUpdate);
    SetWindowText(Dialog, szLocalFile);
    SetEtudiantRec(NoElev, tEtudiant);
  end;

end;

procedure BackupReponses(NoElev: longint; tEtudiant: TypeEtudiant; bErase: BOOL);
var
  f: file;
  DirInfo: TSearchRec;
  FileInfo: TSearchRec;
  Dir, PropositionName, CommandLine: szLongName;
  Message: TMsg;
  NumTasks: word;
  ExitCopy: boolean;
  MSG: TMSG;
  wDrvTyp: word;
  szStudent: array[0..255] of char;
  szCurDir, szLesson: array[0..255] of char;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 137, 0, 0, 0, nil, True);
  {$ENDIF}

  SetCursor(LoadCursor(0, IDC_WAIT));
  EleveRep(Dir, NoElev);

  StrCopy(CommandLine, Dir);
  StrCat(CommandLine, '\*.WAV');
  DosError := FindFirst(CommandLine, faArchive, FileInfo);
  if DosError = 0 then
  begin
    StrCopy(CommandLine, Dir);
    StrCat(CommandLine, '\');
    StrCat(CommandLine, PChar(FileInfo.Name));
    NumTasks := 0; //GetNumTasks;
    ShellExecute(window, nil, 'WAVCOMP.EXE', CommandLine, Dir, SW_HIDE);
    repeat
      if PeekMessage(Message, 0, 0, 0, PM_REMOVE) then
      begin
        TranslateMessage(Message);
        DispatchMessage(Message);
        SetCursor(LoadCursor(0, IDC_WAIT));
      end;
    until NumTasks = 0; // GetNumTasks;
    SetCursor(LoadCursor(0, IDC_ARROW));
  end;
  FindClose(FileInfo);

  wDrvTyp := GetDriveType(Ord(UpCase(PathFloppy[0])) - Ord('A'));
  if wDrvTyp = DRIVE_REMOVABLE then
    MessageBox(Window, mmLoadString(hInstRes, STR_INSERTDISK), '', MB_OK or
      MB_ICONEXCLAMATION);
  while PeekMessage(MSG, 0, 0, 0, PM_REMOVE) do
  begin
    TranslateMessage(MSG);
    DispatchMessage(MSG);
  end;
  SetCursor(LoadCursor(0, IDC_WAIT));

  GetDosName(szStudent, tEtudiant.Nom);
  GetDosName(szLesson, tEtudiant.LessonName);
  StrCat(szStudent, '\');
  StrCat(szStudent, szLesson);

  StrECopy(StrECopy(PathFichier, PathFloppy), szStudent);
  CreerRep(PathFichier);
  StrECopy(StrECopy(StrECopy(PathFichier, PathFloppy), szStudent), '\ETUDIANT.LST');
  {--ResetIOResult--}
  InOutRes := 0;
  {$i-}
  Assign(fEtudiant, PChar(PathFichier));
  rewrite(fEtudiant);
  Write(fEtudiant, tEtudiant);
  Close(fEtudiant);
  {$i+}
  GetCurrentDirectory(SizeOF(szCurDir), szCurDir);
  SetCurrentDirectory(Dir);
  ExitCopy := False;
  if DosError = 0 then
  begin
    DosError := FindFirst('*.*', faArchive, FileInfo);
    while DosError = 0 do
    begin
      StrECopy(StrECopy(StrECopy(PropositionName, PathFloppy), szStudent), '\');
      StrCat(PropositionName, PChar(FileInfo.Name));
      while not FastCopyFile(PChar(FileInfo.Name), PropositionName) and not ExitCopy do
      begin
        case CopyError of
          $0002: StrCopy(szMessage, mmLoadString(hInstRes, STR_INSNEXTDISK));
          LZERROR_WRITE,
          LZERROR_BADOUTHANDLE: StrCopy(szMessage, mmLoadString(hInstRes, STR_INSERTDISK));
          else
            CopyErrorMessage(szMessage);
        end;
        SetCursor(LoadCursor(0, IDC_ARROW));
        ExitCopy := MessageBox(Window, szMessage, '', MB_OKCANCEL or
          MB_ICONEXCLAMATION) = idCancel;
        while PeekMessage(MSG, 0, 0, 0, PM_REMOVE) do
        begin
          TranslateMessage(MSG);
          DispatchMessage(MSG);
        end;
        SetCursor(LoadCursor(0, IDC_WAIT));
      end;
      if bErase then
      begin
        {$I-}
        Assign(f, FileInfo.Name);
        erase(f);
        {$I+}
      end;
      DosError := FindNext(FileInfo);
    end;
    StrECopy(StrECopy(StrECopy(PropositionName, PathFloppy), szStudent), '\');
    StrCat(PropositionName, '..\Repelev.stm');
    FastCopyFile('..\Repelev.stm', PropositionName);
  end;
  FindClose(FileInfo);
  SetCurrentDirectory(szCurDir);
  SetCursor(LoadCursor(0, IDC_ARROW));
end;

procedure RestoreReponsesInit(NoElev: longint; var tEtudiant: TypeEtudiant);
var
  f: file;
  fEtudiant: file of TypeEtudiant;
  DirInfo: TSearchRec;
  FileInfo: TSearchRec;
  Dir, PathFichier, PropositionName, CommandLine: szLongName;
  Message: TMsg;
  NumTasks: word;
  Restore, ExitCopy: boolean;
  MSG: TMSG;
  wDrvTyp: word;
  szStudent: array[0..255] of char;
  szCurDir, szLesson: array[0..255] of char;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 138, 0, 0, 0, nil, True);
  {$ENDIF}

  EleveRep(Dir, NoElev);

  SetCursor(LoadCursor(0, IDC_ARROW));
  wDrvTyp := GetDriveType(Ord(UpCase(PathFloppy[0])) - Ord('A'));
  if wDrvTyp = DRIVE_REMOVABLE then
    MessageBox(Window, mmLoadString(hInstRes, STR_INSANSDISK), '', MB_OK or
      MB_ICONEXCLAMATION);

  {while PeekMessage(MSG, 0, 0, 0, PM_REMOVE) do begin
    TranslateMessage(MSG);
    DispatchMessage(MSG);
  end;}

  SetCursor(LoadCursor(0, IDC_WAIT));
  ExitCopy := False;
  Restore := True;
  GetCurrentDirectory(SizeOf(szCurDir), szCurDir);

  StrCopy(CommandLine, PathFloppy);
  GetDosName(szStudent, tEtudiant.Nom);
  StrCat(CommandLine, szStudent);
  StrCat(CommandLine, '\*.*');
  DosError := FindFirst(CommandLine, faDirectory, DirInfo);
  while DosError = 0 do
  begin

    if (StrComp(PChar(DirInfo.Name), '.') <> 0) and
      (StrComp(PChar(DirInfo.Name), '..') <> 0) then
    begin

      GetDosName(szStudent, tEtudiant.Nom);
      StrCat(szStudent, '\');
      StrCat(szStudent, PChar(DirInfo.Name));
      StrECopy(StrECopy(StrECopy(PathFichier, PathFloppy), szStudent), '\ETUDIANT.LST');
      {--ResetIOResult--}
      InOutRes := 0;
      {$i-}
      Assign(fEtudiant, PChar(PathFichier));
      FileMode := OF_SHARE_DENY_NONE or OF_READ;
      reset(fEtudiant);
      Read(fEtudiant, tEtudiant);
      Close(fEtudiant);
      FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;
      {$i+}
      if IOResult = 0 then
      begin

        SetEtudiantRec(NoElev, tEtudiant);
        EleveRep(Dir, NoElev);
        {WriteLn('?', PathFichier, ' ', Dir);}
        Restore := True;

        while Restore do
        begin
          StrECopy(StrECopy(PathFichier, PathFloppy), szStudent);
          SetCurrentDirectory(PathFichier);
          {WriteLn(PathFichier, ' -> ', Dir, ' ', DosError);}
          if DosError = 0 then
          begin
            SendDlgItemMessage(hRestore, 101, LB_ADDSTRING, 0, DWORD(@tEtudiant.LessonName));
          end;
          SetCursor(LoadCursor(0, IDC_ARROW));
          if wDrvTyp = DRIVE_REMOVABLE then
          begin
            Restore := MessageBox(Window, mmLoadString(hInstRes, STR_INSLASTDISK)
              , '', MB_OKCANCEL or MB_ICONEXCLAMATION) = idOk;
          end
          else
          begin
            Restore := False;
          end;
        end;
      end;
      while PeekMessage(MSG, 0, 0, 0, PM_REMOVE) do
      begin
        TranslateMessage(MSG);
        DispatchMessage(MSG);
      end;
      SetCursor(LoadCursor(0, IDC_WAIT));
    end;
    DosError := FindNext(DirInfo);
  end;
  FindClose(DirInfo);
  SetCurrentDirectory(szCurDir);
  SetCursor(LoadCursor(0, IDC_ARROW));
end;

procedure RestoreReponsesDone(NoElev: longint; var tEtudiant: TypeEtudiant);
var
  f: file;
  fEtudiant: file of TypeEtudiant;
  DirInfo: TSearchRec;
  FileInfo: TSearchRec;
  Dir, PathFichier, PropositionName, CommandLine: szLongName;
  Message: TMsg;
  NumTasks: word;
  Restore, ExitCopy: boolean;
  MSG: TMSG;
  wDrvTyp: word;
  szStudent: array[0..255] of char;
  szCurDir, szLesson: array[0..255] of char;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 138, 0, 0, 0, nil, True);
  {$ENDIF}

  EleveRep(Dir, NoElev);

  SetCursor(LoadCursor(0, IDC_ARROW));
  wDrvTyp := GetDriveType(Ord(UpCase(PathFloppy[0])) - Ord('A'));
  if wDrvTyp = DRIVE_REMOVABLE then
    MessageBox(Window, mmLoadString(hInstRes, STR_INSANSDISK), '', MB_OK or
      MB_ICONEXCLAMATION);

  {while PeekMessage(MSG, 0, 0, 0, PM_REMOVE) do begin
    TranslateMessage(MSG);
    DispatchMessage(MSG);
  end;}

  SetCursor(LoadCursor(0, IDC_WAIT));
  ExitCopy := False;
  Restore := True;
  GetCurrentDirectory(SizeOF(szCurDir), szCurDir);

  StrCopy(CommandLine, PathFloppy);
  GetDosName(szStudent, tEtudiant.Nom);
  StrCat(CommandLine, szStudent);
  StrCat(CommandLine, '\*.*');
  DosError := FindFirst(CommandLine, faDirectory, DirInfo);
  while DosError = 0 do
  begin

    if (StrComp(PChar(DirInfo.Name), '.') <> 0) and
      (StrComp(PChar(DirInfo.Name), '..') <> 0) then
    begin

      GetDosName(szStudent, tEtudiant.Nom);
      StrCat(szStudent, '\');
      StrCat(szStudent, PChar(DirInfo.Name));
      StrECopy(StrECopy(StrECopy(PathFichier, PathFloppy), szStudent), '\ETUDIANT.LST');
      {--ResetIOResult--}
      InOutRes := 0;
      {$i-}
      Assign(fEtudiant, PChar(PathFichier));
      FileMode := OF_SHARE_DENY_NONE or OF_READ;
      reset(fEtudiant);
      Read(fEtudiant, tEtudiant);
      Close(fEtudiant);
      FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;
      {$i+}
      if (IOResult = 0) and (SendDlgItemMessage(hRestore, 101,
        LB_GETSEL, SendDlgItemMessage(hRestore, 101, LB_FINDSTRINGEXACT,
        0, DWORD(@tEtudiant.LessonName)), 0) > 0) then
      begin

        StrCopy(szStartLesson, tEtudiant.LessonName);

        SetEtudiantRec(NoElev, tEtudiant);
        EleveRep(Dir, NoElev);
        {WriteLn('?', PathFichier, ' ', Dir);}
        Restore := True;

        while Restore do
        begin
          StrECopy(StrECopy(PathFichier, PathFloppy), szStudent);
          SetCurrentDirectory(PathFichier);
          {WriteLn(PathFichier, ' -> ', Dir, ' ', DosError);}
          if DosError = 0 then
          begin
            DosError := FindFirst('*.*', faArchive, FileInfo);
            while DosError = 0 do
            begin
              StrCopy(PropositionName, Dir);
              StrCat(PropositionName, '\');
              StrCat(PropositionName, PChar(FileInfo.Name));
              {case PropositionName[StrLen(PropositionName)-3] of
                'B' : PropositionName[StrLen(PropositionName)-1] := 'P';
                'T' : PropositionName[StrLen(PropositionName)-1] := 'T';
                'W' : PropositionName[StrLen(PropositionName)-1] := 'V';
                'L' : PropositionName[StrLen(PropositionName)-1] := 'T';
              end;}
              {WriteLn(FileInfo.Name, ' -> ', PropositionName);}
              while not CopyFile(PChar(FileInfo.Name), PropositionName) and not ExitCopy do
              begin
                CopyErrorMessage(szMessage);
                SetCursor(LoadCursor(0, IDC_ARROW));
                ExitCopy := MessageBox(Window, szMessage, '', MB_OKCANCEL or
                  MB_ICONEXCLAMATION) = idCancel;
                while PeekMessage(MSG, 0, 0, 0, PM_REMOVE) do
                begin
                  TranslateMessage(MSG);
                  DispatchMessage(MSG);
                end;
                SetCursor(LoadCursor(0, IDC_WAIT));
              end;
              {$I-}
              {Assign(f,FileInfo.Name);
              erase(f);}
              {$I+}
              DosError := FindNext(FileInfo);
            end;
            FindClose(FileInfo);
            StrCopy(PropositionName, Dir);
            StrCat(PropositionName, '\..\Repelev.stm');
            CopyFile('..\Repelev.stm', PropositionName);
          end;
          SetCursor(LoadCursor(0, IDC_ARROW));
          if wDrvTyp = DRIVE_REMOVABLE then
          begin
            Restore := MessageBox(Window, mmLoadString(hInstRes, STR_INSLASTDISK)
              , '', MB_OKCANCEL or MB_ICONEXCLAMATION) = idOk;
          end
          else
          begin
            Restore := False;
          end;
        end;
      end;
      while PeekMessage(MSG, 0, 0, 0, PM_REMOVE) do
      begin
        TranslateMessage(MSG);
        DispatchMessage(MSG);
      end;
      SetCursor(LoadCursor(0, IDC_WAIT));
    end;
    DosError := FindNext(DirInfo);
  end;
  FindClose(DirInfo);
  SetCurrentDirectory(szCurDir);
  SetCursor(LoadCursor(0, IDC_ARROW));
end;

procedure DelAllReponseFile(NoElev: longint);
var
  DirInfo: TSearchRec;
  FileInfo: TSearchRec;
  f: file;
  Dir: array[0..79] of char;
  Drive: byte;
  PropositionName: szLongName;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 139, 0, 0, 0, nil, True);
  {$ENDIF}

  EleveRoot(PropositionName, NoElev);
  SetCurrentDirectory(PropositionName);
  if DosError = 0 then
  begin
    DosError := FindFirst('*.*', faDirectory, DirInfo);
    while DosError = 0 do
    begin
      if DirInfo.Name[1] <> '.' then
      begin
        EleveRoot(PropositionName, NoElev);
        StrCat(PropositionName, '\');
        StrCat(PropositionName, PChar(DirInfo.Name));
        SetCurrentDirectory(PropositionName);
        if DosError = 0 then
        begin
          DosError := FindFirst('*.*', faArchive, FileInfo);
          while DosError = 0 do
          begin
            {$I-}
            Assign(f, FileInfo.Name);
            erase(f);
            {$I+}
            InOutRes := 0;
            DosError := FindNext(FileInfo);
          end;
          FindClose(FileInfo);
        end;
      end;
      DosError := FindNext(DirInfo);
    end;
  end;
  FindClose(DirInfo);
end;

procedure InitEtudiantLst;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 140, 0, 0, 0, nil, True);
  {$ENDIF}

  {StrCopy(PathFichier,PathServeur);
  StrCat(PathFichier,PathLavac);}
  StrCopy(PathFichier, PathProf);
  StrCat(PathFichier, 'ETUDIANT.LST');
  if not FileExist(PathFichier) then
  begin
    Assign(fEtudiant, PChar(PathFichier));
    rewrite(fEtudiant);
    Close(fEtudiant);
    GetfAttr(fEtudiant, wReturn);
    SetfAttr(fEtudiant, wReturn or faShare); {SHARE Flag}
  end;
end;

function GetEtudiantRec(No: longint; var tEtudiant: TypeEtudiant): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 141, 0, 0, 0, nil, True);
  {$ENDIF}

  if (No = 0) then
    with tEtudiant do
    begin
      FillChar(tEtudiant, SizeOf(tEtudiant), 0);
      StrCopy(Nom, 'Createur');
      StrCopy(LessonName, tLecon.Nom);
     {Position        : LongInt;
     Appel           : Bool;
     LeconEnCours    : Integer;
     QuestionEnCours : Integer;
     ReponseEnCours  : Integer;
     Score           : Integer;
     MaxPoints       : Integer;
     MinPoints       : Integer;}
      exit;
    end;

  if (No <= 0) or (No > MAXELEVE) then
  begin
    FillChar(tEtudiant, SizeOf(tEtudiant), 0);
    exit;
  end;
  GetEtudiantRec := False;
  {StrCopy(PathFichier,PathServeur);
  StrCat(PathFichier,PathLavac);}
  StrCopy(PathFichier, PathProf);
  StrCat(PathFichier, 'ETUDIANT.LST');
  {--ResetIOResult--}
  InOutRes := 0;
  {$i-}
  Assign(fEtudiant, PChar(PathFichier));
  FileMode := OF_SHARE_DENY_NONE or OF_READ;
  reset(fEtudiant);
  Seek(fEtudiant, No - 1);
  Read(fEtudiant, tEtudiant);
  Close(fEtudiant);
  FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;
  {$i+}
  if IOResult = 0 then
    GetEtudiantRec := True;
end;

function SetEtudiantRec(No: longint; var tEtudiant: TypeEtudiant): boolean;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 142, 0, 0, 0, nil, True);
  {$ENDIF}

  if (No <= 0) or (No > MAXELEVE) then
    exit;
  SetEtudiantRec := False;
  {StrCopy(PathFichier,PathServeur);
  StrCat(PathFichier,PathLavac);}
  StrCopy(PathFichier, PathProf);
  StrCat(PathFichier, 'ETUDIANT.LST');
  {--ResetIOResult--}
  InOutRes := 0;
  {$i-}
  Assign(fEtudiant, PChar(PathFichier));
  reset(fEtudiant);
  Seek(fEtudiant, No - 1);
  Write(fEtudiant, tEtudiant);
  Close(fEtudiant);
  {$i+}
  if IOResult = 0 then
    SetEtudiantRec := True;
end;

function GetDilateDuree(var DilateDuree: integer): boolean;
var
  f: file of shortint;
  wRet: word;
  DilatoVal: shortint = 100;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 143, 0, 0, 0, nil, True);
  {$ENDIF}

  GetDilateDuree := False;
  StrCopy(PathFichier, PathProf);
  StrCat(PathFichier, 'Dilatato.val');

  {--ResetIOResult--}
  InOutRes := 0;

  {$i-}
  FileMode := OF_SHARE_DENY_NONE or OF_READ;
  Assign(f, PChar(PathFichier));
  reset(f);
  {$i+}
  wRet := IOResult;
  if wRet <> 0 then
  begin
    WriteLn('Error ', wRet, ' opening ', PathFichier);
    exit;
  end;

  {$i-}
  Read(f, DilatoVal);
  {$i+}
  wRet := IOResult;
  if wRet <> 0 then
  begin
    WriteLn('Error ', wRet, ' reading ', PathFichier);
    exit;
  end;

  {$i-}
  Close(f);
  FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;
  {$i+}
  wRet := IOResult;
  if wRet <> 0 then
  begin
    WriteLn('Error ', wRet, ' closing ', PathFichier);
    exit;
  end;

  DilateDuree := DilatoVal;

  GetDilateDuree := True;
end;

function SetDilateDuree(DilateDuree: integer): boolean;
var
  f: file of integer;
  wReturn: word;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 144, 0, 0, 0, nil, True);
  {$ENDIF}

  SetDilateDuree := False;
  {StrCopy(PathFichier,PathServeur);
  StrCat(PathFichier,PathLavac);}
  StrCopy(PathFichier, PathProf);
  StrCat(PathFichier, 'Dilatato.val');
  {--ResetIOResult--}
  InOutRes := 0;
  {$i-}
  Assign(f, PChar(PathFichier));
  reset(f);
  {$i+}
  if IOResult <> 0 then
  begin
     {$i-}
    rewrite(f);
    GetFattr(f, wReturn);
    SetFattr(f, wReturn or faShare);
     {$i+}
  end;
  {$i-}
  Write(f, DilateDuree);
  Close(f);
  {$i+}
  MakeSharedFile(PathFichier);
  if IOResult = 0 then
    SetDilateDuree := True;
end;

procedure ReponseEtudiant(NoELEV: longint; PropositionNo: longint;
  var PropositionName: szLongName);
var
  szNo: szPName;
  tEtudiant: TypeEtudiant;
  szStudent, szLesson: szLongName;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 145, 0, 0, 0, nil, True);
  {$ENDIF}


  GetEtudiantRec(noElev, tEtudiant);
  GetDosName(szStudent, tEtudiant.Nom);
  GetDosName(szLesson, tEtudiant.LessonName);
  {StrCopy(PathFichier,PathServeur);}
  StrCopy(PathFichier, PathEleves);
  StrCat(PathFichier, szStudent);
  StrCat(PathFichier, '\');
  StrCat(PathFichier, szLesson);
  CreerRep(PathFichier);
  {StrCat(PathFichier,ELEV);
  StrPCopy(szNo, IntToStr(NoELEV));
  StrCat(PathFichier,szNo);}
  StrCat(PathFichier, '\');
  StrCat(PathFichier, R000000);
  StrPCopy(szNo, IntToStr(PropositionNo));
  StrLCopy(PropositionName, PathFichier, StrLen(PathFichier) - (StrLen(szNo) - 1));
  StrCat(PropositionName, szNo);
  StrCat(PropositionName, '.WAV');
end;

function DrawPosition(DC: HDC; hWind: hWnd;
  Position, ANote, AMax, AMin: integer): Bool;
var
  R: TRect;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 146, 0, 0, 0, nil, True);
  {$ENDIF}

  GetItemRect(GetParent(hWind), GetDlgCtrlID(hWind), R);

  { ajustement GroupBox }
  dwReturn := GetWindowLong(hWind, GWL_STYLE);
  if dwReturn and BS_GROUPBOX = BS_GROUPBOX then
    Inc(R.top, 7);

  DrawPosition := DrawPositionInRect(DC, R, Position, ANote, AMax, AMin);
end;

function DrawPositionInRect(DC: HDC; R: TRECT;
  Position, ANote, AMax, AMin: integer): Bool;
var
  nW, nH, nWdone, nWnote: integer;
  SZMess: szLongName;
  OldBr, NoteBrush: hBrush;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 147, 0, 0, 0, nil, True);
  {$ENDIF}


  with R do
  begin

    { enlève bord }
    Inc(left, 2);
    Inc(top, 2);
    Dec(right, 2);
    Dec(bottom, 2);

    nW := right - left;
    nH := bottom - top;

    { efface le fond }
    OldBr := SelectObject(DC, hFond);
    PatBlt(DC, left, top, nW, nH, PATCOPY);
    SelectObject(DC, OldBr);

    nWdone := longint(nW * Position) div 100;
    OldBr := SelectObject(DC, hDiagram);
    PatBlt(DC, left, top, nWdone, nH, PATCOPY);
    PatBlt(DC, left + nWdone, top, 1, nH, Whiteness);
    SelectObject(DC, OldBr);

    if ANote > 0 then
    begin
      NoteBrush := CreateSolidBrush(RGB(0, 255, 0));
      OldBr := SelectObject(DC, NoteBrush);
      if AMax <> 0 then
        nWnote := (nW * ANote) div AMax
      else
        nWnote := 0;
    end;
    if ANote <= 0 then
    begin
      NoteBrush := CreateSolidBrush(RGB(255, 0, 0));
      OldBr := SelectObject(DC, NoteBrush);
      if AMin <> 0 then
        nWnote := (nW * ANote) div AMin
      else
        nWnote := 0;
    end;
    if ANote = 0 then
    begin
      nWnote := 0;
    end;
    PatBlt(DC, left, top + nH div 2 + 1, nWnote, nH div 2, PATCOPY);
    PatBlt(DC, left + nWnote, top + nH div 2 + 1, 1, nH div 2, Whiteness);
    SelectObject(DC, OldBr);

  end;
  DeleteObject(NoteBrush);

  DrawPositionInRect := True;
end;

{****************************************************************}
{* S.E. Regarde le flag AVideo de la structure TypeLecon        *}
{*      si TRUE alors retourne TRUE sinon False                 *}
{****************************************************************}
function VerifieVideo(var tLecon: TypeLecon): Bool;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 148, 0, 0, 0, nil, True);
  {$ENDIF}

  VerifieVideo := False;
  if tLecon.AVideo or ChercheVideo(tLecon) then
    VerifieVideo := True;

end;

{****************************************************************}
{ SE: TRUE si on peut travailler en local FALSE sinon            }
{ SI: Regarde si le flag de LAVAC.INI autorise le travail local  }
{     Regarde si la place minimale sur disque est disponible     }
{****************************************************************}
function RechercheLocal(var tLecon: TypeLecon): Bool;

var
  nManque, nTaille, nTaille1: longint;
  Chaine1: string;
  szChaine2: szLongName;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 149, 0, 0, 0, nil, True);
  {$ENDIF}

  RechercheLocal := False;

  { Vérifie la taille sur disque local }
  if VideoLoc then
  begin
    nTaille := DiskFree(3);
    nTaille1 := TousFichierVideo(tLecon);
    if (nTaille > (TailleLoc + nTaille1)) and (nTaille > nTaille1) then
      RechercheLocal := True
    else
    begin
      nManque := (TailleLoc + nTaille1 - nTaille);
      wvsprintf(szChaine2, mmLoadString(hInstRes, ERR_LOCALSPACE), @nManque);
      VideoLoc := False;
      MessageBox(Window, szChaine2, '', MB_OK or MB_ICONEXCLAMATION);
    end;
  end;
end;

{****************************************************************}

{****************************************************************}
{             Procédure EffaceAll                                }
{ SE: Efface les fichiers précisés par szNom (chemin + nom)      }
{     Le nom peut être de la forme *.*, *.C, ...                 }
{ SI: Passe toutes les substitutions de noms possible et efface  }
{     les fichiers associés.                                     }
{****************************************************************}
procedure EffaceAll(szNom: PChar);

var
  Structfile: TSearchRec;
  f: file;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 150, 0, 0, 0, nil, True);
  {$ENDIF}

  {Recherche le premier fichier correspondant au nom}
  DosError := findfirst(szNom, faAnyFile, StructFile);
  while DosError = 0 do
  begin
    Assign(f, StructFile.Name);
    Erase(f);
    DosError := findnext(StructFile);
  end;
  FindClose(StructFile);
end;

{****************************************************************}

{****************************************************************}
{             Procédure Efface                                   }
{ SE: Efface le  fichier  précisé  par szNom (chemin + nom)      }
{****************************************************************}
procedure Efface(szNom: PChar);

var
  {f : file;}
  F: integer;
  MciCommandStr: array[0..511] of char;
  TOF: TOFSTRUCT;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 151, 0, 0, 0, nil, True);
  {$ENDIF}

  F := OpenFile(szNom, TOF, OF_DELETE or OF_SHARE_DENY_NONE);
  if F = -1 then
  begin
    WriteLn('ErrDos ', TOF.nErrCode, ' on deleting ', szNom);
  end;
  {$I-}
  {Assign(f, szNom);
  Erase(f);}
  {$I+}
  {if InOutRes <> 0 then begin
    WriteLn('ErrDos ', IOResult, ' on ', szNom);
  end;}
end;

{****************************************************************}

{****************************************************************}
{              fonction TailleFichier                            }
{ SE: Retourne la taille du fichier de nom szNom                 }
{     En cas d'erreur retourne -1                                }
{ SI: Recherche le fichier de nom szNom.                         }
{     Retourne sa taille.                                        }
{****************************************************************}
function TailleFichier(szNom: PChar): longint;

var
  StructFile: TSearchRec;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 152, 0, 0, 0, nil, True);
  {$ENDIF}

  DosError := FindFirst(szNom, faAnyFile, StructFile);
  if DosError = 0 then
    TailleFichier := StructFile.Size
  else
    TailleFichier := -1;
  FindClose(StructFile);
end;

{****************************************************************}

{****************************************************************}
{              fonction DateFichier                              }
{ SE: Retourne la date du fichier de nom szNom                   }
{     En cas d'erreur retourne -1                                }
{ SI: Recherche le fichier de nom szNom.                         }
{     Retourne sa date.                                          }
{****************************************************************}
function DateFichier(szNom: PChar): longint;

var
  StructFile: TSearchRec;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 153, 0, 0, 0, nil, True);
  {$ENDIF}

  DosError := FindFirst(szNom, faAnyFile, StructFile);
  if DosError = 0 then
    DateFichier := StructFile.Time
  else
  begin
    DateFichier := -1;
  end;
  FindClose(StructFile);
end;

{****************************************************************}

{****************************************************************}
{              fonction TousFichierVideo                         }
{ SE: Retourne la taille cumulée des fichiers AVI.               }
{     -1 sinon                                                   }
{ SI: Recherche les fichiers .AVI dans lecons.lst                }
{     Quand on en trouve un, on recherche sa taille à partir     }
{     de la structure TSearchRec.                                }
{     On ajoute les tailles.                                     }
{****************************************************************}
function TousFichierVideo(var tLecon: TypeLecon): longint;

var
  CheminLecon, CheminFichier: szLongName;
  StructFile: TSearchRec;
  f: FileOfQuestion;
  nTaille: longint;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 154, 0, 0, 0, nil, True);
  {$ENDIF}

  { Recherche des fichiers .AVI dans le répertoire de la leçon }
  StrCopy(CheminLecon, tLecon.PathLecon);
  StrCat(CheminLecon, '\QUESTION.LST');
  {--ResetIOResult--}
  InOutRes := 0;
  {$i-}
  Assign(f, PChar(CheminLecon));
  FileMode := OF_SHARE_DENY_NONE or OF_READ;
  reset(f);

  {Recherche des fichiers AVI de la leçon en lisant le fichier lecons.lst}
  nTaille := 0;
  while (InOutRes = 0) and not EOF(f) do
  begin
    SetCursor(LoadCursor(0, IDC_WAIT));
    Read(f, tQuestion);
    if IsVideoFile(tQuestion.FichierGraph) then
    begin
      {On traite un fichier AVI: on ajoute sa taille à nTaille}
      DosError := FindFirst(tQuestion.FichierGraph, faAnyFile, StructFile);
      if (DosError = 0) and (InOutRes = 0) then
        Inc(nTaille, StructFile.Size)
      else if DosError <> 0 then
      begin
        wvsprintf(szMessage, mmLoadString(hInstRes, ERR_DOSNUM), @DosError);
        MessageBox(window, szMessage, '', MB_OK);
      end;
      FindClose(StructFile);

    end;
  end;
  Close(f);
  FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;
  {$i+}
  if InOutRes <> 0 then
  begin
    wvsprintf(szMessage, mmLoadString(hInstRes, ERR_IONUM), @InOutRes);
    MessageBox(window, szMessage, '', MB_OK);
    InOutRes := 0;
  end;
  TousFichierVideo := nTaille;
end;

{****************************************************************}

{****************************************************************}
{                    fonction ChercheVideo                       }
{* S.E. Regarde Si la leçon contient un fichier .AVI            *}
{*      si oui alors retourne TRUE et modifie le champ AVideo   *}
{*      sinon retourne FALSE                                    *}
{****************************************************************}
function ChercheVideo(var tLecon: TypeLecon): boolean;

var
  CheminLecon: szLongName;
  f: FileOfQuestion;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 155, 0, 0, 0, nil, True);
  {$ENDIF}

  ChercheVideo := False;

  { Construction du chemin de la leçon en cours }
  CheminLecon := tLecon.PathLecon;

  { Recherche des fichiers .AVI dans le répertoire de la leçon }
  StrCopy(CheminLecon, tLecon.PathLecon);
  StrCat(CheminLecon, '\QUESTION.LST');
  {--ResetIOResult--}
  InOutRes := 0;
  {$i-}
  Assign(f, PChar(CheminLecon));
  FileMode := OF_SHARE_DENY_NONE or OF_READ;
  reset(f);

  {Recherche des fichiers AVI de la leçon en lisant le fichier lecons.lst}
  while (InOutRes = 0) and not EOF(f) do
  begin
    SetCursor(LoadCursor(0, IDC_WAIT));
    Read(f, tQuestion);
    if (InOutRes = 0) and IsVideoFile(tQuestion.FichierGraph) then
      ChercheVideo := True;
  end;
  FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;
  Close(f);
  {$i+}
  if InOutRes <> 0 then
  begin
    wvsprintf(szMessage, mmLoadString(hInstRes, ERR_IONUM), @InOutRes);
    MessageBox(window, szMessage, '', MB_OK);
    InOutRes := 0;
  end;
end;

{****************************************************************}

{****************************************************************}
{  S.E. Retourne le nombre de fichiers .AVI contenus dans une    }
{       leçon.                                                   }
{****************************************************************}
function CompteFichVideo(var tLecon: TypeLecon): integer;

var
  CheminLecon: szLongName;
  f: FileOfQuestion;

const
  compteur: integer = 0;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 156, 0, 0, 0, nil, True);
  {$ENDIF}

  { Construction du chemin de la leçon en cours }
  CheminLecon := tLecon.PathLecon;

  { Recherche des fichiers .AVI dans le répertoire de la leçon }
  StrCopy(CheminLecon, tLecon.PathLecon);
  StrCat(CheminLecon, '\QUESTION.LST');
  {--ResetIOResult--}
  InOutRes := 0;
  {$i-}
  Assign(f, PChar(CheminLecon));
  FileMode := OF_SHARE_DENY_NONE or OF_READ;
  reset(f);

  {Recherche des fichiers AVI de la leçon en lisant le fichier lecons.lst}
  Compteur := 0;
  while (InOutRes = 0) and not EOF(f) do
  begin
    SetCursor(LoadCursor(0, IDC_WAIT));
    Read(f, tQuestion);
    if (InOutRes = 0) and IsVideoFile(tQuestion.FichierGraph) then
      compteur := compteur + 1;
  end;
  Close(f);
  FileMode := OF_SHARE_DENY_NONE or OF_READWRITE;
  {$i+}
  if InOutRes <> 0 then
  begin
    wvsprintf(szMessage, mmLoadString(hInstRes, ERR_IONUM), @InOutRes);
    MessageBox(window, szMessage, '', MB_OK);
    InOutRes := 0;
  end;
  CompteFichVideo := compteur;
end;

{****************************************************************}

{****************************************************************}
{                  fonction VerifieQuestionVidéo                 }
{* S.E. True si le fichier est un .AVI.                          *}
{****************************************************************}
function VerifieQuestionVideo(var tQuestion: TypeQuestion): Bool;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 157, 0, 0, 0, nil, True);
  {$ENDIF}

  VerifieQuestionVideo := False;
  if IsVideoFile(tQuestion.FichierGraph) then
    VerifieQuestionVideo := True;
end;

{****************************************************************}

{****************************************************************}
{                  fonction DonneNomLocal                        }
{* SE: A partir de szName, constitue un nom de fichier dont      }
{      le chemin commence par 'C:\LAVAC\VIDEO\' cad PathVideoLoc }
{****************************************************************}
function DonneNomLocal(szName: PChar): PChar;
const
  szDir1: szLongName = '';
  szDir: szLongName = '';
var
  szNom: array[0..9] of char;
  szExt: array[0..4] of char;
  szLessonName: array[0..255] of char;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 158, 0, 0, 0, nil, True);
  {$ENDIF}

  DonneNomLocal := #0;
  FileSplit(szName, szDir1, szNom, szExt);
  StrCopy(szDir, PathVideoLoc);
  GetDosName(szLessonName, tLecon.Nom);
  StrCat(szDir, szLessonName);
  StrCat(szDir, '\');
  StrCat(szDir, szNom);
  StrCat(szDir, szExt);
  DonneNomLocal := szDir;

end;

{****************************************************************}

{****************************************************************}
{                  fonction MessageBox                           }
{* S.E. True si le fichier est un .AVI.                         *}
{****************************************************************}
procedure BoiteAlerte(szChaine: PChar);

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 159, 0, 0, 0, nil, True);
  {$ENDIF}

  MessageBox(Window, szChaine, 'Erreur', MB_OK or MB_ICONINFORMATION);
end;

{****************************************************************}

{****************************************************************}
{****************************************************************}
function AboutBoxProc(Dialog: HWnd; Message, WParam: DWord;
  LParam: longint): Bool; stdcall;
var
  szImage: szLongName;

var
  szLicence: array[0..255] of char;

const
  hDIB2: THandle = 0;
  pDIB2: PBitmapInfo = nil;
  pBits2: Pointer = nil;
  hPal2: THandle = 0;
  pPal2: PLOGPALETTE = nil;
  Palette2: HPalette = 0;

begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 160, 0, 0, 0, nil, True);
  {$ENDIF}

  AboutBoxProc := True;
  case Message of
    wm_InitDialog:
    begin

      CenterDialog(Dialog);
        {$IFDEF _ASSIST}
      LoadBitmapResource(hInstRes, 'MABITMAP', hDIB2, pDIB2, pBits2, hPal2, pPal2, Palette2);
        {$ELSE}
      LoadBitmapResource(hInstRes, MAKEINTRESOURCE(LAVAC_DIB), hDIB2,
        pDIB2, pBits2, hPal2, pPal2, Palette2);
        {$ENDIF}
      {SetDlgItemText(Dialog, 10000, mmLoadString(hInstRes, -1));}
      StrCopy(szLicence, PathLavac);
      StrCat(szLicence, 'LAVAC.LIC');
      SetDlgItemText(Dialog, 10000, licGetText(Dialog, szLicence));
    end;

    wm_paint:
    begin
      BeginPaint(Dialog, PS);
      AfficheBitmapIn(GetDlgItem(Dialog, 103), 2, 8, hDIB2, pDIB2, pBits2,
        Palette2, False, False);
      EndPaint(Dialog, PS);
    end;

    wm_Command:
    begin
      case LoWord(wParam) of
        idOk:
        begin
          ReleaseBitmapRessource(hDIB2, hPal2);
          EndDialog(Dialog, 1);
          CheckDlgButton(hMessagesProc, 204, 0);
          CheckDlgButton(hMessagesProc, 201, 1);
        end;
      end;
    end;
  end;
  AboutBoxProc := False;
end;

procedure MMLavacDone;
begin

  {$IFDEF _DEBUG}
  AddDebugFunction(FUNC_MMLAVAC, nFUNC_MMLAVAC + 161, 0, 0, 0, nil, True);
  {$ENDIF}

  GlobalUnLock(hLineBuffer);
  GlobalFree(hLineBuffer);
end;

end.

